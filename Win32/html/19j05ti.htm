<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Reading, Writing, and Locking Files</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="19j05ti"></A><B>Reading, Writing, and Locking Files</B></P>

<P>The <A HREF="cjnd8p.htm"><B>ReadFile</B></A> function requires a file handle that is open for reading, or reading and writing. <B>ReadFile</B> copies a specified number of bytes, from the current position up to the end of the file, to a specified buffer. The current position is either the current file pointer setting or the <B>Offset</B> and <B>OffsetHigh</B> members of the specified <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure. The function returns the actual number of bytes read in a variable specified by its fourth parameter. </P>

<P>The <A HREF="g0sox_.htm"><B>WriteFile</B></A> function requires a file handle that is open for writing, or writing and reading. <B>WriteFile</B> copies a specified number of bytes, from the current position up to the end of the buffer, to a specified file. The function returns the actual number of bytes written in a variable specified by its fourth parameter. </P>

<P>The following example illustrates a possible flow for using callback completion asynchronous I/O. </P>

<P><B>Completion Routine</B>: </P>

<P>VOID IoCompletionRoutine(DWORD dwErrorCode,  </P>

<P>DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped) </P>

<P>{ </P>

<P>// If an I/O error occurs, display the error and exit. </P>

<P></P>

<P>if (dwErrorCode) { </P>

<P>printf("FATAL I/O Error %ld I/O Context %lx.%lx\n", </P>

<P>dwErrorCode, lpOverlapped, lpOverlapped-&gt;hEvent); </P>

<P>ExitProcess(dwErrorCode); </P>

<P>} </P>

<P>LocalFree(lpOverlapped); </P>

<P>} </P>

<P></P>

<P><B>Main Thread</B>: </P>

<P>VOID IoWorkerThread(VOID)  </P>

<P>{ </P>

<P>HANDLE HandleVector[2]; </P>

<P>DWORD CompletionStatus; </P>

<P>PIOREQUEST IoRequestPacket; </P>

<P>LPOVERLAPPED Overlapped; </P>

<P>BOOL IoOperationStatus; </P>

<P></P>

<P>HandleVector[0] = IoWorkerListLock; </P>

<P>HandleVector[1] = IoWorkerListSemaphore; </P>

<P></P>

<P>for(;;) { </P>

<P></P>

<P>// Do an alertable wait on the handle vector. </P>

<P>Both objects </P>

<P>// being signaled at the same time means that there is an </P>

<P>// I/O request in the queue and the caller has exclusive </P>

<P>// access to the queue. </P>

<P></P>

<P>CompletionStatus = WaitForMultipleObjectsEx(2, HandleVector, </P>

<P>TRUE, INFINITE, TRUE); </P>

<P></P>

<P>// If the wait failed, error out. </P>

<P></P>

<P>if (CompletionStatus == 0xFFFFFFFF) { </P>

<P>printf("FATAL WAIT ERROR %ld\n", GetLastError()); </P>

<P>ExitProcess(1); </P>

<P>} </P>

<P>// If an I/O completion occurred, wait for another </P>

<P>// I/O request or I/O completion. </P>

<P></P>

<P>if (CompletionStatus != WAIT_IO_COMPLETION) { </P>

<P></P>

<P>// The wait was satisfied. Ownership of the I/O </P>

<P>// request queue is exclusive, and there is something in </P>

<P>// the queue. To insert something in the queue, the </P>

<P>// inserter gets the list lock (mutex), inserts an entry, </P>

<P>// signals the list semaphore, and finally releases the </P>

<P>// list lock. </P>

<P></P>

<P>IoRequestPacket = RemoveHeadList(&amp;IoRequestList); </P>

<P></P>

<P>ReleaseMutex(IoWorkerListLock); </P>

<P></P>

<P>// Allocate an overlapped structure.</P>

<P></P>

<P>Overlapped = LocalAlloc(LMEM_ZEROINIT, </P>

<P>sizeof(OVERLAPPED)); </P>

<P></P>

<P>if (!Overlapped) { </P>

<P>printf("FATAL allocation error\n"); </P>

<P>ExitProcess(1); </P>

<P>} </P>

<P></P>

<P>Overlapped-&gt;Offset = IoRequestPacket-&gt;Offset; </P>

<P>Overlapped-&gt;OffsetHigh = IoRequestPacket-&gt;OffsetHigh; </P>

<P>Overlapped-&gt;hEvent = </P>

<P>IoRequestPacket-&gt;dwAdditionalIoContext; </P>

<P></P>

<P>if (IoRequestPacket-&gt;bRead) { </P>

<P>IoOperationStatus = </P>

<P>ReadFileEx(IoRequestPacket-&gt;hFile, </P>

<P>IoRequestPacket-&gt;lpBuffer, </P>

<P>IoRequestPacket-&gt;dwTransferCount, </P>

<P>Overlapped, IoCompletionRoutine); </P>

<P>} </P>

<P>else { </P>

<P>IoOperationStatus = </P>

<P>WriteFileEx(IoRequestPacket-&gt;hFile, </P>

<P>IoRequestPacket-&gt;lpBuffer, </P>

<P>IoRequestPacket-&gt;dwTransferCount, </P>

<P>Overlapped, </P>

<P>IoCompletionRoutine); </P>

<P>} </P>

<P></P>

<P>// Test to see if the I/O was queued successfully.</P>

<P></P>

<P>if (!IoOperationStatus) { </P>

<P>printf("FATAL I/O Error %ld I/O Context %lx.%lx\n", </P>

<P>GetLastError(), Overlapped, Overlapped-&gt;hEvent); </P>

<P>ExitProcess(1); </P>

<P>} </P>

<P></P>

<P>// The I/O queued successfully. Go back into the </P>

<P>// alertable wait for I/O completion or for </P>

<P>// more I/O requests. </P>

<P></P>

<P>} </P>

<P>} </P>

<P>} </P>

<P></P>

<P>The <A HREF="1o4.z9c.htm"><B>SetFilePointer</B></A> function moves the file pointer a specified number of bytes, relative to the beginning or end of the file, or the file pointer's current position. If a positive number of bytes is specified, <B>SetFilePointer</B> moves the file pointer toward the end of the file; a negative value moves the pointer toward the beginning of the file. </P>

<P>The following example appends one file to the end of another file. The application opens two files by using <A HREF="xn35yd.htm"><B>CreateFile</B></A>: ONE.TXT is opened for reading, and TWO.TXT is opened for writing. Then the application appends the contents of ONE.TXT to the end of TWO.TXT by reading and writing 4K blocks by using <A HREF="cjnd8p.htm"><B>ReadFile</B></A> and <A HREF="g0sox_.htm"><B>WriteFile</B></A>. Before writing to the second file, the application sets the second file's pointer to the end of the file by using <B>SetFilePointer</B> and locks the area to be written by using <A HREF="egdiih.htm"><B>LockFile</B></A>. This prevents another process from accessing the area while the write is in progress. After each write operation, <A HREF="2v.n6yp.htm"><B>UnlockFile</B></A> unlocks the locked area. </P>

<P>HANDLE hFile;  </P>

<P></P>

<P>HANDLE hAppend; </P>

<P></P>

<P>DWORD  dwBytesRead, dwBytesWritten, dwPos; </P>

<P></P>

<P>char   buff[4096]; </P>

<P></P>

<P>// Open the existing file. </P>

<P></P>

<P>hFile = CreateFile("ONE.TXT",     // open ONE.TXT </P>

<P>GENERIC_READ,                 // open for reading </P>

<P>0,                            // do not share </P>

<P>NULL,                         // no security </P>

<P>OPEN_EXISTING,                // existing file only </P>

<P>FILE_ATTRIBUTE_NORMAL,        // normal file </P>

<P>NULL);                        // no attr. template </P>

<P>if (hFile == INVALID_HANDLE_VALUE) { </P>

<P>ErrorHandler("Could not open ONE.");  // process error </P>

<P>} </P>

<P></P>

<P>// Open the existing file, or if the file does not exist, </P>

<P>// create a new file. </P>

<P></P>

<P>hAppend = CreateFile("TWO.TXT",   // open TWO.TXT </P>

<P>GENERIC_WRITE,                // open for writing </P>

<P>0,                            // do not share </P>

<P>NULL,                         // no security </P>

<P>OPEN_ALWAYS,                  // open or create </P>

<P>FILE_ATTRIBUTE_NORMAL,        // normal file </P>

<P>NULL);                        // no attr. template </P>

<P>if (hAppend == INVALID_HANDLE_VALUE) { </P>

<P>ErrorHandler("Could not open TWO.");    // process error </P>

<P>} </P>

<P></P>

<P>// Append the first file to the end of the second file. </P>

<P>// Lock the second file to prevent another process from </P>

<P>// accessing it while writing to it. Unlock the </P>

<P>// file when writing is finished. </P>

<P></P>

<P>do { </P>

<P>if (ReadFile(hFile, buff, 4096, &amp;dwBytesRead, NULL)) { </P>

<P>dwPos = SetFilePointer(hAppend, 0, NULL, FILE_END); </P>

<P>LockFile(hAppend, dwPos, 0, dwPos + dwBytesRead, 0); </P>

<P>WriteFile(hAppend, buff, dwBytesRead, </P>

<P>&amp;dwBytesWritten, NULL); </P>

<P>UnlockFile(hAppend, dwPos, 0, dwPos + dwBytesRead, 0); </P>

<P>} </P>

<P>} while (dwBytesRead == 4096); </P>

<P></P>

<P>// Close both files.</P>

<P></P>

<P>CloseHandle(hFile); </P>

<P>CloseHandle(hAppend); </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
