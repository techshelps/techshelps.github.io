<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Setting Fonts for Menu-Item Text Strings</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="0i.1yl"></A><B>Setting Fonts for Menu-Item Text Strings</B></P>

<P>This topic contains an example from an application that uses owner-drawn menu items in a menu. The menu contains items that set the attributes of the current font, and the items are displayed using the appropriate font attribute.</P>

<P>Here is how the menu is defined in the resource-definition file. Note that the strings for the Regular, Bold, Italic, and Underline menu items are assigned at run time, so their strings are empty in the resource-definition file. </P>

<P>MainMenu MENU  </P>

<P>BEGIN </P>

<P>POPUP   "&amp;Character" </P>

<P>BEGIN </P>

<P>MENUITEM    "",    IDM_REGULAR </P>

<P>MENUITEM SEPARATOR </P>

<P>MENUITEM    "",    IDM_BOLD </P>

<P>MENUITEM    "",    IDM_ITALIC </P>

<P>MENUITEM    "",    IDM_ULINE </P>

<P>END </P>

<P>END </P>

<P></P>

<P>The application's window procedure processes the messages involved in using owner-drawn menu items. The application uses the <A HREF="2re1yt3.htm">WM_CREATE</A> message to do the following: </P>

<P>·Set the MF_OWNERDRAW flag for the menu items. </P>

<P>·Set the text strings for the menu items. </P>

<P>·Obtain handles of the fonts used to draw the items. </P>

<P>·Obtain the text and background color values for selected menu items. </P>

<P></P>

<P>The text strings and font handles are stored in an array of application-defined MYITEM structures. The application-defined GetAFont function creates a font that corresponds to the given font attribute and returns the handle of the font. The handles are destroyed during the processing of the <A HREF="0yqmho.htm">WM_DESTROY</A> message. </P>

<P>During the processing of the <A HREF=".a2o7n.htm">WM_MEASUREITEM</A> message, the example gets the width and height of a menu-item string and copies these values into the <A HREF="5k1k_8r.htm"><B>MEASUREITEMSTRUCT</B></A> structure. Windows uses the width and height values to calculate the size of the  menu. </P>

<P>During the processing of the <A HREF="70lqx9p.htm">WM_DRAWITEM</A> message, the menu item's string is drawn with room left next to the string for the check-mark bitmap. If the user selects the item, the selected text and background colors are used to draw the item. </P>

<P>LRESULT APIENTRY MainWndProc(hwnd, uMsg, wParam, lParam)  </P>

<P>HWND hwnd; </P>

<P>UINT uMsg; </P>

<P>WPARAM wParam; </P>

<P>LPARAM lParam; </P>

<P>{ </P>

<P></P>

<P>typedef struct _MYITEM { </P>

<P>HFONT hfont; </P>

<P>LPSTR psz; </P>

<P>} MYITEM;             // structure for item font and string  </P>

<P></P>

<P>MYITEM *pmyitem;      // pointer to item's font and string        </P>

<P>static MYITEM myitem[CITEMS];   // array of MYITEMS               </P>

<P>static HMENU hmenu;             // handle of main menu            </P>

<P>static COLORREF crSelText;  // text color of selected item        </P>

<P>static COLORREF crSelBkgnd; // background color of selected item  </P>

<P>COLORREF crText;            // text color of unselected item      </P>

<P>COLORREF crBkgnd;           // background color unselected item   </P>

<P>LPMEASUREITEMSTRUCT lpmis;  // points to item of data             </P>

<P>LPDRAWITEMSTRUCT lpdis;     // points to item drawing data        </P>

<P>HDC hdc;                    // handle of screen DC                </P>

<P>SIZE size;                  // menu-item text extents             </P>

<P>DWORD dwCheckXY;            // check-mark dimensions              </P>

<P>WORD wCheckX;               // check-mark width                   </P>

<P>int nTextX;                 // width of menu item                 </P>

<P>int nTextY;                 // height of menu item                </P>

<P>int i;                      // loop counter                       </P>

<P>HFONT hfontOld;             // handle of old font                 </P>

<P>BOOL fSelected = FALSE;     // menu-item selection flag           </P>

<P></P>

<P>switch (uMsg) { </P>

<P>case WM_CREATE: </P>

<P></P>

<P>// Modify the Regular, Bold, Italic, and Underline </P>

<P>// menu items to make them owner-drawn items. Associate </P>

<P>// a MYITEM structure with each item to contain the </P>

<P>// string and font handle for each item. </P>

<P></P>

<P>hmenu = GetMenu(hwnd); </P>

<P>ModifyMenu(hmenu, IDM_REGULAR, MF_BYCOMMAND | </P>

<P>MF_CHECKED | MF_OWNERDRAW, IDM_REGULAR, </P>

<P>(LPTSTR) &amp;myitem[REGULAR]); </P>

<P>ModifyMenu(hmenu, IDM_BOLD, MF_BYCOMMAND | </P>

<P>MF_OWNERDRAW, IDM_BOLD, (LPTSTR) &amp;myitem[BOLD]); </P>

<P>ModifyMenu(hmenu, IDM_ITALIC, MF_BYCOMMAND | </P>

<P>MF_OWNERDRAW, IDM_ITALIC, </P>

<P>(LPTSTR) &amp;myitem[ITALIC]); </P>

<P>ModifyMenu(hmenu, IDM_ULINE, MF_BYCOMMAND | </P>

<P>MF_OWNERDRAW, IDM_ULINE, (LPTSTR) &amp;myitem[ULINE]); </P>

<P></P>

<P>// Retrieve each item's font handle and copy it into </P>

<P>// the hfont member of each item's MYITEM structure. </P>

<P>// Also, copy each item's string into the structures. </P>

<P></P>

<P>myitem[REGULAR].hfont = GetAFont(REGULAR); </P>

<P>myitem[REGULAR].psz = "Regular"; </P>

<P>myitem[BOLD].hfont = GetAFont(BOLD); </P>

<P>myitem[BOLD].psz = "Bold"; </P>

<P>myitem[ITALIC].hfont = GetAFont(ITALIC); </P>

<P>myitem[ITALIC].psz = "Italic"; </P>

<P>myitem[ULINE].hfont = GetAFont(ULINE); </P>

<P>myitem[ULINE].psz = "Underline"; </P>

<P></P>

<P>// Retrieve the text and background colors of the </P>

<P>// selected menu text. </P>

<P></P>

<P>crSelText = GetSysColor(COLOR_HIGHLIGHTTEXT); </P>

<P>crSelBkgnd = GetSysColor(COLOR_HIGHLIGHT); </P>

<P></P>

<P>return 0; </P>

<P></P>

<P>case WM_MEASUREITEM: </P>

<P></P>

<P>// Retrieve a device context for the main window.  </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P></P>

<P>// Retrieve pointers to the menu item's </P>

<P>// MEASUREITEMSTRUCT structure and MYITEM structure. </P>

<P></P>

<P>lpmis = (LPMEASUREITEMSTRUCT) lParam; </P>

<P>pmyitem = (MYITEM *) lpmis-&gt;itemData; </P>

<P></P>

<P>// Select the font associated with the item into </P>

<P>// the main window's device context. </P>

<P></P>

<P>hfontOld = SelectObject(hdc, pmyitem-&gt;hfont); </P>

<P></P>

<P>// Retrieve the width and height of the item's string, </P>

<P>// and then copy the width and height into the </P>

<P>// MEASUREITEMSTRUCT structure's itemWidth and </P>

<P>// itemHeight members. </P>

<P></P>

<P>GetTextExtentPoint32(hdc, pmyitem-&gt;psz, </P>

<P>lstrlen(pmyitem-&gt;psz), &amp;size); </P>

<P>lpmis-&gt;itemWidth = size.cx; </P>

<P>lpmis-&gt;itemHeight = size.cy; </P>

<P></P>

<P>// Select the old font back into the device context, </P>

<P>// and then release the device context. </P>

<P></P>

<P>SelectObject(hdc, hfontOld); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P></P>

<P>return TRUE; </P>

<P></P>

<P>break; </P>

<P></P>

<P>case WM_DRAWITEM: </P>

<P></P>

<P>// Get pointers to the menu item's DRAWITEMSTRUCT </P>

<P>// structure and MYITEM structure. </P>

<P></P>

<P>lpdis = (LPDRAWITEMSTRUCT) lParam; </P>

<P>pmyitem = (MYITEM *) lpdis-&gt;itemData; </P>

<P></P>

<P>// If the user has selected the item, use the selected </P>

<P>// text and background colors to display the item. </P>

<P></P>

<P>if (lpdis-&gt;itemState &amp; ODS_SELECTED) { </P>

<P>crText = SetTextColor(lpdis-&gt;hDC, crSelText); </P>

<P>crBkgnd = SetBkColor(lpdis-&gt;hDC, crSelBkgnd); </P>

<P>fSelected = TRUE; </P>

<P>} </P>

<P></P>

<P>// Remember to leave space in the menu item for the </P>

<P>// check-mark bitmap. Retrieve the width of the bitmap </P>

<P>// and add it to the width of the menu item. </P>

<P></P>

<P>dwCheckXY = GetMenuCheckMarkDimensions(); </P>

<P>wCheckX = LOWORD(dwCheckXY); </P>

<P>nTextX = wCheckX + lpdis-&gt;rcItem.left; </P>

<P>nTextY = lpdis-&gt;rcItem.top; </P>

<P></P>

<P>// Select the font associated with the item into the </P>

<P>// item's device context, and then draw the string. </P>

<P></P>

<P>hfontOld = SelectObject(lpdis-&gt;hDC, pmyitem-&gt;hfont); </P>

<P>ExtTextOut(lpdis-&gt;hDC, nTextX, nTextY, ETO_OPAQUE, </P>

<P>&amp;lpdis-&gt;rcItem, pmyitem-&gt;psz, </P>

<P>lstrlen(pmyitem-&gt;psz), NULL); </P>

<P></P>

<P>// Select the previous font back into the device </P>

<P>// context. </P>

<P></P>

<P>SelectObject(lpdis-&gt;hDC, hfontOld); </P>

<P></P>

<P>// Return the text and background colors to their </P>

<P>// normal state (not selected). </P>

<P></P>

<P>if (fSelected) { </P>

<P>SetTextColor(lpdis-&gt;hDC, crText); </P>

<P>SetBkColor(lpdis-&gt;hDC, crBkgnd); </P>

<P>} </P>

<P></P>

<P>return TRUE; </P>

<P></P>

<P>. </P>

<P>. // Process other messages.  </P>

<P>. </P>

<P></P>

<P>case WM_DESTROY: </P>

<P></P>

<P>// Destroy the menu items' font handles.  </P>

<P></P>

<P>for (i = 0; i &lt; CITEMS; i++) </P>

<P>DeleteObject(myitem[i].hfont); </P>

<P></P>

<P>PostQuitMessage(0); </P>

<P>break; </P>

<P></P>

<P>default: </P>

<P>return DefWindowProc(hwnd, uMsg, wParam, lParam); </P>

<P>} </P>

<P>return NULL; </P>

<P>} </P>

<P></P>

<P>HFONT GetAFont(fnFont) </P>

<P>int fnFont;             // font-attribute flag             </P>

<P>{ </P>

<P>static LOGFONT lf;  // structure for font information  </P>

<P></P>

<P>// Get a handle to the ANSI fixed-pitch font, and copy </P>

<P>// information about the font to a LOGFONT structure. </P>

<P></P>

<P>GetObject(GetStockObject(ANSI_FIXED_FONT), sizeof(LOGFONT), </P>

<P>&amp;lf); </P>

<P></P>

<P>// Set the font attributes, as appropriate.  </P>

<P></P>

<P>if (fnFont == BOLD) </P>

<P>lf.lfWeight = FW_BOLD; </P>

<P>else </P>

<P>lf.lfWeight = FW_NORMAL; </P>

<P></P>

<P>lf.lfItalic = (fnFont == ITALIC); </P>

<P>lf.lfItalic = (fnFont == ULINE); </P>

<P></P>

<P>// Create the font, and then return its handle.  </P>

<P></P>

<P>return CreateFont(lf.lfHeight, lf.lfWidth, </P>

<P>lf.lfEscapement, lf.lfOrientation, lf.lfWeight, </P>

<P>lf.lfItalic, lf.lfUnderline, lf.lfStrikeOut, lf.lfCharSet, </P>

<P>lf.lfOutPrecision, lf.lfClipPrecision, lf.lfQuality, </P>

<P>lf.lfPitchAndFamily, lf.lfFaceName); </P>

<P>} </P>

<P></P>

</BODY>
</HTML>
