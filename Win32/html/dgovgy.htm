<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>CryptVerifySignature [New - Windows NT] [New - Windows 95, OEM Service Release 2]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="dgovgy"></A><B>CryptVerifySignature  <A HREF=".j_o55.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="41b3l2.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="rkgz3o.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>[New - Windows 95, OEM Service Release 2]</P>

<P>The <B>CryptVerifySignature</B> function is used to verify a signature against a hash object.</P>

<P>Before calling this function, the <A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A> function must be called to get a handle to a hash object. The <A HREF="46c7fgj.htm"><B>CryptHashData</B></A> and/or <A HREF="21hhdd_.htm"><B>CryptHashSessionKey</B></A> functions are then used to add the data and/or session keys to the hash object.</P>

<P>Once this function has been completed, the only hash function that can be called using the <I>hHash</I> handle is the <A HREF="1rbk0dy.htm"><B>CryptDestroyHash</B></A> function.</P>

<P><B>BOOL CRYPTFUNC CryptVerifySignature(</B></P>

<TABLE cols=2 width=227>

<TR VALIGN="top">
<TD width=85%><B>HCRYPTHASH </B><I>hHash</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    BYTE *</B><I>pbSignature</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwSigLen</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    HCRYPTKEY </B><I>hPubKey</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    LPCTSTR </B><I>sDescription</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwFlags</I></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>   );</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hHash</I></P>

<P>[in] A handle to the hash object to verify against.</P>

<P><I>pbSignature</I></P>

<P>[in] The address of the signature data to be verified.</P>

<P><I>dwSigLen</I></P>

<P>[in] The number of bytes in the <I>pbSignature</I> signature data.</P>

<P><I>hPubKey</I></P>

<P>[in] A handle to the public key to use to authenticate the signature. This public key must belong to the key pair that was originally used to create the digital signature.</P>

<P><I>sDescription</I></P>

<P>[in] String describing the signed data. This must be exactly the same string that was passed in to the <A HREF="bod3zd.htm"><B>CryptSignHash</B></A> function when the signature was created. If this string does not match, the signature verification will fail.</P>

<P>When this function is called, some CSPs (not the Microsoft RSA Base Provider) will display this description string to the user, together with an indication of whether the signature verified correctly. This provides the user with the verification results in a way that is completely independent of the application.</P>

<P><I>dwFlags</I></P>

<P>[in] The flag values. This parameter is reserved for future use and should always be zero.</P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To retrieve extended error information, use the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function.</P>

<P>The following table lists the error codes most commonly returned by the <B>GetLastError</B> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=47%>&nbsp;</TD>
<TD width=53%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_HANDLE</TD>
<TD width=53%>One of the parameters specifies an invalid handle.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_PARAMETER</TD>
<TD width=53%>One of the parameters contains an invalid value. This is most often an illegal pointer.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_FLAGS</TD>
<TD width=53%>The <I>dwFlags</I> parameter is nonzero.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_HASH</TD>
<TD width=53%>The hash object specified by the <I>hHash</I> parameter is invalid.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_KEY</TD>
<TD width=53%>The <I>hPubKey</I> parameter does not contain a handle to a valid public key.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_SIGNATURE</TD>
<TD width=53%>The signature failed to verify. This could be because the data itself has changed, the description string did not match, or the wrong public key was specified by <I>hPubKey</I>.
<P>This error can also be returned if the hashing or signature algorithms do not match the ones used to create the signature.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_UID</TD>
<TD width=53%>The CSP context that was specified when the hash object was created cannot be found.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_NO_MEMORY</TD>
<TD width=53%>The CSP ran out of memory during the operation.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Example</B></P>

<P>#include &lt;wincrypt.h&gt;</P>

<P></P>

<P>HCRYPTPROV hProv = 0;</P>

<P>#define BUFFER_SIZE 256</P>

<P>BYTE pbBuffer[BUFFER_SIZE];</P>

<P>HCRYPTHASH hHash = 0;</P>

<P>HCRYPTKEY hPubKey = 0;</P>

<P>BYTE *pbSignature = NULL;</P>

<P>DWORD dwSigLen;</P>

<P>LPTSTR szDescription = NULL;</P>

<P>// Get handle to the default provider.</P>

<P>if(!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0)) {</P>

<P>printf("Error %x during CryptAcquireContext!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Load 'pbBuffer' with 'BUFFER_SIZE' bytes of test data. This must</P>

<P>// be the same data that was originally signed.</P>

<P>...</P>

<P></P>

<P>// Point 'pbSignature' at the signature created by a previous call</P>

<P>// to CryptSignHash. Set 'dwSigLen' to the number of bytes in the</P>

<P>// signature.</P>

<P>...</P>

<P></P>

<P>// Point 'szDescription' at some text describing the data being  </P>

<P>// signed. This must be the same description text that was originally</P>

<P>// passed to CryptSignHash.</P>

<P>...</P>

<P></P>

<P>// Get public key of the user that created the digital signature </P>

<P>// and import it into the CSP using CryptImportKey. This will return</P>

<P>// a handle to the public key in 'hPubKey'.</P>

<P>...</P>

<P></P>

<P>// Create hash object.</P>

<P>if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash)) {</P>

<P>printf("Error %x during CryptCreateHash!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Hash buffer.</P>

<P>if(!CryptHashData(hHash, pbBuffer, BUFFER_SIZE, 0)) {</P>

<P>printf("Error %x during CryptHashData!\n", GetLastError());</P>

<P>goto done;</P>

<P>}</P>

<P>// Validate digital signature.</P>

<P>if(!CryptVerifySignature(hHash, pbSignature, dwSigLen, hPubKey, szDescription, 0)) {</P>

<P>if(GetLastError() == NTE_BAD_SIGNATURE) {</P>

<P>printf("Signature failed to validate!\n");</P>

<P>} else {</P>

<P>printf("Error %x during CryptSignHash!\n", GetLastError());</P>

<P>}</P>

<P>} else {</P>

<P>printf("Signature validated OK\n");</P>

<P>}</P>

<P></P>

<P>done:</P>

<P>...</P>

<P>// Release public key.</P>

<P>if(hPubKey != 0) CryptDestroyKey(hPubKey);</P>

<P>// Destroy hash object.</P>

<P>if(hHash != 0) CryptDestroyHash(hHash);</P>

<P>// Release provider handle.</P>

<P>if(hProv != 0) CryptReleaseContext(hProv, 0);</P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A>, <A HREF="1rbk0dy.htm"><B>CryptDestroyHash</B></A>, <A HREF="46c7fgj.htm"><B>CryptHashData</B></A>, <A HREF="21hhdd_.htm"><B>CryptHashSessionKey</B></A>, <A HREF="bod3zd.htm"><B>CryptSignHash</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
