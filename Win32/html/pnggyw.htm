<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Finding Text</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="pnggyw"></A><B>Finding Text</B></P>

<P>This topic describes sample code that displays and manages a Find dialog box so the user can specify the parameters of a search operation. The dialog box sends messages to your window procedure so you can perform the search operation. </P>

<P>The code for displaying and managing a Replace dialog box is similar, except that it uses the <A HREF="1s0xwwr.htm"><B>ReplaceText</B></A> function to display the dialog box. The Replace dialog box also sends messages in response to user clicks on the Replace and Replace All buttons.</P>

<P>To use the Find or Replace dialog box, you must perform three separate tasks:</P>

<P>1.Get a message identifier for the <A HREF="gy41ze.htm">FINDMSGSTRING</A> registered message.</P>

<P>2.Display the dialog box.</P>

<P>3.Process FINDMSGSTRING messages when the dialog box is open.</P>

<P></P>

<P>When you initialize your application, call the <A HREF="xkgsv4.htm"><B>RegisterWindowMessage</B></A> function to get a message identifier for the FINDMSGSTRING registered message. </P>

<P>UINT uFindReplaceMsg;  // message identifier for FINDMSGSTRING  </P>

<P>uFindReplaceMsg = RegisterWindowMessage(FINDMSGSTRING);</P>

<P></P>

<P>To display a Find dialog box, first initialize a <A HREF="1de83do.htm"><B>FINDREPLACE</B></A> structure and then call the <A HREF="55jx_hv.htm"><B>FindText</B></A> function. Note that the <B>FINDREPLACE</B> structure and the buffer for the search string should be a global or static variable so it does not go out of scope before the dialog box closes. You must set the <B>hwndOwner</B> member to specify the window that receives the registered messages. After you create the dialog box, you can move or manipulate it by using the returned handle. </P>

<P>FINDREPLACE fr;       // common dialog box structure</P>

<P>HWND hwnd;            // owner window</P>

<P>CHAR szFindWhat[80];  // buffer receiving string</P>

<P>HWND hdlg = NULL;     // handle of Find dialog box</P>

<P></P>

<P>// Initialize FINDREPLACE<BR>
ZeroMemory(&amp;fr, sizeof(FINDREPLACE));</P>

<P>fr.lStructSize = sizeof(FINDREPLACE);</P>

<P>fr.hwndOwner = hwnd;</P>

<P>fr.lpstrFindWhat = szFindWhat;</P>

<P>fr.wFindWhatLen = 80;</P>

<P>fr.Flags = 0;</P>

<P>hdlg = FindText(&amp;fr);</P>

<P></P>

<P>When the dialog box is open, your main message loop must include a call to the <A HREF="3mdxb3e.htm"><B>IsDialogMessage</B></A> function. Pass the window handle of the dialog box as a parameter in the <B>IsDialogMessage</B> call. This ensures that the dialog box correctly processes keyboard messages.</P>

<P>To monitor messages sent from the dialog box, your window procedure must check for the FINDMSGSTRING registered message and process the values passed in the <A HREF="1de83do.htm"><B>FINDREPLACE</B></A> structure as in the following example:</P>

<P>LPFINDREPLACE lpfr;</P>

<P></P>

<P>if (message == uFindReplaceMsg){ </P>

<P>// Get pointer to FINDREPLACE structure from lParam.</P>

<P>lpfr = (LPFINDREPLACE)lParam;</P>

<P>// If the FR_DIALOGTERM flag is set, </P>

<P>// invalidate the handle identifying the dialog box. </P>

<P>if (lpfr-&gt;Flags &amp; FR_DIALOGTERM){ </P>

<P>hdlg = NULL; </P>

<P>return 0; </P>

<P>} </P>

<P>// If the FR_FINDNEXT flag is set, </P>

<P>// call the application-defined search routine</P>

<P>// to search for the requested string. </P>

<P>if (lpfr-&gt;Flags &amp; FR_FINDNEXT) </P>

<P>SearchFile(lpfr-&gt;lpstrFindWhat,</P>

<P>(BOOL) (lpfr-&gt;Flags &amp; FR_DOWN), </P>

<P>(BOOL) (lpfr-&gt;Flags &amp; FR_MATCHCASE)); </P>

<P>return 0; </P>

<P></P>

<P>} </P>

<P></P>

</BODY>
</HTML>
