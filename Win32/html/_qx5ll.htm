<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>CreateProcessAsUser</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="_qx5ll"></A><B>CreateProcessAsUser  <A HREF="13idmr7.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="glns2h.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="7wnz9r.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>CreateProcessAsUser</B> function creates a new process and its primary thread. The new process then executes a specified executable file. The <B>CreateProcessAsUser</B> function is similar to the <A HREF="5fbj_xx.htm"><B>CreateProcess</B></A> function, except that the new process runs in the security context of the user represented by the <I>hToken</I> parameter. By default, the new process is non-interactive, that is, it runs on a desktop that is not visible and cannot receive user input. Also, by default, the new process inherits the environment of the calling process, rather than the environment associated with the specified user.</P>

<P><B>BOOL CreateProcessAsUser(</B></P>

<TABLE cols=2 width=702>

<TR VALIGN="top">
<TD width=51%><B>HANDLE</B> <I>hToken</I><B>,</B></TD>
<TD width=49%>// handle to a token that represents a logged-on user</TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPCTSTR</B> <I>lpApplicationName</I><B>,</B></TD>
<TD width=49%>// pointer to name of executable module </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPTSTR</B> <I>lpCommandLine</I><B>,</B></TD>
<TD width=49%>// pointer to command line string</TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPSECURITY_ATTRIBUTES</B> <I>lpProcessAttributes</I><B>,</B></TD>
<TD width=49%>// pointer to process security attributes </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPSECURITY_ATTRIBUTES</B> <I>lpThreadAttributes</I><B>,</B></TD>
<TD width=49%>// pointer to thread security attributes </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    BOOL</B> <I>bInheritHandles</I><B>,</B></TD>
<TD width=49%>// new process inherits handles </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    DWORD</B> <I>dwCreationFlags</I><B>,</B></TD>
<TD width=49%>// creation flags </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPVOID</B> <I>lpEnvironment</I><B>,</B></TD>
<TD width=49%>// pointer to new environment block </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPCTSTR</B> <I>lpCurrentDirectory</I><B>,</B></TD>
<TD width=49%>// pointer to current directory name </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPSTARTUPINFO</B> <I>lpStartupInfo</I><B>,</B></TD>
<TD width=49%>// pointer to STARTUPINFO </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>    LPPROCESS_INFORMATION</B> <I>lpProcessInformation</I> </TD>
<TD width=49%>// pointer to PROCESS_INFORMATION  </TD>
</TR>

<TR VALIGN="top">
<TD width=51%><B>   );</B></TD>
<TD width=49%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hToken</I></P>

<P>Handle to a primary token that represents a user. The user represented by the token must have read and execute access to the application specified by the <I>lpApplicationName</I> or the <I>lpCommandLine</I> parameter.</P>

<P>If your process has the SE_TCB_NAME privilege, it can call the <A HREF="emh6d1.htm"><B>LogonUser</B></A> function to get a primary token that represents a specified user.</P>

<P>Alternatively, you can call the <A HREF="2my4.hr.htm"><B>DuplicateTokenEx</B></A> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client. </P>

<P>The other parameters of the <B>CreateProcessAsUser</B> function behave just like the analogous parameters of the <A HREF="5fbj_xx.htm"><B>CreateProcess</B></A> function.</P>

<P><I>lpApplicationName</I></P>

<P>Points to a null-terminated string specifying the full path and filename of the module to execute. If a partial name is specified, the current drive and current directory are used by default. If this parameter is NULL, the module name must be the first white space-delimited token in the <I>lpCommandLine</I> string. The specified module can be a Win32-based application, or it can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. </P>

<P><I>lpCommandLine</I></P>

<P>Points to a null-terminated string specifying the command line for the application to be executed. If this parameter is NULL, the <I>lpApplicationName</I> string is used as the command line. If both <I>lpApplicationName</I> and <I>lpCommandLine</I> are non-NULL, <I>lpApplicationName</I> specifies the module to execute and <I>lpCommandLine</I> is used as the command line. The new process can use <A HREF="1xs07zy.htm"><B>GetCommandLine</B></A> to retrieve the entire command line; or C runtime processes can use the <B>argc</B>/<B>argv</B> mechanism. </P>

<P>If <I>lpApplicationName</I> is NULL, the first white space-delimited token of the command line specifies the module name. If the filename does not contain an extension, .EXE is assumed. If the filename ends in a period (.) with no extension, or the filename contains a path, .EXE is not appended. If the filename does not contain a directory path, Windows searches for the executable file in the following sequence: </P>

<P>1.The directory from which the application loaded. </P>

<P>2.The current directory. </P>

<P>3.The 32-bit Windows system directory. Use the <B>GetSystemDirectory</B> function to get the path of this directory. The name of this directory is SYSTEM32.</P>

<P>4.The 16-bit Windows system directory. There is no Win32 function that obtains the path of this directory, but it is searched. The name of this directory is SYSTEM.</P>

<P>5.The Windows directory. Use the <A HREF="1b6tycn.htm"><B>GetWindowsDirectory</B></A> function to get the path of this directory. </P>

<P>6.The directories that are listed in the PATH environment variable. </P>

<P></P>

<P>If the process to be created is an MS-DOS - based or 16-bit Windows-based application, <I>lpCommandLine</I> should be a full command line in which the first element is the application name. Because this also works well for Win32-based applications, it is the most robust way to set <I>lpCommandLine</I>. </P>

<P><I>lpProcessAttributes</I></P>

<P>Pointer to a <A HREF="be53kg.htm"><B>SECURITY_ATTRIBUTES</B></A> structure that specifies a security descriptor for the new process and determines whether child processes can inherit the returned handle. If <I>lpProcessAttributes</I> is NULL, the process gets a default security descriptor and the handle cannot be inherited.</P>

<P><I>lpThreadAttributes</I></P>

<P>Pointer to a <A HREF="be53kg.htm"><B>SECURITY_ATTRIBUTES</B></A> structure that specifies a security descriptor for the new process and determines whether child processes can inherit the returned handle. If <I>lpThreadAttributes</I> is NULL, the thread gets a default security descriptor and the handle cannot be inherited.</P>

<P><I>bInheritHandles</I></P>

<P>Indicates whether the new process inherits handles from the calling process. If TRUE, each inheritable open handle in the calling process is inherited by the new process. Inherited handles have the same value and access privileges as the original handles. </P>

<P><I>dwCreationFlags</I></P>

<P>Specifies additional flags that control the priority class and the creation of the process. The following creation flags can be specified in any combination, except as noted: </P>

<TABLE cols=6>

<TR VALIGN="top">
<TD colspan=2 width=14%><B>Value</B></TD>
<TD colspan=3 width=73%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>CREATE_DEFAULT_ERROR_MODE</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>The new process does not inherit the error mode of the calling process. Instead, <B>CreateProcessAsUser </B>gives the new process the current default error mode. An application sets the current default error mode by calling <A HREF="6vrdc5.htm"><B>SetErrorMode</B></A>.
<P>This flag is particularly useful for multi-threaded shell applications that run with hard errors disabled. </P>

<P>The default behavior for <B>CreateProcessAsUser</B> is for the new process to inherit the error mode of the caller. Setting this flag changes that default behavior.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>CREATE_NEW_CONSOLE</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>The new process has a new console, instead of inheriting the parent's console. This flag cannot be used with the DETACHED_PROCESS flag.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>CREATE_NEW_PROCESS_GROUP</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>The new process is the root process of a new process group. The process group includes all processes that are descendants of this root process. The process identifier of the new process group is the same as the process identifier, which is returned in the <I>lpProcessInformation</I> parameter. Process groups are used by the <A HREF="19h8n57.htm"><B>GenerateConsoleCtrlEvent</B></A> function to enable sending a CTRL+C or CTRL+BREAK signal to a group of console processes.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>CREATE_SEPARATE_WOW_VDM</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>This flag is only valid only starting a 16-bit Windows program. If set, the new process is run in a private Virtual DOS Machine (VDM).  By default, all 16-bit Windows programs are run in a single, shared VDM.  The advantage of running separately is that a crash only kills the single VDM; any other programs running in distinct VDMs continue to function normally. Also, 16-bit Windows applications that are run in separate VDMs have separate input queues. That means that if one application hangs momentarily, applications in separate VDMs continue to receive input.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>CREATE_SUSPENDED</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>The primary thread of the new process is created in a suspended state, and does not run until the <A HREF="5kez_mi.htm"><B>ResumeThread</B></A> function is called.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>CREATE_UNICODE_ENVIRONMENT</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>If set, the environment block pointed to by <I>lpEnvironment</I> uses Unicode characters. If clear, the environment block uses ANSI characters.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>DEBUG_PROCESS</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>If set, the calling process is treated as a debugger, and the new process is a process being debugged. The system notifies the debugger of all debug events that occur in the process being debugged.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>DEBUG_ONLY_THIS_PROCESS</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>If not set and the calling process is being debugged, the new process becomes another process being debugged by the calling process's debugger. If the calling process is not a process being debugged, no debugging-related actions occur.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=16%>DETACHED_PROCESS</TD>
<TD colspan=3 width=84%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=12%>&nbsp;</TD>
<TD colspan=3 width=63%>For console processes, the new process does not have access to the console of the parent process. The new process can call the <A HREF="440z8e.htm"><B>AllocConsole</B></A> function at a later time to create a new console. This flag cannot be used with the CREATE_NEW_CONSOLE flag.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>The <I>dwCreationFlags</I> parameter also controls the new process's priority class, which is used in determining the scheduling priorities of the process's threads. If none of the following priority class flags is specified, the priority class defaults to <B>NORMAL_PRIORITY_CLASS</B> unless the priority class of the creating process is <B>IDLE_PRIORITY_CLASS</B>. In this case the default priority class of the child process is <B>IDLE_PRIORITY_CLASS</B>. One of the following flags can be specified: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=47%><B>Priority</B></TD>
<TD width=53%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=47%>HIGH_PRIORITY_CLASS</TD>
<TD width=53%>Indicates a process that performs time-critical tasks that must be executed immediately for it to run correctly. The threads of a high-priority class process preempt the threads of normal-priority or idle-priority class processes. An example is Windows Task List, which must respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a high-priority class CPU-bound application can use nearly all available cycles.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>IDLE_PRIORITY_CLASS</TD>
<TD width=53%>Indicates a process whose threads run only when the system is idle and are preempted by the threads of any process running in a higher priority class. An example is a screen saver. The idle priority class is inherited by child processes.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NORMAL_PRIORITY_CLASS</TD>
<TD width=53%>Indicates a normal process with no special scheduling needs.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>REALTIME_PRIORITY_CLASS</TD>
<TD width=53%>Indicates a process that has the highest possible priority. The threads of a real-time priority class process preempt the threads of all other processes, including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches not to flush or cause the mouse to be unresponsive.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><I>lpEnvironment</I></P>

<P>Points to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process. </P>

<P>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the form: </P>

<P>name=value  </P>

<P></P>

<P>Because the equal sign is used as a separator, it must not be used in the name of an environment variable. </P>

<P>If an application provides an environment block, rather than passing NULL for this parameter, the current directory information of the system drives is not automatically propagated to the new process. For a discussion of this situation and how to handle it, see the following Remarks section. </P>

<P>An environment block can contain Unicode or ANSI characters. If the environment block pointed to by <I>lpEnvironment</I> contains Unicode characters, the <I>dwCreationFlags</I> field's CREATE_UNICODE_ENVIRONMENT flag will be set. If the block contains ANSI characters, that flag will be clear.</P>

<P>Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.</P>

<P><I>lpCurrentDirectory</I></P>

<P>Points to a null-terminated string that specifies the current drive and directory for the new process. The string must be a full path and filename that includes a drive letter. If this parameter is NULL, the new process is created with the same current drive and directory as the calling process. This option is provided primarily for shells that need to start an application and specify its initial drive and working directory. </P>

<P><I>lpStartupInfo</I></P>

<P>Points to a <A HREF="d.kh8s.htm"><B>STARTUPINFO</B></A> structure that specifies how the main window for the new process should appear. </P>

<P><I>lpProcessInformation</I></P>

<P>Points to a <A HREF="fneyqd.htm"><B>PROCESS_INFORMATION</B></A> structure that receives identification information about the new process. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Remarks</B></P>

<P>The <B>CreateProcessAsUser</B> function requires the SE_ASSIGNPRIMARYTOKEN_NAME and SE_INCREASE_QUOTA_NAME privileges. If they are not already enabled, <B>CreateProcessAsUser</B> enables them for the duration of the call.</P>

<P>By default, <B>CreateProcessAsUser</B> creates the new process on a noninteractive window station with a desktop that is not visible and cannot receive user input. To enable user interaction with the new process, you must specify the name of the default interactive window station and desktop, "winsta0\default", in the <B>lpDesktop</B> member of the <A HREF="d.kh8s.htm"><B>STARTUPINFO</B></A> structure. In addition, before calling <B>CreateProcessAsUser</B>, you must change the discretionary access control list (DACL) of both the default interactive window station and the default desktop. The DACLs for the window station and desktop must grant access to the user represented by the <I>hToken</I> parameter.</P>

<P><B>CreateProcessAsUser</B> does not load the specified user's profile into the HKEY_USERS registry key. This means that access to information in the HKEY_CURRENT_USER registry key may not produce results consistent with a normal interactive logon. It is your responsibility to load the user's registry hive into HKEY_USERS before calling <B>CreateProcessAsUser</B>.</P>

<P>If the <I>lpEnvironment</I> parameter is NULL, the new process inherits the environment of the calling process. <B>CreateProcessAsUser</B> does not automatically modify the environment block to include environment variables specific to the user represented by <I>hToken</I>. For example, the USERNAME and USERDOMAIN variables are inherited from the calling process if <I>lpEnvironment</I> is NULL. It is your responsibility to prepare the environment block for the new process and specify it in <I>lpEnvironment</I>.</P>

<P><B>CreateProcessAsUser</B> allows you to access the specified directory and executable image in the security context of the caller or the target user. By default, <B>CreateProcessAsUser</B> accesses the directory and executable image in the security context of the caller. In this case, if the caller does not have access to the directory and executable image, the function fails. To access the directory and executable image using the security context of the target user, specify <I>hToken</I> in a call to the <A HREF="6tqnja.htm"><B>ImpersonateLoggedOnUser</B></A> function before calling <B>CreateProcessAsUser</B>. </P>

<P>The new process and the new thread handles are created with full access rights (PROCESS_ALL_ACCESS and THREAD_ALL_ACCESS). For either handle, if a security descriptor is not provided, the handle can be used in any function that requires an object handle of that type. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If the access check denies access, the requesting process is not able to use the handle to gain access to the process or thread. </P>

<P>If the <I>lpProcessAttributes</I> parameter is NULL, the default security descriptor for the user referenced in the <I>hToken</I> parameter will be used. This security descriptor may not allow access for the caller, in which case the process may not be opened again once it is run. The handle returned in the <A HREF="fneyqd.htm"><B>PROCESS_INFORMATION</B></A> structure is valid and will continue to have all access. This is also true for thread attributes.</P>

<P>Handles in <B>PROCESS_INFORMATION</B> must be closed with <A HREF="ngwwie.htm"><B>CloseHandle</B></A> when they are no longer needed.</P>

<P>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the <A HREF="9mlgut.htm"><B>OpenProcess</B></A> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in the <B>PROCESS_INFORMATION</B> structure. </P>

<P>When specifying an application name in the <I>lpApplicationName</I> or <I>lpCommandLine</I> strings, it doesn't matter whether the application name includes the filename extension, with one exception: an MS-DOS - based or Windows-based application whose filename extension is .COM must include the .COM extension. </P>

<P>The calling thread can use the <A HREF="11.xgys.htm"><B>WaitForInputIdle</B></A> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because <B>CreateProcessAsUser</B> returns without waiting for the new process to finish its initialization. For example, the creating process would use <B>WaitForInputIdle</B> before trying to find a window associated with the new process. </P>

<P>The preferred way to shut down a process is by using the <A HREF="i5ihdk.htm"><B>ExitProcess</B></A> function, because this function notifies all dynamic-link libraries (DLLs) attached to the process of the approaching termination. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls <B>ExitProcess</B>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). </P>

<P><B>ExitProcess</B>, <A HREF="c.xq03.htm"><B>ExitThread</B></A>, <A HREF="70ts0y.htm"><B>CreateThread</B></A>, <A HREF="19iu6kt.htm"><B>CreateRemoteThread</B></A>, and a process that is starting (as the result of a call by <B>CreateProcessAsUser</B>) are serialized between each other within a process. Only one of these events can happen at a time. This means the following restrictions hold: </P>

<P>·During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process. </P>

<P>·Only one thread in a process can be in a DLL initialization or detach routine at a time. </P>

<P>·The <B>ExitProcess</B> function does not return until no threads are executing DLL initialization or detach routines. </P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="440z8e.htm"><B>AllocConsole</B></A>, <A HREF="ngwwie.htm"><B>CloseHandle</B></A>, <A HREF="5fbj_xx.htm"><B>CreateProcess</B></A>, <A HREF="19iu6kt.htm"><B>CreateRemoteThread</B></A>, <A HREF="70ts0y.htm"><B>CreateThread</B></A>, <A HREF="2my4.hr.htm"><B>DuplicateTokenEx</B></A>, <A HREF="i5ihdk.htm"><B>ExitProcess</B></A>, <A HREF="c.xq03.htm"><B>ExitThread</B></A>, <A HREF="19h8n57.htm"><B>GenerateConsoleCtrlEvent</B></A>, <A HREF="1xs07zy.htm"><B>GetCommandLine</B></A>, <A HREF="422g_ss.htm"><B>GetEnvironmentStrings</B></A>, <A HREF="2mm.i..htm"><B>GetExitCodeProcess</B></A>, <A HREF="8n6hyc.htm"><B>GetFullPathName</B></A>, <A HREF="7vidhb.htm"><B>GetStartupInfo</B></A>, <A HREF="3oj42sv.htm"><B>GetSystemDirectory</B></A>, <A HREF="1b6tycn.htm"><B>GetWindowsDirectory</B></A>, <A HREF="6tqnja.htm"><B>ImpersonateLoggedOnUser</B></A>, <A HREF="l7hy._.htm"><B>LoadModule</B></A>, <A HREF="emh6d1.htm"><B>LogonUser</B></A>, <A HREF="9mlgut.htm"><B>OpenProcess</B></A>, <A HREF="fneyqd.htm"><B>PROCESS_INFORMATION</B></A>, <A HREF="5kez_mi.htm"><B>ResumeThread</B></A>, <A HREF="be53kg.htm"><B>SECURITY_ATTRIBUTES</B></A>, <A HREF="6gcpc8.htm"><B>SetConsoleCtrlHandler</B></A>, <A HREF="6vrdc5.htm"><B>SetErrorMode</B></A>, <A HREF="d.kh8s.htm"><B>STARTUPINFO</B></A>, <A HREF=".d3m14.htm"><B>TerminateProcess</B></A>, <A HREF="11.xgys.htm"><B>WaitForInputIdle</B></A>, <A HREF="12sap3t.htm"><B>WinExec</B></A> </P>

</BODY>
</HTML>
