<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using Event Objects</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="10pey."></A><B>Using Event Objects</B></P>

<P>Win32-based applications use event objects in a number of situations to notify a waiting thread of the occurrence of an event. For example, overlapped I/O operations on files, named pipes, and communications devices use an event object to signal their completion. For more information about the use of event objects in overlapped I/O operations, see <A HREF="l05c8e.htm">Synchronization and Overlapped Input and Output</A>.</P>

<P>In the following example, an application uses event objects to prevent several threads from reading from a shared memory buffer while a master thread is writing to that buffer. First, the master thread uses the <A HREF="j_zbjv.htm"><B>CreateEvent</B></A> function to create a manual-reset event object. The master thread sets the event object to nonsignaled when it is writing to the buffer and then resets the object to signaled when it has finished writing. Then it creates several reader threads and an auto-reset event object for each thread. Each reader thread sets its event object to signaled when it is not reading from the buffer. </P>

<P>#define NUMTHREADS 4  </P>

<P>HANDLE hGlobalWriteEvent; </P>

<P>void CreateEventsAndThreads(void) </P>

<P>{</P>

<P>HANDLE hReadEvents[NUMTHREADS], hThread; </P>

<P>DWORD i, IDThread; </P>

<P>// Create a manual-reset event object. The master thread sets </P>

<P>// this to nonsignaled when it writes to the shared buffer. </P>

<P>hGlobalWriteEvent = CreateEvent( </P>

<P>NULL,         // no security attributes</P>

<P>TRUE,         // manual-reset event</P>

<P>TRUE,         // initial state is signaled</P>

<P>"WriteEvent"  // object name</P>

<P>); </P>

<P>if (hGlobalWriteEvent == NULL) { </P>

<P>// error exit</P>

<P>}</P>

<P>// Create multiple threads and an auto-reset event object </P>

<P>// for each thread. Each thread sets its event object to </P>

<P>// signaled when it is not reading from the shared buffer. </P>

<P>for(i = 1; i &lt;= NUMTHREADS; i++) </P>

<P>{</P>

<P>// Create the auto-reset event.</P>

<P>hReadEvents[i] = CreateEvent( </P>

<P>NULL,     // no security attributes</P>

<P>FALSE,    // auto-reset event</P>

<P>TRUE,     // initial state is signaled</P>

<P>NULL);    // object not named</P>

<P>if (hReadEvents[i] == NULL) </P>

<P>{</P>

<P>// Error exit.</P>

<P>}</P>

<P>hThread = CreateThread(NULL, 0, </P>

<P>(LPTHREAD_START_ROUTINE) ThreadFunction, </P>

<P>&amp;hReadEvents[i],  // pass event handle</P>

<P>0, &amp;IDThread); </P>

<P>if (hThread == NULL) </P>

<P>{</P>

<P>// Error exit.</P>

<P>}</P>

<P>}</P>

<P>}</P>

<P>Before the master thread writes to the shared buffer, it uses the <A HREF="1.ih1gv.htm"><B>ResetEvent</B></A> function to set the state of hGlobalWriteEvent (an application-defined global variable) to nonsignaled. This blocks the reader threads from starting a read operation. The master then uses the <A HREF="ux0.eo.htm"><B>WaitForMultipleObjects</B></A> function to wait for all reader threads to finish any current read operations. When <B>WaitForMultipleObjects</B> returns, the master thread can safely write to the buffer. After it has finished, it sets hGlobalWriteEvent and all the reader-thread events to signaled, enabling the reader threads to resume their read operations. </P>

<P>VOID WriteToBuffer(VOID)  </P>

<P>{</P>

<P>DWORD dwWaitResult, i; </P>

<P>// Reset hGlobalWriteEvent to nonsignaled, to block readers.</P>

<P></P>

<P>if (! ResetEvent(hGlobalWriteEvent) ) </P>

<P>{ </P>

<P>// Error exit.</P>

<P>} </P>

<P>// Wait for all reading threads to finish reading.</P>

<P>dwWaitResult = WaitForMultipleObjects( </P>

<P>NUMTHREADS,   // number of handles in array</P>

<P>hReadEvents,  // array of read-event handles</P>

<P>TRUE,         // wait until all are signaled</P>

<P>INFINITE);    // indefinite wait</P>

<P>switch (dwWaitResult) </P>

<P>{</P>

<P>// All read-event objects were signaled.</P>

<P>case WAIT_OBJECT_0: </P>

<P>// Write to the shared buffer.</P>

<P>break;</P>

<P>// An error occurred.</P>

<P>default: </P>

<P>printf("Wait error: %d\n", GetLastError()); </P>

<P>ExitProcess(0); </P>

<P>} </P>

<P>// Set hGlobalWriteEvent to signaled.</P>

<P>if (! SetEvent(hGlobalWriteEvent) ) </P>

<P>{</P>

<P>// Error exit.</P>

<P>}</P>

<P>// Set all read events to signaled.</P>

<P>for(i = 1; i &lt;= NUMTHREADS; i++) </P>

<P>if (! SetEvent(hReadEvents[i]) ) { </P>

<P>// Error exit.</P>

<P>} </P>

<P>}</P>

<P></P>

<P>Before starting a read operation, each reader thread uses <A HREF="ux0.eo.htm"><B>WaitForMultipleObjects</B></A> to wait for the application-defined global variable hGlobalWriteEvent and its own read event to be signaled. When <B>WaitForMultipleObjects</B> returns, the reader thread's auto-reset event has been reset to nonsignaled. This blocks the master thread from writing to the buffer until the reader thread uses the <A HREF="at02d..htm"><B>SetEvent</B></A> function to set the event's state back to signaled. </P>

<P>VOID ThreadFunction(LPVOID lpParam)  </P>

<P>{</P>

<P>DWORD dwWaitResult, i;</P>

<P>HANDLE hEvents[2]; </P>

<P>hEvents[0] = (HANDLE) *lpParam;  // thread's read event</P>

<P>hEvents[1] = hGlobalWriteEvent; </P>

<P>dwWaitResult = WaitForMultipleObjects( </P>

<P>2,            // number of handles in array</P>

<P>hEvents,      // array of event handles</P>

<P>TRUE,         // wait till all are signaled</P>

<P>INFINITE);    // indefinite wait</P>

<P>switch (dwWaitResult) </P>

<P>{</P>

<P>// Both event objects were signaled.</P>

<P>case WAIT_OBJECT_0: </P>

<P>// Read from the shared buffer.</P>

<P>break; </P>

<P>// An error occurred.</P>

<P>default: </P>

<P>printf("Wait error: %d\n", GetLastError()); </P>

<P>ExitThread(0); </P>

<P>}</P>

<P>// Set the read event to signaled.</P>

<P>if (! SetEvent(hEvents[0]) ) </P>

<P>{ </P>

<P>// Error exit.</P>

<P>} </P>

<P>}</P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
