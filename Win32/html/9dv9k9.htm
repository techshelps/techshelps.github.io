<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>VirtualAllocEx [New - Windows NT]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="9dv9k9"></A><B>VirtualAllocEx  <A HREF="rlc1wg.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="7gqv3r.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="9cqndc.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>The <B>VirtualAllocEx</B> function reserves, commits, or both, a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero. </P>

<P>The difference between the <B>VirtualAllocEx</B> function and the <A HREF="1m7v8go.htm"><B>VirtualAlloc</B></A> function is that <B>VirtualAlloc</B> allocates memory within the address space of the calling process, while <B>VirtualAllocEx</B> lets you specify a process. </P>

<P><B>LPVOID VirtualAllocEx(</B></P>

<TABLE cols=2 width=477>

<TR VALIGN="top">
<TD width=43%><B>HANDLE</B> <I>hProcess</I><B>,</B></TD>
<TD width=57%>// process within which to allocate memory  </TD>
</TR>

<TR VALIGN="top">
<TD width=43%><B>    LPVOID</B> <I>lpAddress</I><B>,</B></TD>
<TD width=57%>// desired starting address of allocation </TD>
</TR>

<TR VALIGN="top">
<TD width=43%><B>    DWORD</B> <I>dwSize</I><B>,</B></TD>
<TD width=57%>// size, in bytes, of region to allocate </TD>
</TR>

<TR VALIGN="top">
<TD width=43%><B>    DWORD</B> <I>flAllocationType</I><B>,</B></TD>
<TD width=57%>// type of allocation </TD>
</TR>

<TR VALIGN="top">
<TD width=43%><B>    DWORD</B> <I>flProtect</I> </TD>
<TD width=57%>// type of access protection</TD>
</TR>

<TR VALIGN="top">
<TD width=43%><B>   );</B></TD>
<TD width=57%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hProcess</I></P>

<P>Handle to a process. The function allocates memory within the virtual address space of this process.</P>

<P>You must have PROCESS_VM_OPERATION access to the process. If you do not, the function fails.</P>

<P><I>lpAddress</I></P>

<P>Pointer that specifies a desired starting address for the region of pages that you want to allocate. </P>

<P>If you are reserving memory, the function rounds this address down to the nearest 64-kilobyte boundary. </P>

<P>If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. To determine the size of a page on the host computer, use the <A HREF="nh29xo.htm"><B>GetSystemInfo</B></A> function. </P>

<P>If <I>lpAddress</I> is NULL, the function determines where to allocate the region. </P>

<P><I>dwSize</I></P>

<P>Specifies the size, in bytes, of the region of memory to allocate. </P>

<P>If <I>lpAddress</I> is NULL, the function rounds <I>dwSize</I> up to the next page boundary.</P>

<P>If <I>lpAddress</I> is not NULL, the function allocates all pages that contain one or more bytes in the range from <I>lpAddress</I> to (<I>lpAddress</I>+<I>dwSize</I>). This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.  </P>

<P><I>flAllocationType</I></P>

<P>A set of bit flags that specifies the type of memory allocation. You can set one or more of the following flags: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=34%><B>Flag</B></TD>
<TD width=66%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=34%>MEM_COMMIT</TD>
<TD width=66%>The function allocates actual physical storage in memory or in the paging file on disk for the specified region of memory pages. The function initializes the memory to zero. </TD>
</TR>

<TR VALIGN="top">
<TD width=34%>&nbsp;</TD>
<TD width=66%>An attempt to commit a memory page that is already committed does not cause the function to fail. This means that you can commit a range of pages without first determining the current commitment state of each page.
<P>If a memory page is not yet reserved, setting this flag causes the function to both reserve and commit the memory page. </P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=34%>MEM_RESERVE</TD>
<TD width=66%>The function reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk. 
<P>Other memory allocation functions, such as <B>malloc</B> and <A HREF="2_d2ee.htm"><B>LocalAlloc</B></A>, cannot use a reserved range of memory until it is released. </P>

<P>You can commit reserved memory pages in subsequent calls to the <B>VirtualAllocEx</B> function. </P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=34%>MEM_TOP_DOWN</TD>
<TD width=66%>The function allocates memory at the highest possible address.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><I>flProtect</I></P>

<P>A set of bit flags that specifies access protection for the region of pages you are allocating. You can specify one of the following flags, along with the PAGE_GUARD and PAGE_NOCACHE protection modifier flags, as desired: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=46%><B>Flag</B></TD>
<TD width=54%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_READONLY</TD>
<TD width=54%>Enables read permission to the committed region of pages. An attempt to write to the committed region results in an access violation. If the system differentiates between read-only permission and execute permission, an attempt to execute code in the committed region results in an access violation.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_READWRITE</TD>
<TD width=54%>Enables both read and write permission to the committed region of pages.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_EXECUTE</TD>
<TD width=54%>Enables execute permission to the committed region of pages. An attempt to read or write to the committed region results in an access violation.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_EXECUTE_READ</TD>
<TD width=54%>Enables execute and read permission to the committed region of pages. An attempt to write to the committed region results in an access violation.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_EXECUTE_READWRITE</TD>
<TD width=54%>Enables execute, read, and write permission to the committed region of pages.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_GUARD</TD>
<TD width=54%>Pages in the region become guard pages. Any attempt to read from or write to a guard page causes the operating system to raise a STATUS_GUARD_PAGE exception and turn off the guard page status. Guard pages thus act as a one-shot access alarm.
<P>The PAGE_GUARD flag is a page protection modifier. An application uses it with one of the other page protection flags, with one exception: It cannot be used with PAGE_NOACCESS. When an access attempt leads the operating system to turn off guard page status, the underlying page protection takes over.</P>

<P>If a guard page exception occurs during a system service, the service typically returns a failure status indicator.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_NOACCESS</TD>
<TD width=54%>Disables all access to the committed region of pages. An attempt to read from, write to, or execute in the committed region results in an access violation exception, called a general protection (GP) fault.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>PAGE_NOCACHE</TD>
<TD width=54%>Allows no caching of the committed regions of pages. The hardware attributes for the physical memory should be specified as "no cache." This is not recommended for general usage. It is useful for device drivers; for example, mapping a video frame buffer with no caching. This flag is a page protection modifier, only valid when used with one of the page protections other than PAGE_NOACCESS.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>A set of bit flags that specifies access protection for the region of pages you are allocating. You can specify one of the following flags, along with the PAGE_GUARD and PAGE_NOCACHE protection modifier flags, as desired: </P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is the base address of the allocated region of pages.</P>

<P>If the function fails, the return value is NULL. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Remarks</B></P>

<P>The <B>VirtualAllocEx</B> function can perform the following operations: </P>

<P>·Commit a region of pages reserved by a previous call to the <B>VirtualAllocEx</B>  function. </P>

<P>·Reserve a region of free pages. </P>

<P>·Reserve and commit a region of free pages. </P>

<P></P>

<P>You can use <B>VirtualAllocEx</B> to reserve a block of pages and then make additional calls to <B>VirtualAllocEx</B> to commit individual pages from the reserved block. This lets you reserve a range of a process's virtual address space without consuming physical storage until it is needed. </P>

<P>Each page of memory in a process's virtual address space is in one of three states: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=18%><B>State</B></TD>
<TD width=82%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=18%>Free</TD>
<TD width=82%>The page is not committed or reserved and is not accessible to the process. The <B>VirtualAllocEx</B> function can reserve, or simultaneously reserve and commit, a free page.</TD>
</TR>

<TR VALIGN="top">
<TD width=18%>Reserved</TD>
<TD width=82%>The page is reserved. The range of addresses cannot be used by other allocation functions, but the page is not accessible and has no physical storage associated with it. The <B>VirtualAllocEx</B> function can commit a reserved page, but it cannot reserve it a second time. You can use the <A HREF=".6dc7e.htm"><B>VirtualFreeEx</B></A> function to release a reserved page in a specified process, making it a free page.</TD>
</TR>

<TR VALIGN="top">
<TD width=18%>Committed</TD>
<TD width=82%>Physical storage is allocated for the page, and access is controlled by a protection code. The system initializes and loads each committed page into physical memory only at the first attempt to read or write to that page. When the process terminates, the system releases the storage for committed pages. The <B>VirtualAllocEx</B> function can commit an already committed page. This means that you can commit a range of pages, regardless of whether they have already been committed, and the function will not fail. You can use the <A HREF=".6dc7e.htm"><B>VirtualFreeEx</B></A> function to decommit a committed page in a specified process, or to simultaneously decommit and free a committed page.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>If the <I>lpAddress</I> parameter is not NULL, the function uses the <I>lpAddress</I> and <I>dwSize</I> parameters to compute the region of pages to be allocated. The current state of the entire range of pages must be compatible with the type of allocation specified by the <I>flAllocationType</I> parameter. Otherwise, the function fails and none of the pages is allocated. This compatibility requirement does not preclude committing an already committed page; see the preceding list. </P>

<P>The PAGE_GUARD protection modifier flag establishes guard pages. Guard pages act as one-shot access alarms. For more information see <A HREF="e98zfa.htm">Guard Pages</A>. </P>

<P><B>See Also</B></P>

<P><A HREF="f12w9..htm"><B>GlobalAlloc</B></A>, <A HREF="12yjji7.htm"><B>HeapAlloc</B></A>, <A HREF="1m7v8go.htm"><B>VirtualAlloc</B></A>, <A HREF="8dcrwp.htm"><B>VirtualFree</B></A>, <A HREF=".6dc7e.htm"><B>VirtualFreeEx</B></A>, <A HREF="8diouv.htm"><B>VirtualLock</B></A>, <A HREF="aruejx.htm"><B>VirtualProtect</B></A>, <A HREF="1mh41k0.htm"><B>VirtualQuery</B></A> </P>

</BODY>
</HTML>
