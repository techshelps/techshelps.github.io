<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Debugging Events</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="12lnrzz"></A><B>Debugging Events</B></P>

<P>A <I>debugging event</I> is an incident in the process being debugged that causes the kernel to notify the debugger. Debugging events include creating a process, creating a thread, loading a dynamic-link library (DLL), unloading a DLL, sending an output string, and generating an exception. </P>

<P>If a debugging event occurs while a debugger is waiting for one, the kernel fills the <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure specified by <A HREF="2bhs1hv.htm"><B>WaitForDebugEvent</B></A> with information describing the event. </P>

<P>When the kernel notifies the debugger of a debugging event, it also suspends all threads in the affected process. The threads do not resume execution until the debugger continues the debugging event by using <A HREF="1ims3jn.htm"><B>ContinueDebugEvent</B></A>. The following debugging events may occur while a process is being debugged. </P>

<TABLE cols=6>

<TR VALIGN="top">
<TD colspan=2 width=23%><B>Debugging event</B></TD>
<TD colspan=3 width=64%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>CREATE_PROCESS_DEBUG_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated whenever a new process is created in a process being debugged or whenever the debugger begins debugging an already active process. The kernel generates this debugging event before the process begins to execute in user mode and before the kernel generates any other debugging events for the new process.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains a <A HREF="12r9ao0.htm"><B>CREATE_PROCESS_DEBUG_INFO</B></A> structure. This structure includes a handle of the new process, a handle of the process's image file, a handle of the process's initial thread, and other information that describes the new process.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The handle of the process has PROCESS_VM_READ and PROCESS_VM_WRITE access. If a debugger has these types of access to a thread, it can read and write to the process's memory by using the <A HREF="2rlm_kf.htm"><B>ReadProcessMemory</B></A> and <A HREF="_4c4hp.htm"><B>WriteProcessMemory</B></A> functions.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The handle of the process's image file has GENERIC_READ access and is opened for read-sharing.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The handle of the process's initial thread has THREAD_GET_CONTEXT, THREAD_SET_CONTEXT, and THREAD_SUSPEND_RESUME access to the thread. If a debugger has these types of access to a thread, it can read from and write to the thread's registers by using the <A HREF="h1g8jb.htm"><B>GetThreadContext</B></A> and <A HREF="0wtukc.htm"><B>SetThreadContext</B></A> functions and can suspend and resume the thread by using the <A HREF="0pf8eh.htm"><B>SuspendThread</B></A> and <A HREF="5kez_mi.htm"><B>ResumeThread</B></A> functions.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>CREATE_THREAD_DEBUG_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated whenever a new thread is created in a process being debugged or whenever the debugger begins debugging an already active process. This debugging event is generated before the new thread begins to execute in user mode.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains a <A HREF="3nllrse.htm"><B>CREATE_THREAD_DEBUG_INFO</B></A> structure. This structure includes a handle of the new thread and the thread's starting address. The handle has THREAD_GET_CONTEXT, THREAD_SET_CONTEXT, and THREAD_SUSPEND_RESUME access to the thread. If a debugger has these types of access to a thread, it can read from and write to the thread's registers by using the <A HREF="h1g8jb.htm"><B>GetThreadContext</B></A> and <A HREF="0wtukc.htm"><B>SetThreadContext</B></A> functions and can suspend and resume the thread by using the <A HREF="0pf8eh.htm"><B>SuspendThread</B></A> and <A HREF="5kez_mi.htm"><B>ResumeThread</B></A> functions.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>EXCEPTION_DEBUG_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated whenever an exception occurs in the process being debugged. Possible exceptions include attempting to access inaccessible memory, executing breakpoint instructions, attempting to divide by zero, or any other exception noted in <A HREF="atyjkk.htm">Structured Exception Handling</A>. </TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains an <A HREF="f3kbop.htm"><B>EXCEPTION_DEBUG_INFO</B></A> structure. This structure describes the exception that caused the debugging event.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Besides the standard exception conditions, an additional exception code can occur during console process debugging. The kernel generates a DBG_CONTROL_C exception code when CTRL+C is input to a console process that handles CTRL+C signals and is being debugged. This exception code is not meant to be handled by applications. An application should never use an exception handler to deal with it. It is raised only for the benefit of the debugger and is only used when a debugger is attached to the console process.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>If a process is not being debugged or if the debugger passes on the DBG_CONTROL_C exception unhandled (through the <B>gn</B> command), the application's list of handler functions is searched, as documented for the <A HREF="6gcpc8.htm"><B>SetConsoleCtrlHandler</B></A><B> </B>function.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>If the debugger handles the DBG_CONTROL_C exception (through the <B>gh</B> command), an application will not notice the CTRL+C except in code like this.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>while ((inputChar = getchar()) != EOF) ...
<P>while (gets(inputString)) ...</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Thus, the debugger cannot be used to stop the read wait in such code from terminating.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>EXIT_PROCESS_DEBUG_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated whenever the last thread in a process being debugged exits. This debugging event occurs immediately after the kernel unloads the process's DLLs and updates the process's exit code.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains an <A HREF="1n4w8db.htm"><B>EXIT_PROCESS_DEBUG_INFO</B></A> structure that specifies the exit code.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The debugger deallocates any internal structures associated with the process on receipt of this debugging event. The kernel closes the debugger's handle of the exiting process and all of the process's threads.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>EXIT_THREAD_DEBUG_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated whenever a thread that is part of a process being debugged exits. The kernel generates this debugging event immediately after it updates the thread's exit code.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains an <A HREF="le5alr.htm"><B>EXIT_THREAD_DEBUG_INFO</B></A> structure that specifies the exit code.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The debugger deallocates any internal structures associated with the thread on receipt of this debugging event. The system closes the debugger's handle of the exiting thread.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>This debugging event does not occur if the exiting thread is the last thread of a process. In this case, the EXIT_PROCESS_DEBUG_EVENT debugging event occurs instead.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>LOAD_DLL_DEBUG_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated whenever a process being debugged loads a DLL. This debugging event occurs when the system loader resolves links to a DLL or when the debugged process uses the <A HREF="1vghbf8.htm"><B>LoadLibrary</B></A> function. This debugging event only occurs the first time the kernel attaches a DLL to the virtual address space of a process.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains a <A HREF="sms5vo.htm"><B>LOAD_DLL_DEBUG_INFO</B></A> structure. This structure includes a handle of the newly loaded DLL, the base address of the DLL, and other information that describes the DLL.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Typically, a debugger loads a symbol table associated with the DLL on receipt of this debugging event.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>OUTPUT_DEBUG_STRING_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated when a process being debugged uses the <A HREF="w85cwp.htm"><B>OutputDebugString</B></A> function.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains an <A HREF="djwf82.htm"><B>OUTPUT_DEBUG_STRING_INFO</B></A> structure. This structure specifies the address, length, and format of the debugging string.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=3 width=25%>UNLOAD_DLL_DEBUG_EVENT</TD>
<TD colspan=3 width=75%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Generated whenever a process being debugged unloads a DLL by using the <A HREF="3mcs_pm.htm"><B>FreeLibrary</B></A> function. This debugging event only occurs the last time a DLL is unloaded from a process's address space (that is, when the DLL's usage count is zero).</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>The <A HREF="5j5av0.htm"><B>DEBUG_EVENT</B></A> structure contains an <A HREF="_l2sa5.htm"><B>UNLOAD_DLL_DEBUG_INFO</B></A> structure. This structure specifies the base address of the DLL in the address space of the process that unloads the DLL.</TD>
</TR>

<TR VALIGN="top">
<TD width=20%>&nbsp;</TD>
<TD colspan=3 width=57%>Typically, a debugger unloads a symbol table associated with the DLL upon receiving this debugging event.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=23%>&nbsp;</TD>
<TD colspan=3 width=64%>When a process exits, the kernel automatically unloads the process's DLLs, but does not generate an UNLOAD_DLL_DEBUG_EVENT debugging event.</TD>
</TR>
</TABLE><BR>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
