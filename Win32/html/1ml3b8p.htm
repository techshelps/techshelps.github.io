<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Opening and Displaying a .BMP File</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="1ml3b8p"></A><B>Opening and Displaying a .BMP File</B></P>

<P>In the sample application, a user is able to open a .BMP file that contains a bitmapped image and display that image in the client area of the application's window. The user selects the file to be opened when the application displays the Open dialog box. (For more information about the Open dialog box, see <A HREF="y3i0nj.htm">Common Dialog Box Library</A>.) </P>

<P>After the user selects a file and closes the dialog box, the file and path names are stored in members of the <A HREF="2wivnae.htm"><B>OPENFILENAME</B></A> structure. The application uses this data to open the appropriate file and retrieve the bitmap header and data. The following code sample can be used to retrieve this data. </P>

<P>/* Retrieve a handle identifying the file. */  </P>

<P></P>

<P>hfbm = CreateFile(ofn.lpstrFile, GENERIC_READ, </P>

<P>FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES) NULL, </P>

<P>OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, </P>

<P>(HANDLE) NULL); </P>

<P></P>

<P>/* Retrieve the BITMAPFILEHEADER structure. */ </P>

<P></P>

<P>ReadFile(hfbm, &amp;bmfh, sizeof(BITMAPFILEHEADER), </P>

<P>&amp;dwRead, (LPOVERLAPPED)NULL); </P>

<P></P>

<P>/* Retrieve the BITMAPFILEHEADER structure. */ </P>

<P></P>

<P>ReadFile(hfbm, &amp;bmih, sizeof(BITMAPINFOHEADER), </P>

<P>&amp;dwRead, (LPOVERLAPPED)NULL); </P>

<P></P>

<P>/* Allocate memory for the BITMAPINFO structure. */ </P>

<P></P>

<P>hmem1 = GlobalAlloc(GHND, </P>

<P>sizeof(BITMAPINFOHEADER) + </P>

<P>((1&lt;&lt;bmih.biBitCount) * sizeof(RGBQUAD))); </P>

<P></P>

<P>lpbmi = GlobalLock(hmem1); </P>

<P></P>

<P>/* </P>

<P>* Load BITMAPINFOHEADER into the BITMAPINFO </P>

<P>* structure. </P>

<P>*/ </P>

<P></P>

<P>lpbmi-&gt;bmiHeader.biSize = bmih.biSize; </P>

<P>lpbmi-&gt;bmiHeader.biWidth = bmih.biWidth; </P>

<P>lpbmi-&gt;bmiHeader.biHeight = bmih.biHeight; </P>

<P>lpbmi-&gt;bmiHeader.biPlanes = bmih.biPlanes; </P>

<P>lpbmi-&gt;bmiHeader.biBitCount = bmih.biBitCount; </P>

<P>lpbmi-&gt;bmiHeader.biCompression = bmih.biCompression; </P>

<P>lpbmi-&gt;bmiHeader.biSizeImage = bmih.biSizeImage; </P>

<P>lpbmi-&gt;bmiHeader.biXPelsPerMeter = bmih.biXPelsPerMeter; </P>

<P>lpbmi-&gt;bmiHeader.biYPelsPerMeter = bmih.biYPelsPerMeter; </P>

<P>lpbmi-&gt;bmiHeader.biClrUsed = bmih.biClrUsed; </P>

<P>lpbmi-&gt;bmiHeader.biClrImportant = bmih.biClrImportant; </P>

<P></P>

<P>/* </P>

<P>* Retrieve the color table. </P>

<P>* 1 &lt;&lt; bmih.biBitCount == 2 ^ bmih.biBitCount </P>

<P>*/ </P>

<P></P>

<P>ReadFile(hfbm, lpbmi-&gt;bmiColors, </P>

<P>((1&lt;&lt;bmih.biBitCount) * sizeof(RGBQUAD)), </P>

<P>&amp;dwRead, (LPOVERLAPPED) NULL); </P>

<P></P>

<P>/* </P>

<P>* Allocate memory for the required number of </P>

<P>* bytes. </P>

<P>*/ </P>

<P></P>

<P>hmem2 = GlobalAlloc(GHND, </P>

<P>(bmfh.bfSize - bmfh.bfOffBits)); </P>

<P></P>

<P>lpvBits = GlobalLock(hmem2); </P>

<P></P>

<P>/* Retrieve the bitmap data. */ </P>

<P></P>

<P>ReadFile(hfbm, lpvBits, </P>

<P>(bmfh.bfSize - bmfh.bfOffBits), </P>

<P>&amp;dwRead, (LPOVERLAPPED) NULL); </P>

<P></P>

<P>/* </P>

<P>* Create a bitmap from the data stored in the </P>

<P>* .BMP file. </P>

<P>*/ </P>

<P></P>

<P>hbm = CreateDIBitmap(hdc, &amp;bmih, </P>

<P>CBM_INIT, lpvBits, </P>

<P>lpbmi, DIB_RGB_COLORS); </P>

<P></P>

<P>/* </P>

<P>* Unlock the global memory objects and </P>

<P>* close the .BMP file. </P>

<P>*/ </P>

<P></P>

<P>GlobalUnlock(hmem1); </P>

<P>GlobalUnlock(hmem2); </P>

<P>CloseHandle(hfbm); </P>

<P></P>

<P>/* Set the fDisplayBitmap flag. */ </P>

<P></P>

<P>if (hbm) </P>

<P>fDisplayBitmap = TRUE; </P>

<P>else </P>

<P>TextOut(hdc, 100, 100, "LoadBitmap Failed", 17); </P>

<P></P>

<P>/* Paint the window (and draw the bitmap). */ </P>

<P></P>

<P>GetClientRect(hwnd, &amp;rect); </P>

<P>InvalidateRect(hwnd, &amp;rect, TRUE); </P>

<P>UpdateWindow(hwnd); </P>

<P></P>

<P>Once the bitmap data is retrieved, the bitmapped image can be drawn in the application's client area. The following code sample is used to draw the bitmap. </P>

<P>case WM_PAINT:  </P>

<P>BeginPaint(hwnd, &amp;ps);  </P>

<P>if (fDisplayBitmap) { </P>

<P>hdcMem = CreateCompatibleDC(ps.hdc); </P>

<P>SelectObject(hdcMem, hbm); </P>

<P>GetObject(hbm, sizeof(BITMAP), (LPSTR) &amp;bm); </P>

<P>BitBlt(ps.hdc, 0, 0, bm.bmWidth, bm.bmHeight, </P>

<P>hdcMem, 0, 0, SRCCOPY); </P>

<P>DeleteDC(hdcMem); </P>

<P>} </P>

<P>EndPaint(hwnd, &amp;ps); </P>

<P>break; </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
