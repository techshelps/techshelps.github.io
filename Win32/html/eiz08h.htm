<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using the High-Level Input and Output Functions</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="eiz08h"></A><B>Using the High-Level Input and Output Functions</B></P>

<P>The following example uses the high-level console I/O functions for console I/O. For more information about the high-level console I/O functions, see <A HREF="1otwjmp.htm">High-Level Console I/O</A>. </P>

<P>The example assumes that the default I/O modes are in effect initially for the first calls to the <A HREF="cjnd8p.htm"><B>ReadFile</B></A> and <A HREF="g0sox_.htm"><B>WriteFile</B></A> functions. Then the input mode is changed to turn off line input mode and echo input mode for the second calls to <B>ReadFile</B> and <B>WriteFile</B>. The <A HREF=".nbq2p.htm"><B>SetConsoleTextAttribute</B></A> function is used to set the colors in which subsequently written text will be displayed. Before exiting, the program restores the original console input mode and color attributes. </P>

<P>The example's NewLine function is used when line input mode is disabled. It handles carriage returns by moving the cursor position to the first cell of the next row. If the cursor is already in the last row of the screen buffer, the contents of the screen buffer are scrolled up one line. For an example that illustrates the use of the <A HREF="0m6cbe.htm"><B>ScrollConsoleScreenBuffer</B></A> function to scroll a screen buffer, see <A HREF="kwwuha.htm">Scrolling a Screen Buffer's Contents</A>. </P>

<P>#include &lt;windows.h&gt;  </P>

<P></P>

<P>VOID NewLine(VOID); </P>

<P>VOID ScrollScreenBuffer(HANDLE, INT); </P>

<P></P>

<P>HANDLE hStdout, hStdin; </P>

<P>CONSOLE_SCREEN_BUFFER_INFO csbiInfo; </P>

<P></P>

<P>VOID main(void) { </P>

<P>LPSTR lpszPrompt1 = "Type something and press Enter:\n"; </P>

<P>LPSTR lpszPrompt2 = "Type any key: "; </P>

<P>CHAR chBuffer[256]; </P>

<P>DWORD cRead, cWritten, fdwMode, fdwOldMode; </P>

<P>WORD wOldColorAttrs; </P>

<P></P>

<P>/* Get handles to STDIN and STDOUT. */ </P>

<P></P>

<P>hStdin = GetStdHandle(STD_INPUT_HANDLE); </P>

<P>hStdout = GetStdHandle(STD_OUTPUT_HANDLE); </P>

<P>if (hStdin == INVALID_HANDLE_VALUE || </P>

<P>hStdout == INVALID_HANDLE_VALUE) </P>

<P>MyErrorExit("GetStdHandle"); </P>

<P></P>

<P>/* Save the current text colors. */ </P>

<P></P>

<P>if (! GetConsoleScreenBufferInfo(hStdout, &amp;csbiInfo)) </P>

<P>MyErrorExit("GetConsoleScreenBufferInfo"); </P>

<P>wOldColorAttrs = csbiInfo.wAttributes; </P>

<P></P>

<P>/* Set the text attr. to draw red text on black background. */ </P>

<P></P>

<P>if (! SetConsoleTextAttribute(hStdout, FOREGROUND_RED)) </P>

<P>MyErrorExit("SetConsoleTextAttribute"); </P>

<P></P>

<P>/* </P>

<P>* Write to STDOUT and read from STDIN by using the default </P>

<P>* modes. Input is echoed automatically, and ReadFile </P>

<P>* does not return until a carriage return is typed. </P>

<P>* </P>

<P>* The default input modes are line, processed, and echo. </P>

<P>* The default output modes are processed and wrap at EOL. </P>

<P>*/ </P>

<P></P>

<P>while (1) { </P>

<P>if (! WriteFile( </P>

<P>hStdout,              /* output handle  */ </P>

<P>lpszPrompt1,          /* prompt string  */ </P>

<P>lstrlen(lpszPrompt1), /* string length  */ </P>

<P>&amp;cWritten,            /* bytes written  */ </P>

<P>NULL) )               /* not overlapped */ </P>

<P>break; </P>

<P>if (! ReadFile( </P>

<P>hStdin,    /* input handle        */ </P>

<P>chBuffer,  /* buffer to read into */ </P>

<P>255,       /* size of buffer      */ </P>

<P>&amp;cRead,    /* actual bytes read   */ </P>

<P>NULL) )    /* not overlapped      */ </P>

<P>break; </P>

<P>if (chBuffer[0] == 'q') break; </P>

<P>} </P>

<P></P>

<P>/* Turn off the line input mode, and echo the input mode. */ </P>

<P></P>

<P>if (! GetConsoleMode(hStdin, &amp;fdwOldMode)) </P>

<P>MyErrorExit("GetConsoleMode"); </P>

<P>fdwMode = fdwOldMode &amp; </P>

<P>~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT); </P>

<P>if (! SetConsoleMode(hStdin, fdwMode)) </P>

<P>MyErrorExit("SetConsoleMode"); </P>

<P></P>

<P>/* Prompt for input. */ </P>

<P></P>

<P>if (! WriteFile( </P>

<P>hStdout,              /* output handle  */ </P>

<P>lpszPrompt2,          /* prompt string  */ </P>

<P>lstrlen(lpszPrompt2), /* string length  */ </P>

<P>&amp;cWritten,            /* bytes written  */ </P>

<P>NULL) )               /* not overlapped */ </P>

<P>MyErrorExit("WriteFile"); </P>

<P></P>

<P>/* </P>

<P>* Without line and echo input modes, ReadFile returns </P>

<P>* when any input is available. Carriage returns must </P>

<P>* be handled, and WriteFile is used to echo input. </P>

<P>*/ </P>

<P></P>

<P>while (1) { </P>

<P>if (! ReadFile(hStdin, chBuffer, 1, &amp;cRead, NULL)) </P>

<P>break; </P>

<P>if (chBuffer[0] == '\r') </P>

<P>NewLine(); </P>

<P>else </P>

<P>if (! WriteFile(hStdout, chBuffer, cRead, </P>

<P>&amp;cWritten, NULL)) </P>

<P>break; </P>

<P>if (chBuffer[0] == 'q') break; </P>

<P>} </P>

<P></P>

<P>/* Restore the original console mode. */ </P>

<P></P>

<P>if (! SetConsoleMode(hStdin, fdwOldMode)) </P>

<P>MyErrorExit("SetConsoleMode"); </P>

<P></P>

<P>/* Restore the original text colors. */ </P>

<P></P>

<P>if (! SetConsoleTextAttribute(hStdout, wOldColorAttrs)) </P>

<P>MyErrorExit("SetConsoleTextAttribute"); </P>

<P></P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* The NewLine function handles carriage returns when the processed </P>

<P>* input mode is disabled. It gets the current cursor position </P>

<P>* and resets it to the first cell of the next row. </P>

<P>*/ </P>

<P></P>

<P>VOID NewLine(VOID) { </P>

<P></P>

<P>if (! GetConsoleScreenBufferInfo(hStdout, &amp;csbiInfo)) </P>

<P>MyErrorExit("GetConsoleScreenBufferInfo"); </P>

<P>csbiInfo.dwCursorPosition.X = 0; </P>

<P></P>

<P>/* </P>

<P>* If it is the last line in the screen buffer, scroll </P>

<P>* the buffer up. </P>

<P>*/ </P>

<P></P>

<P>if ((csbiInfo.dwSize.Y-1) == csbiInfo.dwCursorPosition.Y) { </P>

<P>ScrollScreenBuffer(hStdout, 1); </P>

<P>} </P>

<P></P>

<P>/* Otherwise, advance the cursor to the next line. */ </P>

<P></P>

<P>else </P>

<P>csbiInfo.dwCursorPosition.Y += 1; </P>

<P></P>

<P>if (! SetConsoleCursorPosition(hStdout, </P>

<P>csbiInfo.dwCursorPosition)) </P>

<P>MyErrorExit("SetConsoleCursorPosition"); </P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
