<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>VirtualAlloc</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="1m7v8go"></A><B>VirtualAlloc  <A HREF="9p6aje.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="7gqv3r.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="9cqndc.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>VirtualAlloc</B> function reserves or commits a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero. </P>

<P><B>LPVOID VirtualAlloc(</B></P>

<TABLE cols=2 width=485>

<TR VALIGN="top">
<TD width=42%><B>LPVOID</B> <I>lpAddress</I><B>,</B></TD>
<TD width=58%>// address of region to reserve or commit  </TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>    DWORD</B> <I>dwSize</I><B>,</B></TD>
<TD width=58%>// size of region </TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>    DWORD</B> <I>flAllocationType</I><B>,</B></TD>
<TD width=58%>// type of allocation </TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>    DWORD</B> <I>flProtect</I> </TD>
<TD width=58%>// type of access protection </TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>   );</B></TD>
<TD width=58%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>lpAddress</I></P>

<P>Specifies the desired starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the next 64-kilobyte boundary. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page on the host computer, use the <A HREF="nh29xo.htm"><B>GetSystemInfo</B></A> function. If this parameter is NULL, the system determines where to allocate the region. </P>

<P><I>dwSize</I></P>

<P>Specifies the size, in bytes, of the region. If the <I>lpAddress</I> parameter is NULL, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from <I>lpAddress</I> to (<I>lpAddress</I>+<I>dwSize</I>). This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region. </P>

<P><I>flAllocationType</I></P>

<P>Specifies the type of allocation. You can specify any combination of the following flags: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=34%><B>Flag</B></TD>
<TD width=66%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=34%>MEM_COMMIT</TD>
<TD width=66%>Allocates physical storage in memory or in the paging file on disk for the specified region of pages.</TD>
</TR>

<TR VALIGN="top">
<TD width=34%>&nbsp;</TD>
<TD width=66%>An attempt to commit an already committed page will not cause the function to fail. This means that a range of committed or decommitted pages can be committed without having to worry about a failure.</TD>
</TR>

<TR VALIGN="top">
<TD width=34%>MEM_RESERVE</TD>
<TD width=66%>Reserves a range of the process's virtual address space without allocating any physical storage. The reserved range cannot be used by any other allocation operations (the <B>malloc</B> function, the <A HREF="2_d2ee.htm"><B>LocalAlloc</B></A> function, and so on) until it is released. Reserved pages can be committed in subsequent calls to the <B>VirtualAlloc</B> function.</TD>
</TR>

<TR VALIGN="top">
<TD width=34%>MEM_TOP_DOWN</TD>
<TD width=66%>Allocates memory at the highest possible address.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><I>flProtect</I></P>

<P>Specifies the type of access protection. If the pages are being committed, any one of the following flags can be specified, along with the PAGE_GUARD and PAGE_NOCACHE protection modifier flags, as desired: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=44%><B>Flag</B></TD>
<TD width=56%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_READONLY</TD>
<TD width=56%>Enables read access to the committed region of pages. An attempt to write to the committed region results in an access violation. If the system differentiates between read-only access and execute access, an attempt to execute code in the committed region results in an access violation.</TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_READWRITE</TD>
<TD width=56%>Enables both read and write access to the committed region of pages.</TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_EXECUTE</TD>
<TD width=56%>Enables execute access to the committed region of pages. An attempt to read or write to the committed region results in an access violation.</TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_EXECUTE_READ</TD>
<TD width=56%>Enables execute and read access to the committed region of pages. An attempt to write to the committed region results in an access violation.</TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_EXECUTE_READWRITE</TD>
<TD width=56%>Enables execute, read, and write access to the committed region of pages.</TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_GUARD</TD>
<TD width=56%>Pages in the region become guard pages. Any attempt to read from or write to a guard page causes the operating system to raise a STATUS_GUARD_PAGE exception and turn off the guard page status. Guard pages thus act as a one-shot access alarm.
<P>The PAGE_GUARD flag is a page protection modifier. An application uses it with one of the other page protection flags, with one exception: It cannot be used with PAGE_NOACCESS. When an access attempt leads the operating system to turn off guard page status, the underlying page protection takes over.</P>

<P>If a guard page exception occurs during a system service, the service typically returns a failure status indicator.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_NOACCESS</TD>
<TD width=56%>Disables all access to the committed region of pages. An attempt to read from, write to, or execute in the committed region results in an access violation exception, called a general protection (GP) fault.</TD>
</TR>

<TR VALIGN="top">
<TD width=44%>PAGE_NOCACHE</TD>
<TD width=56%>Allows no caching of the committed regions of pages. The hardware attributes for the physical memory should be specified as "no cache." This is not recommended for general usage. It is useful for device drivers; for example, mapping a video frame buffer with no caching. This flag is a page protection modifier, only valid when used with one of the page protections other than PAGE_NOACCESS.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is the base address of the allocated region of pages.</P>

<P>If the function fails, the return value is NULL. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Remarks</B></P>

<P><B>VirtualAlloc</B> can perform the following operations: </P>

<P>·Commit a region of pages reserved by a previous call to the <B>VirtualAlloc</B> function. </P>

<P>·Reserve a region of free pages. </P>

<P>·Reserve and commit a region of free pages. </P>

<P></P>

<P>You can use <B>VirtualAlloc</B> to reserve a block of pages and then make additional calls to <B>VirtualAlloc</B> to commit individual pages from the reserved block. This enables a process to reserve a range of its virtual address space without consuming physical storage until it is needed. </P>

<P>Each page in the process's virtual address space is in one of three states: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=18%><B>State</B></TD>
<TD width=82%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=18%>Free</TD>
<TD width=82%>The page is not committed or reserved and is not accessible to the process. <B>VirtualAlloc</B> can reserve, or simultaneously reserve and commit, a free page.</TD>
</TR>

<TR VALIGN="top">
<TD width=18%>Reserved</TD>
<TD width=82%>The range of addresses cannot be used by other allocation functions, but the page is not accessible and has no physical storage associated with it. <B>VirtualAlloc</B> can commit a reserved page, but it cannot reserve it a second time. The <A HREF="8dcrwp.htm"><B>VirtualFree</B></A> function can release a reserved page, making it a free page.</TD>
</TR>

<TR VALIGN="top">
<TD width=18%>Committed</TD>
<TD width=82%>Physical storage is allocated for the page, and access is controlled by a protection code. The system initializes and loads each committed page into physical memory only at the first attempt to read or write to that page. When the process terminates, the system releases the storage for committed pages. <B>VirtualAlloc</B> can commit an already committed page. This means that you can commit a range of pages, regardless of whether they have already been committed, and the function will not fail. <A HREF="8dcrwp.htm"><B>VirtualFree</B></A> can decommit a committed page, releasing the page's storage, or it can simultaneously decommit and release a committed page.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>If the <I>lpAddress</I> parameter is not NULL, the function uses the <I>lpAddress</I> and <I>dwSize</I> parameters to compute the region of pages to be allocated. The current state of the entire range of pages must be compatible with the type of allocation specified by the <I>flAllocationType</I> parameter. Otherwise, the function fails and none of the pages are allocated. This compatibility requirement does not preclude committing an already committed page; see the preceding list. </P>

<P>The PAGE_GUARD protection modifier flag establishes guard pages. Guard pages act as one-shot access alarms. See <A HREF="e98zfa.htm">Guard Pages</A>.  </P>

<P><B>See Also</B></P>

<P><A HREF="f12w9..htm"><B>GlobalAlloc</B></A>, <A HREF="12yjji7.htm"><B>HeapAlloc</B></A>, <A HREF="8dcrwp.htm"><B>VirtualFree</B></A>, <A HREF="8diouv.htm"><B>VirtualLock</B></A>, <A HREF="aruejx.htm"><B>VirtualProtect</B></A>, <A HREF="1mh41k0.htm"><B>VirtualQuery</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
