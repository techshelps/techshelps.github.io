<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>ReadFileEx</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="fm7wz7"></A><B>ReadFileEx  <A HREF="30ak_kk.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="qnj9so.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="1f83g2.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>ReadFileEx</B> function reads data from a file asynchronously. It is designed solely for asynchronous operation, unlike the <A HREF="cjnd8p.htm"><B>ReadFile</B></A> function, which is designed for both synchronous and asynchronous operation. <B>ReadFileEx</B> lets an application perform other processing during a file read operation.</P>

<P>The <B>ReadFileEx</B> function reports its completion status asynchronously, calling a specified completion routine when reading is completed and the calling thread is in an alertable wait state.</P>

<P><B>BOOL ReadFileEx(</B></P>

<TABLE cols=2 width=670>

<TR VALIGN="top">
<TD width=66%><B>HANDLE</B> <I>hFile</I><B>,</B></TD>
<TD width=34%>// handle of file to read </TD>
</TR>

<TR VALIGN="top">
<TD width=66%><B>    LPVOID</B> <I>lpBuffer</I><B>,</B></TD>
<TD width=34%>// address of buffer </TD>
</TR>

<TR VALIGN="top">
<TD width=66%><B>    DWORD</B> <I>nNumberOfBytesToRead</I><B>,</B></TD>
<TD width=34%>// number of bytes to read </TD>
</TR>

<TR VALIGN="top">
<TD width=66%><B>    LPOVERLAPPED</B> <I>lpOverlapped</I><B>,</B></TD>
<TD width=34%>// address of offset </TD>
</TR>

<TR VALIGN="top">
<TD width=66%><B>    LPOVERLAPPED_COMPLETION_ROUTINE</B> <I>lpCompletionRoutine</I> </TD>
<TD width=34%>// address of completion routine </TD>
</TR>

<TR VALIGN="top">
<TD width=66%><B>   );</B></TD>
<TD width=34%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hFile</I></P>

<P>An open handle that specifies the file entity to be read from. This file handle must have been created with the FILE_FLAG_OVERLAPPED flag and must have GENERIC_READ access to the file. </P>

<P><B>Windows NT: </B><I>hFile</I> can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function, or a socket handle returned by the <B>socket</B> or <B>accept</B> functions. </P>

<P><B>Windows 95: </B><I>hFile</I> can be a communications resource, mailslot, or named pipe handle opened with the FILE_FLAG_OVERLAPPED flag by <B>CreateFile</B>, or a socket handle returned by the <B>socket</B> or <B>accept</B> functions. Windows 95 does not support asynchronous operations on disk files. </P>

<P><I>lpBuffer</I></P>

<P>Points to a buffer that receives the data read from the file. </P>

<P>This buffer must remain valid for the duration of the read operation. The application should not use this buffer until the read operation is completed.</P>

<P><I>nNumberOfBytesToRead</I></P>

<P>Specifies the number of bytes to be read from the file. </P>

<P><I>lpOverlapped</I></P>

<P>Points to an <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> data structure that supplies data to be used during the asynchronous (overlapped) file read operation.</P>

<P>If the file specified by <I>hFile</I> supports the concept of byte offsets, the caller of <B>ReadFileEx</B> must specify a byte offset within the file at which reading should begin. The caller specifies the byte offset by setting the <B>OVERLAPPED</B> structure's <B>Offset</B> and <B>OffsetHigh</B> members. </P>

<P>If the file entity specified by <I>hFile</I> does not support the concept of byte offsets ¾ for example, if it is a named pipe ¾ the caller must set the <B>Offset</B> and <B>OffsetHigh</B> members to zero, or <B>ReadFileEx</B> fails.</P>

<P>The <B>ReadFileEx</B> function ignores the <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure's <B>hEvent</B> member. An application is free to use that member for its own purposes in the context of a <B>ReadFileEx</B> call. <B>ReadFileEx</B> signals completion of its read operation by calling, or queueing a call to, the completion routine pointed to by <I>lpCompletionRoutine</I>, so it does not need an event handle.</P>

<P>The <B>ReadFileEx</B> function does use the <B>OVERLAPPED</B> structure's <B>Internal</B> and <B>InternalHigh</B> members. An application should not set these members.</P>

<P>The <B>OVERLAPPED</B> data structure pointed to by <I>lpOverlapped</I> must remain valid for the duration of the read operation. It should not be a variable that can go out of scope while the file read operation is in progress.</P>

<P><I>lpCompletionRoutine</I></P>

<P>Points to the completion routine to be called when the read operation is complete and the calling thread is in an alertable wait state. For more information about the completion routine, see <A HREF="axvori.htm"><B>FileIOCompletionRoutine</B></A>. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P>If the function succeeds, the calling thread has an asynchronous I/O (input/output) operation pending: the overlapped read operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable wait state, the system calls the function pointed to by <I>lpCompletionRoutine</I>, and the wait state completes with a return code of WAIT_IO_COMPLETION. </P>

<P>If the function succeeds, and the file reading operation completes, but the calling thread is not in an alertable wait state, the system queues the completion routine call, holding the call until the calling thread enters an alertable wait state. For information about alertable waits and overlapped input/output operations, see <A HREF="l05c8e.htm">Synchronization and Overlapped Input and Output</A>. </P>

<P>If <B>ReadFileEx</B> attempts to read past the end of the file, the function returns zero, and <B>GetLastError</B> returns ERROR_HANDLE_EOF. </P>

<P><B>Remarks</B></P>

<P>If a portion of the file specified by <I>hFile</I> is locked by another process, and the read operation specified in a call to <B>ReadFileEx </B>overlaps the locked portion, the call to <B>ReadFileEx</B> fails. </P>

<P>If <B>ReadFileEx</B> attempts to read data from a mailslot whose buffer is too small, the function returns FALSE, and <B>GetLastError</B> returns ERROR_INSUFFICIENT_BUFFER. </P>

<P>Applications must not read from nor write to the input buffer that a read operation is using until the read operation completes. A premature access to the input buffer may lead to corruption of the data read into that buffer.</P>

<P>The <B>ReadFileEx</B> function may fail if there are too many outstanding asynchronous I/O requests. In the event of such a failure, <B>GetLastError</B> can return ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY. </P>

<P>To cancel all pending asynchronous I/O operations, use the <A HREF="62a8_h_.htm"><B>CancelIO</B></A> function. This function only cancels operations issued by the calling thread for the specified file handle. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. </P>

<P>If <I>hFile</I> is a handle to a named pipe or other file entity that doesn't support the byte-offset concept, the <B>Offset</B> and <B>OffsetHigh</B> members of the <B>OVERLAPPED</B> structure pointed to by <I>lpOverlapped</I> must be zero, or <B>ReadFileEx</B> fails.</P>

<P>An application uses the <B>MsgWaitForMultipleObjectsEx</B>, <B>WaitForSingleObjectEx</B>, <B>WaitForMultipleObjectsEx</B>, and <B>SleepEx</B> functions to enter an alertable wait state. For more information about alertable waits and overlapped input/output, refer to those functions' reference and <A HREF="36dp5f5.htm">Synchronization</A>.</P>

<P><B>Windows 95:</B> On this platform, neither <B>ReadFileEx</B> nor <B>WriteFileEx</B> can be used by the comm ports to communicate. However, you can use <B>ReadFile</B> and <B>WriteFile</B> to perform asynchronous communication.</P>

<P><B>See Also</B></P>

<P><A HREF="62a8_h_.htm"><B>CancelIo</B></A>, <A HREF="xn35yd.htm"><B>CreateFile</B></A>, <A HREF="axvori.htm"><B>FileIOCompletionRoutine</B></A>, <A HREF="14gl8uz.htm"><B>MsgWaitForMultipleObjectsEx</B></A>, <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A>, <A HREF="cjnd8p.htm"><B>ReadFile</B></A>, <A HREF="fmres8.htm"><B>SleepEx</B></A>, <A HREF="1xsv84l.htm"><B>WaitForMultipleObjectsEx</B></A>, <A HREF="aqe6qk.htm"><B>WaitForSingleObjectEx</B></A>, <A HREF="12g2wey.htm"><B>WriteFileEx</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
