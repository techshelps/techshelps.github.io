<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Multiple Conversations</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="d22k0i"></A><B>Multiple Conversations</B></P>

<P>A client application can use the <A HREF="g2v2ut.htm"><B>DdeConnectList</B></A> function to determine whether any servers of interest are available in the system. A client specifies a service name and topic name when it calls <B>DdeConnectList</B>, causing the DDEML to broadcast the <A HREF="hf4ju2.htm">XTYP_WILDCONNECT</A> transaction to the DDE callback functions of all servers that match the service name (except those that filter the transaction). A server's callback function should return a data handle that identifies a null-terminated array of <A HREF="hitezb.htm"><B>HSZPAIR</B></A> structures. The array should contain one structure for each service name and topic name pair that matches the pair specified by the client. The DDEML establishes a conversation for each <B>HSZPAIR</B> structure filled by the server and returns a conversation list handle to the client. The server receives the conversation handle by way of the <A HREF="a65c1_.htm">XTYP_CONNECT</A>_CONFIRM transaction (unless the server filters this transaction). </P>

<P>A client can specify NULL for the service name, topic name, or both when it calls <B>DdeConnectList</B>. If the service name is NULL, all servers in the system that support the specified topic name respond. A conversation is established with each responding server, including multiple instances of the same server. If the topic name is NULL, a conversation is established on each topic recognized by each server that matches the service name. </P>

<P>A client can use the <A HREF="574uwh.htm"><B>DdeQueryNextServer</B></A> and <A HREF="14336h1.htm"><B>DdeQueryConvInfo</B></A> functions to identify the servers that respond to <B>DdeConnectList</B>. <B>DdeQueryNextServer</B> returns the next conversation handle in a conversation list, and <B>DdeQueryConvInfo</B> fills a <A HREF="8ebxhj.htm"><B>CONVINFO</B></A> structure with information about the conversation. The client can keep the conversation handles that it needs and discard the rest from the conversation list. </P>

<P>The following example uses <B>DdeConnectList</B> to establish conversations with all servers that support the System topic and then uses the <B>DdeQueryNextServer</B> and <B>DdeQueryConvInfo</B> functions to obtain the servers' service name string handles and store them in a buffer. </P>

<P>HCONVLIST hconvList; /* conversation list       */  </P>

<P>DWORD idInst;        /* instance identifier     */  </P>

<P>HSZ hszSystem;       /* System topic            */ </P>

<P>HCONV hconv = NULL;  /* conversation handle     */ </P>

<P>CONVINFO ci;         /* holds conversation data */ </P>

<P>UINT cConv = 0;      /* count of conv. handles  */ </P>

<P>HSZ *pHsz, *aHsz;    /* point to string handles */ </P>

<P></P>

<P>/* Connect to all servers that support the System topic. */ </P>

<P></P>

<P>hconvList = DdeConnectList(idInst, NULL, hszSystem, NULL, NULL); </P>

<P></P>

<P>/* Count the number of handles in the conversation list. */ </P>

<P></P>

<P>while ((hconv = DdeQueryNextServer(hconvList, hconv)) != NULL) </P>

<P>cConv++; </P>

<P></P>

<P>/* Allocate a buffer for the string handles. */ </P>

<P></P>

<P>hconv = NULL; </P>

<P>aHsz = (HSZ *) LocalAlloc(LMEM_FIXED, cConv * sizeof(HSZ)); </P>

<P></P>

<P>/* Copy the string handles to the buffer. */ </P>

<P></P>

<P>pHsz = aHsz; </P>

<P>while ((hconv = DdeQueryNextServer(hconvList, hconv)) != NULL) { </P>

<P>DdeQueryConvInfo(hconv, QID_SYNC, (PCONVINFO) &amp;ci); </P>

<P>DdeKeepStringHandle(idInst, ci.hszSvcPartner); </P>

<P>*pHsz++ = ci.hszSvcPartner; </P>

<P>} </P>

<P></P>

<P>. </P>

<P>. /* Use the handles; converse with the servers. */ </P>

<P>. </P>

<P></P>

<P>/* Free the memory and terminate the conversations. */ </P>

<P></P>

<P>LocalFree((HANDLE) aHsz); </P>

<P>DdeDisconnectList(hconvList); </P>

<P></P>

<P>An application can terminate an individual conversation in a conversation list by calling the <A HREF="0._qht.htm"><B>DdeDisconnect</B></A> function. An application can terminate all conversations in a conversation list by calling the <A HREF="6lfheq.htm"><B>DdeDisconnectList</B></A> function. Both functions cause the DDEML to send <A HREF="1jgppl1.htm">XTYP_DISCONNECT</A> transactions to each partner's DDE callback function. <B>DdeDisconnectList</B> sends an XTYP_DISCONNECT transaction for each conversation handle in the list. </P>

<P>A client can retrieve a list of the conversation handles in a conversation list by passing an existing conversation list handle to <A HREF="g2v2ut.htm"><B>DdeConnectList</B></A>. The enumeration process removes the handles of terminated conversations from the list, and nonduplicate conversations that fit the specified service name and topic name are added. </P>

<P>If <B>DdeConnectList</B> specifies an existing conversation list handle, the function creates a new conversation list that contains the handles of any new conversations and the handles from the existing list. </P>

<P>If duplicate conversations exist, <B>DdeConnectList</B> attempts to prevent duplicate conversation handles in the conversation list. A duplicate conversation is a second conversation with the same server on the same service name and topic name. Two such conversations would have different handles, yet they would identify the same conversation. </P>

</BODY>
</HTML>
