<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>DeviceIoControl</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="64ie_y8"></A><B>DeviceIoControl  <A HREF="ecd1ho.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="5jpun8.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="llpv25.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>DeviceIoControl</B> function sends a control code directly to a specified device driver, causing the corresponding device to perform the specified operation. </P>

<P><B>BOOL DeviceIoControl(</B></P>

<TABLE cols=2 width=630>

<TR VALIGN="top">
<TD width=38%><B>HANDLE</B> <I>hDevice</I><B>,</B></TD>
<TD width=62%>// handle to device of interest</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    DWORD</B> <I>dwIoControlCode</I><B>,</B></TD>
<TD width=62%>// control code of operation to perform</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    LPVOID</B> <I>lpInBuffer</I><B>,</B></TD>
<TD width=62%>// pointer to buffer to supply input data</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    DWORD</B> <I>nInBufferSize</I><B>,</B></TD>
<TD width=62%>// size of input buffer</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    LPVOID</B> <I>lpOutBuffer</I><B>,</B></TD>
<TD width=62%>// pointer to buffer to receive output data</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    DWORD</B> <I>nOutBufferSize</I><B>,</B></TD>
<TD width=62%>// size of output buffer</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    LPDWORD</B> <I>lpBytesReturned</I><B>,</B></TD>
<TD width=62%>// pointer to variable to receive output byte count</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    LPOVERLAPPED</B> <I>lpOverlapped</I> </TD>
<TD width=62%>// pointer to overlapped structure for asynchronous operation</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>   );</B></TD>
<TD width=62%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hDevice</I></P>

<P>Handle to the device that is to perform the operation. Call the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function to obtain a device handle. </P>

<P><I>dwIoControlCode</I></P>

<P>Specifies the control code for the operation. This value identifies the specific operation to be performed and the type of device on which the operation is to be performed. The following values are defined: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=59%><B>Value</B></TD>
<TD width=41%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="j9obcg.htm">FSCTL_DISMOUNT_VOLUME</A></TD>
<TD width=41%>Dismounts a volume.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="2x16aap.htm">FSCTL_GET_COMPRESSION</A></TD>
<TD width=41%>Obtains the compression state of a file or directory</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="1_dusdx.htm">FSCTL_LOCK_VOLUME</A></TD>
<TD width=41%>Locks a volume.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%>FSCTL_READ_COMPRESSION</TD>
<TD width=41%>Reserved for future use.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="4ai_x3u.htm">FSCTL_SET_COMPRESSION</A></TD>
<TD width=41%>Sets the compression state of a file or directory.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="y1w54g.htm">FSCTL_UNLOCK_VOLUME</A></TD>
<TD width=41%>Unlocks a volume.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%>FSCTL_WRITE_COMPRESSION</TD>
<TD width=41%>Reserved for future use.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="3n3k.xf.htm">IOCTL_DISK_CHECK_VERIFY</A></TD>
<TD width=41%>Obsolete. Use IOCTL_STORAGE_CHECK_VERIFY</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF=".eu3b2.htm">IOCTL_DISK_EJECT_MEDIA</A></TD>
<TD width=41%>Obsolete. Use IOCTL_STORAGE_EJECT_MEDIA</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="2.zz_xf.htm">IOCTL_DISK_FORMAT_TRACKS</A></TD>
<TD width=41%>Formats a contiguous set of disk tracks.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="9febv1.htm">IOCTL_DISK_GET_DRIVE_GEOMETRY</A></TD>
<TD width=41%>Obtains information on the physical disk's geometry.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="1bmlvm..htm">IOCTL_DISK_GET_DRIVE_LAYOUT</A></TD>
<TD width=41%>Provides information about each partition on a disk.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="36ol_9p.htm">IOCTL_DISK_GET_MEDIA_TYPES</A></TD>
<TD width=41%>Obsolete. Use IOCTL_STORAGE_GET_MEDIA_TYPES</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="1_q14qn.htm">IOCTL_DISK_GET_PARTITION_INFO</A></TD>
<TD width=41%>Obtains disk partition information.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="00sghf.htm">IOCTL_DISK_LOAD_MEDIA</A></TD>
<TD width=41%>Obsolete. Use IOCTL_STORAGE_LOAD_MEDIA</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF=".jm1a5.htm">IOCTL_DISK_MEDIA_REMOVAL</A></TD>
<TD width=41%>Obsolete. Use IOCTL_STORAGE_MEDIA_REMOVAL</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="x_zr8z.htm">IOCTL_DISK_PERFORMANCE</A></TD>
<TD width=41%>Provides disk performance information.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF=".ncsbl.htm">IOCTL_DISK_REASSIGN_BLOCKS</A></TD>
<TD width=41%>Maps disk blocks to spare-block pool.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="15hzhn_.htm">IOCTL_DISK_SET_DRIVE_LAYOUT</A></TD>
<TD width=41%>Partitions a disk.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="1hgd_wg.htm">IOCTL_DISK_SET_PARTITION_INFO</A></TD>
<TD width=41%>Sets the disk partition type.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="1cghmow.htm">IOCTL_DISK_VERIFY</A></TD>
<TD width=41%>Performs logical format of a disk extent.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="1dghk4f.htm">IOCTL_SERIAL_LSRMST_INSERT</A></TD>
<TD width=41%>Enables or disables placement of a line and modem status data into the data stream.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="h9w6ip.htm">IOCTL_STORAGE_CHECK_VERIFY</A></TD>
<TD width=41%>Checks for change in a removable-media device.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="rezlus.htm">IOCTL_STORAGE_EJECT_MEDIA</A></TD>
<TD width=41%>Ejects media from a SCSI device.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="djbjjx.htm">IOCTL_STORAGE_GET_MEDIA_TYPES</A></TD>
<TD width=41%>Obtains information about media support.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="3owf.s4.htm">IOCTL_STORAGE_LOAD_MEDIA</A></TD>
<TD width=41%>Loads media into a device.</TD>
</TR>

<TR VALIGN="top">
<TD width=59%><A HREF="2mdtgb..htm">IOCTL_STORAGE_MEDIA_REMOVAL</A></TD>
<TD width=41%>Enables or disables the media eject mechanism.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>For more detailed information on each control code, see its topic. In particular, each topic provides details on the usage of the <I>lpInBuffer</I>, <I>nInBufferSize</I>, <I>lpOutBuffer</I>, <I>nOutBufferSize</I>, and <I>lpBytesReturned</I> parameters.</P>

<P><I>lpInBuffer</I></P>

<P>Pointer to a buffer that contains the data required to perform the operation. </P>

<P>This parameter can be NULL if the <I>dwIoControlCode</I> parameter specifies an operation that does not require input data. </P>

<P><I>nInBufferSize</I></P>

<P>Specifies the size, in bytes, of the buffer pointed to by <I>lpInBuffer</I>. </P>

<P><I>lpOutBuffer</I></P>

<P>Pointer to a buffer that receives the operation's output data. </P>

<P>This parameter can be NULL if the <I>dwIoControlCode</I> parameter specifies an operation that does not produce output data. </P>

<P><I>nOutBufferSize</I></P>

<P>Specifies the size, in bytes, of the buffer pointed to by <I>lpOutBuffer</I>. </P>

<P><I>lpBytesReturned</I></P>

<P>Pointer to a variable that receives the size, in bytes, of the data stored into the buffer pointed to by <I>lpOutBuffer</I>. </P>

<P>If <I>lpOverlapped</I> is NULL, <I>lpBytesReturned</I> cannot be NULL. Even when an operation produces no output data, and <I>lpOutBuffer</I> can be NULL, the <B>DeviceIoControl</B> function makes use of the variable pointed to by <I>lpBytesReturned</I>. After such an operation, the value of the variable is without meaning. </P>

<P>If <I>lpOverlapped</I> is not NULL, <I>lpBytesReturned</I> can be NULL. If this is an overlapped operation, you can get the number of bytes returned by calling <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A>. If <I>hDevice</I> is associated with an I/O completion port, you can get the number of bytes returned by calling <A HREF="h734vj.htm"><B>GetQueuedCompletionStatus</B></A>.</P>

<P><I>lpOverlapped</I></P>

<P>Pointer to an <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure. </P>

<P>If <I>hDevice</I> was opened with the FILE_FLAG_OVERLAPPED flag, this parameter must point to a valid <B>OVERLAPPED</B> structure. In this case, <B>DeviceIoControl</B> is performed as an overlapped (asynchronous) operation. If the device was opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is NULL, the function fails in unpredictable ways.</P>

<P>If <I>hDevice</I> was opened without specifying the FILE_FLAG_OVERLAPPED flag, this parameter is ignored and the <B>DeviceIoControl</B> function does not return until the operation has been completed, or an error occurs. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To get extended error information, call <A HREF="11c2vs7.htm"><B>GetLastError</B></A>. </P>

<P><B>Remarks</B></P>

<P>If <I>hDevice</I> was opened with FILE_FLAG_OVERLAPPED and the <I>lpOverlapped</I> parameter points to an <B>OVERLAPPED</B> structure, <B>DeviceIoControl</B> is performed as an overlapped (asynchronous) operation. In this case, the <B>OVERLAPPED</B> structure must contain a handle to a manual-reset event object created by a call to the <B>CreateEvent</B> function. For more information on manual-reset event objects, see <A HREF="36dp5f5.htm">Synchronization</A>. </P>

<P>If the overlapped operation cannot be completed immediately, the function returns FALSE, and <B>GetLastError</B> returns ERROR_IO_PENDING, indicating that the operation is executing in the background. When this happens, the operating system sets the event object in the <B>OVERLAPPED</B> structure to the nonsignaled state before <B>DeviceIoControl</B> returns. The system then sets the event object to the signaled state when the operation has been completed. The calling thread can use any of the wait functions to wait for the event object to be signaled, and then use the <B>GetOverlappedResult</B> function to determine the results of the operation. The <B>GetOverlappedResult</B> function reports the success or failure of the operation and the number of bytes returned in the <I>lpOutBuffer</I> buffer. </P>

<P><B>See Also</B></P>

<P><A HREF="j_zbjv.htm"><B>CreateEvent</B></A>, <A HREF="xn35yd.htm"><B>CreateFile</B></A>, <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A>, <A HREF="h734vj.htm"><B>GetQueuedCompletionStatus</B></A>, <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
