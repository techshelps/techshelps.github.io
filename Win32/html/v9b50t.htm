<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using Brushes</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="v9b50t"></A><B>Using Brushes</B></P>

<P>You can use a brush to paint the interior of virtually any shape by using a GDI function. This includes the interiors of rectangles, ellipses, polygons, and paths. Depending on the requirements of your application, you can use a solid brush of a specified color, a stock brush, a hatch brush, or a pattern brush. </P>

<P>This section contains code samples that demonstrate the creation of a custom brush dialog box. The dialog box contains a grid that represents the bitmap Windows uses as a brush. A user can use this grid to create a pattern-brush bitmap and then view the custom pattern by clicking the Test Pattern button. </P>

<P>The following illustration shows a pattern created by using the Custom Brush dialog box. </P>

<P><IMG SRC="../images/bm57.gif" ALT="" BORDER=0></P>

<P>To display a dialog box, you must first create a dialog box template. The following dialog box template defines the Custom Brush dialog box. </P>

<P>CustBrush DIALOG 6, 18, 160, 118  </P>

<P>STYLE WS_DLGFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION </P>

<P>CAPTION "Custom Brush" </P>

<P>FONT 8, "MS Sans Serif" </P>

<P>BEGIN </P>

<P>CONTROL         "", IDD_GRID, "Static", SS_BLACKFRAME | </P>

<P>WS_CHILD, 3, 2, 83, 79 </P>

<P>CONTROL         "", IDD_RECT, "Static", SS_BLACKFRAME | </P>

<P>WS_CHILD, 96, 11, 57, 28 </P>

<P>PUSHBUTTON      "Test Pattern", IDD_PAINTRECT, 96, 47, 57, 14 </P>

<P>PUSHBUTTON      "OK", IDD_OK, 29, 98, 40, 14 </P>

<P>PUSHBUTTON      "Cancel", IDD_CANCEL, 92, 98, 40, 14 </P>

<P>END </P>

<P></P>

<P>The Custom Brush dialog box contains five controls: a bitmap-grid window, a pattern-viewing window, and three push buttons, labeled Test Pattern, OK and Cancel. The Test Pattern push button enables the user to view the pattern. The dialog box template specifies the overall dimensions of the dialog box window, assigns a value to each control, specifies the location of each control, and so forth. (For more information about creating dialog box templates, see <A HREF="ceyqch.htm">Dialog Boxes</A>.) </P>

<P>The control values in the dialog box template are constants that have been defined as follows in the application's header file. </P>

<P>#define IDD_GRID  120  </P>

<P>#define IDD_RECT  121 </P>

<P>#define IDD_PAINTRECT 122 </P>

<P>#define IDD_OK  123 </P>

<P>#define IDD_CANCEL 124 </P>

<P></P>

<P>After you create a dialog box template and include it in the application's resource-definition file, you must write a dialog procedure. This procedure processes messages that Windows sends to the dialog box. The following excerpt from an application's source code shows the dialog box procedure for the Custom Brush dialog box and the two application-defined functions it calls. </P>

<P>int APIENTRY BrushDlgProc(HWND hdlg, WORD message, LONG wParam,  </P>

<P>LONG lParam) </P>

<P>{ </P>

<P>static HWND hwndGrid;       /* grid-window control     */ </P>

<P>static HWND hwndBrush;      /* pattern-brush control   */ </P>

<P>static RECT rctGrid;        /* grid-window rectangle   */ </P>

<P>static RECT rctBrush;       /* pattern-brush rectangle */ </P>

<P>static UINT bBrushBits[8];  /* bitmap bits             */ </P>

<P>static RECT rect[64];       /* grid-cell array         */ </P>

<P>static HBITMAP hbm;         /* bitmap handle           */ </P>

<P>HBRUSH hbrush;              /* current brush           */ </P>

<P>HBRUSH hbrushOld;           /* default brush           */ </P>

<P>HRGN hrgnCell;              /* test-region handle      */ </P>

<P>HDC hdc;                    /* DC handle               */ </P>

<P>int x, y, deltaX, deltaY;   /* drawing coordinates     */ </P>

<P>POINTS ptlHit;              /* mouse coordinates       */ </P>

<P>int i;                      /* count variable          */ </P>

<P></P>

<P>switch (message) </P>

<P>{ </P>

<P>case WM_INITDIALOG: </P>

<P></P>

<P>/* </P>

<P>* Retrieve a window handle for the grid-window and </P>

<P>* pattern-brush controls </P>

<P>*/ </P>

<P></P>

<P>hwndGrid = GetDlgItem(hdlg, IDD_GRID); </P>

<P>hwndBrush = GetDlgItem(hdlg, IDD_RECT); </P>

<P></P>

<P>/* Initialize the array of bits that defines the </P>

<P>* custom brush pattern with the value 1 to produce a </P>

<P>* solid white brush). </P>

<P>*/ </P>

<P>for (i=0; i&lt;8; i++) </P>

<P>bBrushBits[i] = 0xFF; </P>

<P></P>

<P>/* </P>

<P>* Retrieve dimensions for the grid-window and pattern-brush </P>

<P>* controls. </P>

<P>*/ </P>

<P></P>

<P>GetClientRect(hwndGrid, &amp;rctGrid); </P>

<P>GetClientRect(hwndBrush, &amp;rctBrush); </P>

<P></P>

<P>/* Determine the width and height of a single cell. */ </P>

<P></P>

<P>deltaX = (rctGrid.right - rctGrid.left)/8; </P>

<P>deltaY = (rctGrid.bottom - rctGrid.top)/8; </P>

<P></P>

<P>/* Initialize the array of cell rectangles. */ </P>

<P></P>

<P>for (y=rctGrid.top, i=0; y &lt; rctGrid.bottom; y += deltaY){ </P>

<P>for (x=rctGrid.left; x &lt; (rctGrid.right - 8) &amp;&amp; i &lt; 64; </P>

<P>x += deltaX, i++) { </P>

<P>rect[i].left = x; rect[i].top = y; </P>

<P>rect[i].right = x + deltaX; </P>

<P>rect[i].bottom = y + deltaY; </P>

<P>} </P>

<P>} </P>

<P>return FALSE; </P>

<P></P>

<P></P>

<P>case WM_PAINT: </P>

<P></P>

<P></P>

<P>/* Draw the grid. */ </P>

<P></P>

<P>hdc = GetDC(hwndGrid); </P>

<P></P>

<P>for (i=rctGrid.left; i&lt;rctGrid.right; </P>

<P>i+=(rctGrid.right - rctGrid.left)/8){ </P>

<P>MoveToEx(hdc, i, rctGrid.top, NULL); </P>

<P>LineTo(hdc, i, rctGrid.bottom); </P>

<P>} </P>

<P>for (i=rctGrid.top; i&lt;rctGrid.bottom; </P>

<P>i+=(rctGrid.bottom - rctGrid.top)/8){ </P>

<P>MoveToEx(hdc, rctGrid.left, i, NULL); </P>

<P>LineTo(hdc, rctGrid.right, i); </P>

<P>} </P>

<P>ReleaseDC(hwndGrid, hdc); </P>

<P>return FALSE; </P>

<P></P>

<P></P>

<P>case WM_LBUTTONDOWN: </P>

<P></P>

<P>/* Store the mouse coordinates in a POINT structure. */ </P>

<P></P>

<P>ptlHit = MAKEPOINTS((POINTS FAR *)lParam); </P>

<P></P>

<P>/* </P>

<P>* Create a rectangular region with dimensions and </P>

<P>* coordinates that correspond to those of the grid </P>

<P>* window. </P>

<P>*/ </P>

<P></P>

<P>hrgnCell = CreateRectRgn(rctGrid.left, rctGrid.top, </P>

<P>rctGrid.right, rctGrid.bottom); </P>

<P></P>

<P>/* Retrieve a window DC for the grid window. */ </P>

<P></P>

<P>hdc = GetDC(hwndGrid); </P>

<P></P>

<P>/* Select the region into the DC. */ </P>

<P></P>

<P>SelectObject(hdc, hrgnCell); </P>

<P></P>

<P>/* Test for a button click in the grid-window rectangle. */ </P>

<P></P>

<P>if (PtInRegion(hrgnCell, ptlHit.x, ptlHit.y)){ </P>

<P></P>

<P>/* </P>

<P>* A button click occurred in the grid-window rectangle; </P>

<P>* isolate the cell in which it occurred. </P>

<P>*/ </P>

<P></P>

<P>for(i=0; i&lt;64; i++){ </P>

<P>DeleteObject(hrgnCell); </P>

<P></P>

<P>hrgnCell = CreateRectRgn(rect[i].left, rect[i].top, </P>

<P>rect[i].right, rect[i].bottom); </P>

<P></P>

<P>if (PtInRegion(hrgnCell, ptlHit.x, ptlHit.y)){ </P>

<P>InvertRgn(hdc, hrgnCell); </P>

<P></P>

<P>/* Set the appropriate brush bits. */ </P>

<P></P>

<P>if (i % 8 == 0) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x80; </P>

<P>else if (i % 8 == 1) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x40; </P>

<P>else if (i % 8 == 2) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x20; </P>

<P>else if (i % 8 == 3) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x10; </P>

<P>else if (i % 8 == 4) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x08; </P>

<P>else if (i % 8 == 5) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x04; </P>

<P>else if (i % 8 == 6) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x02; </P>

<P>else if (i % 8 == 7) </P>

<P>bBrushBits[i/8] = bBrushBits[i/8] ^ 0x01; </P>

<P></P>

<P>/* Exit the "for" loop after the bit is set. */ </P>

<P></P>

<P>break; </P>

<P>} /* end if */ </P>

<P></P>

<P>} /* end for */ </P>

<P></P>

<P>} /* end if */ </P>

<P></P>

<P>/* Release the DC for the control. */ </P>

<P></P>

<P>ReleaseDC(hwndGrid, hdc); </P>

<P>return TRUE; </P>

<P></P>

<P></P>

<P>case WM_COMMAND: </P>

<P>switch (wParam){ </P>

<P>case IDD_PAINTRECT: </P>

<P></P>

<P>hdc = GetDC(hwndBrush); </P>

<P></P>

<P>/* Create a monochrome bitmap. */ </P>

<P></P>

<P>hbm = CreateBitmap(8, 8, 1, 1, </P>

<P>(LPBYTE)bBrushBits); </P>

<P></P>

<P>/* Select the custom brush into the DC.      */ </P>

<P></P>

<P>hbrush = CreatePatternBrush(hbm); </P>

<P></P>

<P>hbrushOld = SelectObject(hdc, hbrush); </P>

<P></P>

<P>/* Use the custom brush to fill the rectangle. */ </P>

<P></P>

<P>Rectangle(hdc, rctBrush.left, rctBrush.top, </P>

<P>rctBrush.right, rctBrush.bottom); </P>

<P></P>

<P>/* Clean up memory. */ </P>

<P>SelectObject(hdc, hbrushOld); </P>

<P>DeleteObject(hbrush); </P>

<P>DeleteObject(hbm); </P>

<P></P>

<P>ReleaseDC(hwndBrush, hdc); </P>

<P>return TRUE; </P>

<P></P>

<P>case IDD_OK: </P>

<P></P>

<P>case IDD_CANCEL: </P>

<P>EndDialog(hdlg, TRUE); </P>

<P>return TRUE; </P>

<P></P>

<P>} /* end switch */ </P>

<P>break; </P>

<P>default: </P>

<P>return FALSE; </P>

<P>} </P>

<P>} </P>

<P></P>

<P></P>

<P>int GetStrLngth(LPTSTR cArray) </P>

<P>{ </P>

<P>int i = 0; </P>

<P></P>

<P>while (cArray[i++] != 0); </P>

<P>return i-1; </P>

<P></P>

<P>} </P>

<P></P>

<P>DWORD RetrieveWidth(LPTSTR cArray, int iLength) </P>

<P>{ </P>

<P>int i, iTmp; </P>

<P>double dVal, dCount; </P>

<P></P>

<P>dVal = 0.0; </P>

<P>dCount = (double)(iLength-1); </P>

<P>for (i=0; i&lt;iLength; i++){ </P>

<P>iTmp = cArray[i] - 0x30; </P>

<P>dVal = dVal + (((double)iTmp) * pow(10.0, dCount--)); </P>

<P>} </P>

<P></P>

<P>return (DWORD)dVal; </P>

<P>} </P>

<P></P>

<P>The dialog box procedure for the Custom Brush dialog box processes four messages, as described in the following table. </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=34%><B>Message</B></TD>
<TD width=66%><B>Action</B></TD>
</TR>

<TR VALIGN="top">
<TD width=34%><A HREF="ii1w.b.htm">WM_INITDIALOG</A></TD>
<TD width=66%>Retrieves a window handle and dimensions for the grid-window and pattern-brush controls, computes the dimensions of a single cell in the grid-window control, and initializes an array of grid-cell coordinates.</TD>
</TR>

<TR VALIGN="top">
<TD width=34%><A HREF="f55xz2.htm">WM_PAINT</A></TD>
<TD width=66%>Draws the grid pattern in the grid-window control.</TD>
</TR>

<TR VALIGN="top">
<TD width=34%><A HREF="065j6u.htm">WM_LBUTTONDOWN</A></TD>
<TD width=66%>Determines whether the cursor is within the grid-window control when the user presses the left mouse button. If so, the dialog box procedure inverts the appropriate grid cell and records the state of that cell in an array of bits that is used to create the bitmap for the custom brush.</TD>
</TR>

<TR VALIGN="top">
<TD width=34%><A HREF="71v.3j.htm">WM_COMMAND</A></TD>
<TD width=66%>Processes input for the three push button controls. If the user presses the Test Pattern button, the dialog box procedure paints the Test Pattern control with the new custom brush pattern. If the user presses the OK or Cancel button, the dialog box procedure performs actions accordingly.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>For more information about messages and message processing, see <A HREF="21n71oj.htm">Messages and Message Queues</A>. </P>

<P>After you write the dialog box procedure, export it in the module-definition file, include the function definition for the procedure in the application's header file, and then call the dialog box procedure at the appropriate point in the application. </P>

<P>The following excerpt from the module-definition file shows how the dialog box procedure for the Custom Brush is exported. </P>

<P>; Export all functions that are called by a Windows routine.  </P>

<P></P>

<P>EXPORTS </P>

<P>MainWndProc   @1   ; name of window processing function </P>

<P>BrushDlgProc  @2   ; name of custom-brush processing function </P>

<P></P>

<P>The following excerpt from the application's header file shows the function definition for the dialog box procedure and the two functions it calls. </P>

<P>int APIENTRY BrushDlgProc(HWND hdlg, WORD message, LONG wParam,  </P>

<P>LONG lParam); </P>

<P>int GetStrLngth(LPTSTR cArray); </P>

<P>DWORD RetrieveWidth(LPTSTR cArray, int iLength); </P>

<P></P>

<P>Finally, the following code shows how the dialog box procedure is called from the application's source-code file. In this example, the dialog box procedure is called when the user chooses an option from the application's menu. </P>

<P>switch (message)  </P>

<P>{ </P>

<P>case WM_CREATE: </P>

<P>break; </P>

<P>case WM_COMMAND:          // command from application menu  </P>

<P>switch(wParam) </P>

<P>{ </P>

<P>case IDM_CUSTOMBRUSH: </P>

<P>DialogBox((HANDLE)GetModuleHandle(NULL), </P>

<P>(LPTSTR)"CustBrush", hWnd, </P>

<P>(DLGPROC)BrushDlgProc); </P>

<P>break; </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
