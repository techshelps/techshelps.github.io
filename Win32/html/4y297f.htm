<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>File Viewer Structure and Implementation</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="4y297f"></A><B>File Viewer Structure and Implementation</B></P>

<P>A file viewer is an OLE component object in an in-process server DLL where the object implements the <B>IPersistFile</B> and <A HREF="33s7zao.htm"><B>IFileViewer</B></A><I> </I>interfaces. The in-process server exports the <B>DllGetClassObject</B> and <B>DllCanUnloadNow</B> functions, implements a class factory object with the <B>IClassFactory</B> interface, and implements the file viewer object with the interfaces required. The following illustration shows the structure of a file viewer.</P>

<P><IMG SRC="../images/bm43.gif" ALT="" BORDER=0></P>

<P>There are a number of reasons why a file viewer is best implemented in a DLL with the given interfaces. In general, a DLL is faster to load and usually comes in a small package. In the future, these same DLLs will provide other nonuser interface features, such as content indexing, and a component object DLL will be the most efficient and fastest way to access those features. In some cases, a file viewer object may need to display pop-up windows and process messages through its own message loop as in Windows 95. The DLL structure still allows this when used in conjunction with a stub process like Quick View, which gives the file viewer DLL the right to execute a message loop.</P>

<P>The <B>IPersistFile</B> interface in the file viewer object is intended to be a general mechanism through which the object is given a path for a file. From then on, the component that loaded the object can ask it to do any number of things with the file. Through Quick View, the Windows 95 shell asks the object to show the file  by using the <B>IFileViewer::ShowInitialize</B><I> </I>and <B>IFileViewer::Show</B> member functions or asks the object to print the file to a specific printer by using the <B>IFileViewer::PrintTo</B> member function. In the future, the shell may ask the object to perform content indexing, which would happen through an interface other than <A HREF="33s7zao.htm"><B>IFileViewer</B></A><I>. </I>For this reason, the file loading member functions of <B>IPersistFile</B> are separate from the operations that perform on the file, which is why <B>IFileViewer</B> was not just extended with its own <B>Load</B> member function. This latter option is a little more efficient (because it avoids <B>IPersistFile</B> entrypoint functions that are not implemented), but the design given here is easier to extend. </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
