<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>ReadFile</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="cjnd8p"></A><B>ReadFile  <A HREF="udy9_7.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="qnj9so.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="1f83g2.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>ReadFile</B> function reads data from a file, starting at the position indicated by the file pointer. After the read operation has been completed, the file pointer is adjusted by the number of bytes actually read, unless the file handle is created with the overlapped attribute. If the file handle is created for overlapped input and output (I/O), the application must adjust the position of the file pointer after the read operation. </P>

<P><B>BOOL ReadFile(</B></P>

<TABLE cols=2 width=525>

<TR VALIGN="top">
<TD width=50%><B>HANDLE</B> <I>hFile</I><B>,</B></TD>
<TD width=50%>// handle of file to read </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>    LPVOID</B> <I>lpBuffer</I><B>,</B></TD>
<TD width=50%>// address of buffer that receives data  </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>    DWORD</B> <I>nNumberOfBytesToRead</I><B>,</B></TD>
<TD width=50%>// number of bytes to read </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>    LPDWORD</B> <I>lpNumberOfBytesRead</I><B>,</B></TD>
<TD width=50%>// address of number of bytes read </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>    LPOVERLAPPED</B> <I>lpOverlapped</I> </TD>
<TD width=50%>// address of structure for data </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>   );</B></TD>
<TD width=50%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hFile</I></P>

<P>Identifies the file to be read. The file handle must have been created with GENERIC_READ access to the file. </P>

<P><B>Windows NT</B></P>

<P>For asynchronous read operations, <I>hFile</I> can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the <A HREF="xn35yd.htm"><B>CreateFile</B></A> function, or a socket handle returned by the <B>socket</B> or <B>accept</B> functions.</P>

<P><B>Windows 95</B></P>

<P>For asynchronous read operations, <I>hFile</I> can be a communications resource, mailslot, or named pipe handle opened with the FILE_FLAG_OVERLAPPED flag by <B>CreateFile</B>, or a socket handle returned by the <B>socket</B> or <B>accept</B> functions. Windows 95 does not support asynchronous read operations on disk files.</P>

<P><I>lpBuffer</I></P>

<P>Points to the buffer that receives the data read from the file. </P>

<P><I>nNumberOfBytesToRead</I></P>

<P>Specifies the number of bytes to be read from the file. </P>

<P><I>lpNumberOfBytesRead</I></P>

<P>Points to the number of bytes read. <B>ReadFile</B> sets this value to zero before doing any work or error checking. If this parameter is zero when <B>ReadFile</B> returns TRUE on a named pipe, the other end of the message-mode pipe called the <A HREF="g0sox_.htm"><B>WriteFile</B></A> function with <I>nNumberOfBytesToWrite</I> set to zero. </P>

<P>If <I>lpOverlapped</I> is NULL, <I>lpNumberOfBytesRead</I> cannot be NULL.</P>

<P>If <I>lpOverlapped</I> is not NULL, <I>lpNumberOfBytesRead</I> can be NULL. If this is an overlapped read operation, you can get the number of bytes read by calling <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A>. If <I>hFile</I> is associated with an I/O completion port, you can get the number of bytes read by calling <A HREF="h734vj.htm"><B>GetQueuedCompletionStatus</B></A>.</P>

<P><I>lpOverlapped</I></P>

<P>Points to an <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A> structure. This structure is required if <I>hFile</I> was created with FILE_FLAG_OVERLAPPED.</P>

<P>If <I>hFile</I> was opened with FILE_FLAG_OVERLAPPED, the <I>lpOverlapped</I> parameter must not be NULL. It must point to a valid <B>OVERLAPPED</B> structure. If <I>hFile</I> was created with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is NULL, the function can incorrectly report that the read operation is complete. </P>

<P>If <I>hFile</I> was opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is not NULL, the read operation starts at the offset specified in the <B>OVERLAPPED</B> structure and <B>ReadFile</B> may return before the read operation has been completed. In this case, <B>ReadFile</B> returns FALSE and the <B>GetLastError</B> function returns ERROR_IO_PENDING. This allows the calling process to continue while the read operation finishes. The event specified in the <B>OVERLAPPED</B> structure is set to the signaled state upon completion of the read operation. </P>

<P>If <I>hFile</I> was not opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is NULL, the read operation starts at the current file position and <B>ReadFile</B> does not return until the operation has been completed.</P>

<P>If <I>hFile</I> is not opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is not NULL, the read operation starts at the offset specified in the <B>OVERLAPPED</B> structure. <B>ReadFile</B> does not return until the read operation has been completed. </P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero. </P>

<P>If the return value is nonzero and the number of bytes read is zero, the file pointer was beyond the current end of the file at the time of the read operation. However, if the file was opened with FILE_FLAG_OVERLAPPED and <I>lpOverlapped</I> is not NULL, the return value is FALSE and <A HREF="11c2vs7.htm"><B>GetLastError</B></A> returns ERROR_HANDLE_EOF when the file pointer goes beyond the current end of file.</P>

<P>If the function fails, the return value is zero. To get extended error information, call <B>GetLastError</B>. </P>

<P><B>Remarks</B></P>

<P><B>ReadFile</B> returns when one of the following is true: a write operation completes on the write end of the pipe, the number of bytes requested has been read, or an error occurs.</P>

<P>If part of the file is locked by another process and the read operation overlaps the locked portion, this function fails. </P>

<P>Applications must not read from nor write to the input buffer that a read operation is using until the read operation completes. A premature access to the input buffer may lead to corruption of the data read into that buffer.</P>

<P>Characters can be read from the console input buffer by using <B>ReadFile</B> with a handle to console input. The console mode determines the exact behavior of the <B>ReadFile</B> function. </P>

<P>If a named pipe is being read in message mode and the next message is longer than the <I>nNumberOfBytesToRead</I> parameter specifies, <B>ReadFile</B> returns FALSE and <A HREF="11c2vs7.htm"><B>GetLastError</B></A> returns ERROR_MORE_DATA. The remainder of the message may be read by a subsequent call to the <B>ReadFile</B> or <A HREF="3ie31.htm"><B>PeekNamedPipe</B></A> function. </P>

<P>When reading from a communications device, the behavior of <B>ReadFile</B> is governed by the current communication timeouts as set and retrieved using the <A HREF="krcnfq.htm"><B>SetCommTimeouts</B></A> and <A HREF="flt6xa.htm"><B>GetCommTimeouts</B></A> functions. Unpredictable results can occur if you fail to set the timeout values. For more information about communication timeouts, see <A HREF="34jjaa.htm"><B>COMMTIMEOUTS</B></A>.</P>

<P>If <B>ReadFile</B> attempts to read from a mailslot whose buffer is too small, the function returns FALSE and <B>GetLastError</B> returns ERROR_INSUFFICIENT_BUFFER. </P>

<P>If the anonymous write pipe handle has been closed and <B>ReadFile</B> attempts to read using the corresponding anonymous read pipe handle, the function returns FALSE and <B>GetLastError</B> returns ERROR_BROKEN_PIPE. </P>

<P>The <B>ReadFile</B> function may fail and return ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY whenever there are too many outstanding asynchronous I/O requests. </P>

<P>The <B>ReadFile </B>code to check for the end-of-file condition (eof) differs for synchronous and asynchronous read operations.</P>

<P>When a synchronous read operation reaches the end of a file, <B>ReadFile </B>returns TRUE and sets *<I>lpNumberOfBytesRead</I> to zero. The following sample code tests for end-of-file for a synchronous read operation:</P>

<P>// attempt a synchronous read operation  </P>

<P>bResult = ReadFile(hFile, &amp;inBuffer, nBytesToRead, &amp;nBytesRead, NULL) ; </P>

<P>// check for eof </P>

<P>if (bResult &amp;&amp;  nBytesRead == 0, ) { </P>

<P>// we're at the end of the file </P>

<P>} </P>

<P></P>

<P>An asynchronous read operation can encounter the end of a file during the initiating call to <B>ReadFile</B>, or during subsequent asynchronous operation. </P>

<P>If EOF is detected at <B>ReadFile</B> time for an asynchronous read operation, <B>ReadFile</B> returns FALSE and <B>GetLastError</B> returns ERROR_HANDLE_EOF.</P>

<P>If EOF is detected during subsequent asynchronous operation, the call to <B>GetOverlappedResult</B> to obtain the results of that operation returns FALSE and <B>GetLastError </B>returns ERROR_HANDLE_EOF.</P>

<P>To cancel all pending asynchronous I/O operations, use the <A HREF="62a8_h_.htm"><B>CancelIO</B></A> function. This function only cancels operations issued by the calling thread for the specified file handle. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. </P>

<P>The following sample code illustrates testing for end-of-file for an asynchronous read operation:</P>

<P>// set up overlapped structure fields  </P>

<P>// to simplify this sample, we'll eschew an event handle </P>

<P>gOverLapped.Offset     = 0; </P>

<P>gOverLapped.OffsetHigh = 0; </P>

<P>gOverLapped.hEvent     = NULL; </P>

<P></P>

<P>// attempt an asynchronous read operation </P>

<P>bResult = ReadFile(hFile, &amp;inBuffer, nBytesToRead, &amp;nBytesRead, </P>

<P>&amp;gOverlapped) ; </P>

<P></P>

<P>// if there was a problem, or the async. operation's still pending ... </P>

<P>if (!bResult) </P>

<P>{ </P>

<P>// deal with the error code </P>

<P>switch (dwError = GetLastError()) </P>

<P>{ </P>

<P>case ERROR_HANDLE_EOF: </P>

<P>{ </P>

<P>// we're reached the end of the file </P>

<P>// during the call to ReadFile </P>

<P></P>

<P>// code to handle that </P>

<P>} </P>

<P></P>

<P>case ERROR_IO_PENDING: </P>

<P>{ </P>

<P>// asynchronous i/o is still in progress </P>

<P></P>

<P>// do something else for a while </P>

<P>GoDoSomethingElse() ; </P>

<P></P>

<P>// check on the results of the asynchronous read </P>

<P>bResult = GetOverlappedResult(hFile, &amp;gOverlapped, </P>

<P>&amp;nBytesRead, FALSE) ; </P>

<P></P>

<P>// if there was a problem ... </P>

<P>if (!bResult) </P>

<P>{ </P>

<P>// deal with the error code </P>

<P>switch (dwError = GetLastError()) </P>

<P>{ </P>

<P>case ERROR_HANDLE_EOF: </P>

<P>{ </P>

<P>// we're reached the end of the file </P>

<P>//during asynchronous operation </P>

<P>} </P>

<P></P>

<P>// deal with other error cases </P>

<P>} </P>

<P>} </P>

<P>} // end case </P>

<P></P>

<P>// deal with other error cases </P>

<P></P>

<P>} // end switch </P>

<P>} // end if </P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="62a8_h_.htm"><B>CancelIo</B></A>, <A HREF="xn35yd.htm"><B>CreateFile</B></A>, <A HREF="flt6xa.htm"><B>GetCommTimeouts</B></A>, <A HREF="kcz7oz.htm"><B>GetOverlappedResult</B></A>, <A HREF="h734vj.htm"><B>GetQueuedCompletionStatus</B></A>, <A HREF="1n286m5.htm"><B>OVERLAPPED</B></A>, <A HREF="3ie31.htm"><B>PeekNamedPipe</B></A>, <A HREF="fm7wz7.htm"><B>ReadFileEx</B></A>, <A HREF="krcnfq.htm"><B>SetCommTimeouts</B></A>, <A HREF="g0sox_.htm"><B>WriteFile</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
