<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>CryptGetProvParam [New - Windows NT] [New - Windows 95, OEM Service Release 2]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="i6j7dw"></A><B>CryptGetProvParam  <A HREF="18a4qrx.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="1u2hyy.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="5khgnl.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>[New - Windows 95, OEM Service Release 2]</P>

<P>The <B>CryptGetProvParam</B> function lets applications retrieve parameters that govern the operations of a CSP.</P>

<P><B>BOOL CRYPTFUNC CryptGetProvParam(</B></P>

<TABLE cols=2 width=223>

<TR VALIGN="top">
<TD width=85%><B>HCRYPTPROV </B><I>hProv</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwParam</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    BYTE *</B><I>pbData</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD *</B><I>pdwDataLen</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwFlags</I></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>   );</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>hProv</I></P>

<P>[in] A handle to the CSP on which to query parameters.</P>

<P><I>dwParam</I></P>

<P>[in] The parameter number. See the "Remarks" section for a list of valid parameters.</P>

<P><I>pbData</I></P>

<P>[out] The parameter data buffer. The function will copy the specified parameter data to this buffer. The form of this data will vary, depending on the parameter number.</P>

<P>This parameter can be NULL if all you are doing is determining the number of bytes required for the returned parameter data.</P>

<P><I>pdwDataLen</I></P>

<P>[in/out] The address of the parameter data length. Before calling this function, the caller should set this parameter to the length, in bytes, of the <I>pbData</I> buffer. Upon return, this address will contain the number of bytes of parameter data copied to the buffer.</P>

<P>If the buffer specified by <I>pbData</I> is not large enough to hold the data, the function returns the ERROR_MORE_DATA error code through the <B>GetLastError</B> function, and stores the required buffer size in bytes into the variable pointed to by <I>pdwDataLen</I>.</P>

<P>If <I>pbData</I> is NULL, then no error is returned and the function stores the size of the data in bytes in the variable pointed to by <I>pdwDataLen</I>.</P>

<P><B>Note</B>  When one of the enumeration parameters (PP_ENUMALGS or PP_ENUMCONTAINERS) is being read, the <I>pdwDataLen</I> parameter works somewhat differently. If <I>pbData</I> is NULL or the value pointed to <I>pdwDataLen</I> is too small, the value returned in this parameter is the size of the largest item in the enumeration list instead of the size of the item currently being read.</P>

<P>When one of the enumeration parameters is read and the <I>pbData</I> parameter is NULL, the CRYPT_FIRST flag must be specified in order for the size information to be correctly retrieved.</P>

<P><I>dwFlags</I></P>

<P>[in] The flag values. This parameter is normally set to zero.</P>

<P>When one of the enumeration parameters (PP_ENUMALGS or PP_ENUMCONTAINERS) is being read, then the CRYPT_FIRST flag can be specified. When this flag is set, the first item in the enumeration list is returned. If this flag is not set, then the next item in the list is returned.</P>

<P></P>

<P><B>Remarks</B></P>

<P><B>Parameter Numbers</B></P>

<P>The <I>dwParam</I> parameter can be set to one of the following values:</P>

<P>PP_CONTAINER</P>

<P>The key container name. When this parameter is specified, the function fills the <I>pbData</I> buffer with the name of the current key container. This name is in the form of a zero-terminated <B>CHAR</B> string.</P>

<P>This string is exactly the same as the one passed in the <I>pszContainer</I> parameter of the <A HREF="b4q7j2.htm"><B>CryptAcquireContext</B></A> function in order to specify that the current key container be used. This parameter is often read in order to determine the name of the default key container.</P>

<P>PP_ENUMALGS</P>

<P>The algorithm information. When this parameter is specified, the function fills the <I>pbData</I> buffer with information about one of the algorithms supported by the CSP. The PP_ENUMALGS parameter must be read repeatedly to enumerate all the supported algorithms. The algorithms are not enumerated in any particular order.</P>

<P>The first time that the PP_ENUMALGS parameter is read, the CRYPT_FIRST flag should be specified. This will ensure that information about the "first" algorithm in the enumeration list is returned. The PP_ENUMALGS parameter can then be repeatedly read in order to retrieve the information about the rest of the algorithms. When the <B>CryptGetProvParam</B> function fails with the ERROR_NO_MORE_ITEMS, then the end of the enumeration list has been reached. A code sample illustrating this is located in the "Example" section.</P>

<P>The following code fragment indicates the format of the data that the function returns in the <I>pbData</I> buffer.</P>

<P>ALG_ID aiAlgid;</P>

<P>DWORD dwBits;</P>

<P>DWORD dwNameLen;</P>

<P>CHAR szName[dwNameLen];</P>

<P></P>

<P>The following table defines each of these fields.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=21%><B>Field</B></TD>
<TD width=79%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=21%>aiAlgid</TD>
<TD width=79%>The algorithm identifier. This is the value that is passed to the <A HREF="dnbayj.htm"><B>CryptGenKey</B></A>, <A HREF="ioh0._.htm"><B>CryptDeriveKey</B></A>, or <A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A><B> </B>functions in order to specify that a particular algorithm be used.</TD>
</TR>

<TR VALIGN="top">
<TD width=21%>dwBits</TD>
<TD width=79%>The number of bits in the keys used by the algorithm. 
<P>If this is a hash algorithm, this value indicates the number of bits in the hash values generated by this algorithm.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=21%>dwNameLen</TD>
<TD width=79%>The number of characters in the algorithm name, including the terminating zero.</TD>
</TR>

<TR VALIGN="top">
<TD width=21%>szName</TD>
<TD width=79%>The zero-terminated name of the algorithm.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>PP_ENUMCONTAINERS</P>

<P>The key container names. When this parameter is specified, the function fills the <I>pbData</I> buffer with the name of one of the key containers maintained by the CSP. This name is in the form of a zero-terminated <B>CHAR</B> string. The PP_ENUMCONTAINERS parameter must be read repeatedly to enumerate all the container names.</P>

<P>These container names are enumerated in the same way as are the CSP's supported algorithms. Refer to the PP_ENUMALGS for more information.</P>

<P>PP_IMPTYPE</P>

<P>The CSP implementation type. The <I>pbData</I> buffer will contain a <B>DWORD</B> value that indicates how the CSP is implemented. Possible values are:</P>

<P>윢RYPT_IMPL_HARDWARE</P>

<P>윢RYPT_IMPL_SOFTWARE</P>

<P>윢RYPT_IMPL_MIXED</P>

<P>윢RYPT_IMPL_UNKNOWN (the CSP isn't telling)</P>

<P>PP_NAME</P>

<P>The CSP name. When this parameter is specified, the function fills the <I>pbData</I> buffer with the name of the CSP. This name is in the form of a zero-terminated <B>CHAR</B> string.</P>

<P>This string is identical to the one passed in the <I>pszProvider</I> parameter of the <A HREF="b4q7j2.htm"><B>CryptAcquireContext</B></A> function in order to specify that the current CSP be used. For example, the Microsoft RSA Base Provider will return "Microsoft Base Cryptographic Provider v1.0" when this parameter is read.</P>

<P>PP_VERSION</P>

<P>The CSP version number. The <I>pbData</I> buffer will contain a <B>DWORD</B> value that indicates the version number of the CSP. The least significant byte contains the minor version number and the next most significant byte the major version number. For example, version 1.0 would be represented here as 0x00000100.</P>

<P></P>

<P><B>Algorithm Identifiers</B></P>

<P>When enumerating algorithms, your application may need to determine the class of a particular algorithm. For example, you may want to display a list of encryption algorithms to the user and disregard the rest. This can be done with the GET_ALG_CLASS(x) macro. This macro takes an algorithm identifier as an argument and returns a code indicating the general class of algorithm that the identifier belongs to. Possible return values include:</P>

<P>유LG_CLASS_DATA_ENCRYPT</P>

<P>유LG_CLASS_HASH</P>

<P>유LG_CLASS_KEY_EXCHANGE</P>

<P>유LG_CLASS_SIGNATURE</P>

<P></P>

<P>The following table lists the algorithms supported by the Microsoft RSA Base Provider along with the class of each algorithm.</P>

<TABLE cols=3>

<TR VALIGN="top">
<TD width=22%><B>Name</B></TD>
<TD width=32%><B>Identifier</B></TD>
<TD width=46%><B>Class</B></TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"MD2"</TD>
<TD width=32%>CALG_MD2</TD>
<TD width=46%>ALG_CLASS_HASH</TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"MD5"</TD>
<TD width=32%>CALG_MD5</TD>
<TD width=46%>ALG_CLASS_HASH</TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"SHA"</TD>
<TD width=32%>CALG_SHA</TD>
<TD width=46%>ALG_CLASS_HASH</TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"MAC"</TD>
<TD width=32%>CALG_MAC</TD>
<TD width=46%>ALG_CLASS_HASH</TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"RSA_SIGN"</TD>
<TD width=32%>CALG_RSA_SIGN</TD>
<TD width=46%>ALG_CLASS_SIGNATURE</TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"RSA_KEYX"</TD>
<TD width=32%>CALG_RSA_KEYX</TD>
<TD width=46%>ALG_CLASS_KEY_EXCHANGE</TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"RC2"</TD>
<TD width=32%>CALG_RC2</TD>
<TD width=46%>ALG_CLASS_DATA_ENCRYPT</TD>
</TR>

<TR VALIGN="top">
<TD width=22%>"RC4"</TD>
<TD width=32%>CALG_RC4</TD>
<TD width=46%>ALG_CLASS_DATA_ENCRYPT</TD>
</TR>
</TABLE><BR>

<P></P>

<P>If your application does not recognize an algorithm identifier, it is not recommended that it use the algorithm. Making use of an unknown cryptographic algorithm can sometimes produce unpredictable results.</P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To retrieve extended error information, use the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function.</P>

<P>The following table lists the error codes most commonly returned by the <B>GetLastError</B> function. The error codes  prefaced by "NTE" are generated by the particular CSP you are using.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=47%><B>Error</B></TD>
<TD width=53%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_HANDLE</TD>
<TD width=53%>One of the parameters specifies an invalid handle. </TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_INVALID_PARAMETER</TD>
<TD width=53%>One of the parameters contains an invalid value. This is most often an illegal pointer.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>ERROR_NO_MORE_ITEMS</TD>
<TD width=53%>The end of the enumeration list has been reached. No valid data has been placed in the <I>pbData</I> buffer. This error is only returned when <I>dwParam</I> equals PP_ENUMALGS or PP_ENUMCONTAINERS.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_FLAGS</TD>
<TD width=53%>The <I>dwFlags</I> parameter is nonzero.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_TYPE</TD>
<TD width=53%>The <I>dwParam</I> parameter specifies an unknown parameter number.</TD>
</TR>

<TR VALIGN="top">
<TD width=47%>NTE_BAD_UID</TD>
<TD width=53%>The CSP context specified by <I>hProv</I> is invalid.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Example</B></P>

<P>This example shows how the list of algorithms supported by a particular CSP is accessed by an application.</P>

<P>HCRYPTPROV hProv;         // Handle to CSP</P>

<P>DWORD dwAlgCount;</P>

<P>BYTE *ptr = NULL;</P>

<P>DWORD i;</P>

<P>ALG_ID aiAlgid;</P>

<P>DWORD dwBits;</P>

<P>DWORD dwNameLen;</P>

<P>CHAR szName[100];         // Often allocated dynamically.</P>

<P>BYTE pbData[1000];        // Often allocated dynamically.</P>

<P>DWORD dwDataLen;</P>

<P>DWORD dwFlags;</P>

<P>CHAR *pszAlgType = NULL;</P>

<P></P>

<P>// Enumerate the supported algorithms.</P>

<P>for(i=0 ; ; i++) {</P>

<P>// Set the CRYPT_FIRST flag the first time through the loop.</P>

<P>if(i == 0) {</P>

<P>dwFlags = CRYPT_FIRST;</P>

<P>} else {</P>

<P>dwFlags = 0;</P>

<P>}</P>

<P>// Retrieve information about an algorithm.</P>

<P>dwDataLen = 1000;</P>

<P>if(!CryptGetProvParam(hProv, PP_ENUMALGS, pbData, &amp;dwDataLen, 0)) {</P>

<P>if(GetLastError() == ERROR_NO_MORE_ITEMS) {</P>

<P>// Exit the loop.</P>

<P>break;</P>

<P>} else {</P>

<P>printf("Error %x reading algorithm!\n", GetLastError());</P>

<P>return;</P>

<P>}</P>

<P>}</P>

<P></P>

<P>// Extract algorithm information from 'pbData' buffer.</P>

<P>ptr = pbData;</P>

<P>aiAlgid = *(ALG_ID *)ptr;</P>

<P>ptr += sizeof(ALG_ID);</P>

<P>dwBits = *(DWORD *)ptr;</P>

<P>ptr += sizeof(DWORD);</P>

<P>dwNameLen = *(DWORD *)ptr;</P>

<P>ptr += sizeof(DWORD);</P>

<P>strncpy(szName, ptr,dwNameLen);</P>

<P></P>

<P>// Determine algorithm type.</P>

<P>switch(GET_ALG_CLASS(aiAlgid)) {</P>

<P>case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";</P>

<P>break;</P>

<P>case ALG_CLASS_HASH:         pszAlgType = "Hash     ";</P>

<P>break;</P>

<P>case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";</P>

<P>break;</P>

<P>case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";</P>

<P>break;</P>

<P>default:                     pszAlgType = "Unknown  ";</P>

<P>}</P>

<P></P>

<P>// Print information about algorithm.</P>

<P>printf("Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",</P>

<P>aiAlgid, dwBits, pszAlgType, dwNameLen, szName</P>

<P>);</P>

<P>}</P>

<P></P>

<P><B>See Also</B></P>

<P><A HREF="b4q7j2.htm"><B>CryptAcquireContext</B></A>, <A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A>,<B> <A HREF="ioh0._.htm">CryptDeriveKey</A></B>, <A HREF="dnbayj.htm"><B>CryptGenKey</B></A>, <A HREF="bu8pdf.htm"><B>CryptGetKeyParam</B></A>, <A HREF="jpvjt7.htm"><B>CryptSetProvParam</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
