<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Adding Drop Target Capabilities</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="ae_pge"></A><B>Adding Drop Target Capabilities</B></P>

<P>To enable your application to become a drop target, follow these steps:</P>

<P>1.Initialize the OLE libraries. You should check the build version and call the <B>OleInitialize</B> function exactly as you would for a drop source.</P>

<P>2.Call the <B>RegisterDragDrop</B> function. OLE keeps a list of the windows that are drop targets. Every window that accepts dropped objects must register itself and its <B>IDropTarget</B> interface pointer. Then when the user drags the object over a drop target window, OLE has the <B>IDropTarget</B> interface pointer handy.</P>

<P>3.Implement the <B>IDropTarget</B> interface. OLE uses the <B>IDropTarget</B> interface pointer that you registered with <B>RegisterDragDrop</B> to keep you informed of the state of a drop operation.</P>

<P>When the cursor first enters a registered drop target window, OLE calls the <B>IDropTarget::DragEnter</B> member function. In this member function, you should ensure that your application can create the dragged object if it is dropped. Your application may also display visual feedback showing where the dropped object will appear, if appropriate.</P>

<P>When the cursor moves around inside a drop target window, OLE calls the <B>IDropTarget::DragOver</B> member function, just as Windows 95 sends WM_MOUSEMOVE messages. Here you should update any visual feedback that your application displays to reflect the current cursor position. When the cursor leaves a drop target window, OLE calls the <B>IDropTarget::DragLeave</B> member function. In your <B>DragLeave</B> member function, you should remove any feedback you displayed during <B>DragOver</B> or <B>DragEnter</B>.</P>

<P>OLE calls your <B>IDropTarget::Drop</B> member function when the user drops the object. To be precise, a drop occurs when the drop source returns the DRAGDROP_DROP value from the <B>IDropSource::QueryContinueDrag</B> member function. In your <B>Drop</B> member function, you should create an appropriate object from <B>IDataObject</B> that is passed as a parameter. The following example shows how to implement <B>IDropTarget::Drop</B>.</P>

<P>STDMETHODIMP CDropTarget::Drop (LPDATAOBJECT pDataObj, <BR>
    DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect)  </P>

<P>{ </P>

<P>FORMATETC fmtetc; </P>

<P>SCODE sc = S_OK; </P>

<P></P>

<P>UndrawDragFeedback(); // removes any visual feedback </P>

<P></P>

<P>// QueryDrop returns TRUE if the app. can accept a drop based on </P>

<P>// the current key state, requested action, and cursor position. </P>

<P>if (pDataObj &amp;&amp; QueryDrop(grfKeyState,pointl,FALSE,pdwEffect)) { </P>

<P>m_pDoc-&gt;m_lpSite = CSimpleSite::Create(m_pDoc); </P>

<P>m_pDoc-&gt;m_lpSite-&gt;m_dwDrawAspect = DVASPECT_CONTENT; </P>

<P></P>

<P>// Initialize the FORMATETC structure. </P>

<P>fmtetc.cfFormat = NULL; </P>

<P>fmtetc.ptd = NULL; </P>

<P>fmtetc.lindex = -1; </P>

<P>fmtetc.dwAspect = DVASPECT_CONTENT; // draws object's content </P>

<P>fmtetc.tymed = TYMED_NULL; </P>

<P>HRESULT hrErr = OleCreateFromData </P>

<P>(pDataObj,IID_IOleObject,OLERENDER_DRAW, </P>

<P>&amp;fmtetc, &amp;m_pDoc-&gt;m_lpSite-&gt;m_OleClientSite, </P>

<P>m_pDoc-&gt;m_lpSite-&gt;m_lpObjStorage, </P>

<P>(LPVOID FAR *)&amp;m_pDoc-&gt;m_lpSite-&gt;m_lpOleObject); </P>

<P>if (hrErr == NOERROR) </P>

<P>// The object was created successfully. </P>

<P>else </P>

<P>// The object creation failed. </P>

<P>sc = GetScode(hrErr); </P>

<P>} </P>

<P>return ResultFromScode(sc); </P>

<P>} </P>

<P></P>

<P>4.Call the <B>RevokeDragDrop</B> function. Before a drop target window is destroyed, it must call <B>RevokeDragDrop</B> to allow OLE to remove the window from its list of drop targets.</P>

<P>5.Uninitialize the OLE libraries. Like a drop source, your application needs to uninitialize the OLE libraries before terminating.</P>

</BODY>
</HTML>
