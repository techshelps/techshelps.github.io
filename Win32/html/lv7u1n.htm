<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Using the Virtual Memory Functions</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="lv7u1n"></A><B>Using the Virtual Memory Functions</B></P>

<P>This section explains how to use the virtual memory functions for dynamic allocation. </P>

<P>The following example illustrates the use of the <A HREF="1m7v8go.htm"><B>VirtualAlloc</B></A> and <A HREF="8dcrwp.htm"><B>VirtualFree</B></A> functions in reserving and committing memory as needed for a dynamic array. First, <B>VirtualAlloc</B> is called to reserve a block of pages with NULL specified as the base address parameter, forcing the kernel to determine the location of the block. Later, <B>VirtualAlloc</B> is called whenever it is necessary to commit a page from this reserved region, and the base address of the next page to be committed is specified. </P>

<P>The example uses <B>try</B>-<B>except</B> structured exception-handling syntax to commit pages from the reserved region. Whenever a page fault exception occurs during the execution of the <B>try</B> block, the filter function in the expression preceding the <B>except</B> block is executed. If the filter function can allocate another page, execution continues in the <B>try</B> block at the point where the exception occurred. Otherwise, the exception handler in the <B>except</B> block is executed. For more information about structured exception handling, see <A HREF="atyjkk.htm">Structured Exception Handling</A>. </P>

<P>As an alternative to dynamic allocation, the process can simply commit the entire region instead of only reserving it. However, committing the region consumes physical storage that might not be needed, making it unavailable for use by other processes. </P>

<P>The example uses <B>VirtualFree</B> to free the reserved and committed pages when it is finished with them. The function is called twice: first to decommit the committed pages and again to release the entire region of reserved pages. </P>

<P>#define PAGELIMIT 80  </P>

<P>#define PAGESIZE 0x1000 </P>

<P></P>

<P>INT PageFaultExceptionFilter(DWORD); </P>

<P>VOID MyErrorExit(LPTSTR); </P>

<P></P>

<P>LPTSTR lpNxtPage; </P>

<P>DWORD dwPages = 0; </P>

<P></P>

<P>VOID UseDynamicVirtualAlloc(VOID) { </P>

<P>LPVOID lpvBase; </P>

<P>LPTSTR lpPtr; </P>

<P>BOOL bSuccess; </P>

<P>DWORD i; </P>

<P></P>

<P>/* Reserve pages in the process's virtual address space. */ </P>

<P></P>

<P>lpvBase = VirtualAlloc( </P>

<P>NULL,               /* system selects address   */ </P>

<P>PAGELIMIT*PAGESIZE, /* size of allocation       */ </P>

<P>MEM_RESERVE,        /* allocates reserved pages */ </P>

<P>PAGE_NOACCESS);     /* protection = no access   */ </P>

<P>if (lpvBase == NULL ) </P>

<P>MyErrorExit("VirtualAlloc reserve"); </P>

<P></P>

<P>lpPtr = lpNxtPage = (LPTSTR) lpvBase; </P>

<P></P>

<P>/* </P>

<P>* Use try-except structured exception handling when </P>

<P>* accessing the pages. If a page fault occurs, the </P>

<P>* exception filter is executed to commit another page </P>

<P>* from the reserved block of pages. </P>

<P>*/ </P>

<P></P>

<P>for (i=0; i &lt; PAGELIMIT*PAGESIZE; i++) { </P>

<P></P>

<P>try { </P>

<P></P>

<P>/* Write to memory. */ </P>

<P></P>

<P>lpPtr[i] = 'a'; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* If there is a page fault, commit another page </P>

<P>* and try again. </P>

<P>*/ </P>

<P></P>

<P>except ( PageFaultExceptionFilter( </P>

<P>GetExceptionCode() ) ) { </P>

<P></P>

<P>/* </P>

<P>* This is executed only if the filter function is </P>

<P>* unsuccessful in committing the next page. </P>

<P>*/ </P>

<P></P>

<P>ExitProcess( GetLastError() ); </P>

<P></P>

<P>} </P>

<P></P>

<P>} </P>

<P></P>

<P>/* Release the block of pages when you are finished using them. */ </P>

<P></P>

<P>/* First, decommit the committed pages. */ </P>

<P></P>

<P>bSuccess = VirtualFree( </P>

<P>lpvBase,          /* base address of block    */ </P>

<P>dwPages*PAGESIZE, /* bytes of committed pages */ </P>

<P>MEM_DECOMMIT);    /* decommit the pages       */ </P>

<P></P>

<P>/* Release the entire block. */ </P>

<P></P>

<P>if (bSuccess) </P>

<P>bSuccess = VirtualFree( </P>

<P>lpvBase,        /* base address of block     */ </P>

<P>0,              /* releases the entire block */ </P>

<P>MEM_RELEASE);   /* releases the pages        */ </P>

<P></P>

<P>} </P>

<P></P>

<P>INT PageFaultExceptionFilter(DWORD dwCode) { </P>

<P>LPVOID lpvResult; </P>

<P></P>

<P>/* If the exception is not a page fault, exit. */ </P>

<P></P>

<P>if (dwCode != EXCEPTION_ACCESS_VIOLATION) { </P>

<P>printf("exception code = %d\n", dwCode); </P>

<P>return EXCEPTION_EXECUTE_HANDLER; </P>

<P>} </P>

<P></P>

<P>printf("page fault\n"); </P>

<P></P>

<P>/* If the reserved pages are used up, exit. */ </P>

<P></P>

<P>if (dwPages &gt;= PAGELIMIT) { </P>

<P>printf("out of pages\n"); </P>

<P>return EXCEPTION_EXECUTE_HANDLER; </P>

<P>} </P>

<P></P>

<P>/* Otherwise, commit another page. */ </P>

<P></P>

<P>lpvResult = VirtualAlloc( </P>

<P>(LPVOID) lpNxtPage, /* next page to commit  */ </P>

<P>PAGESIZE,           /* page size, in bytes  */ </P>

<P>MEM_COMMIT,         /* alloc committed page */ </P>

<P>PAGE_READWRITE);    /* read-write access    */ </P>

<P>if (lpvResult == NULL ) { </P>

<P>printf("VirtualAlloc failed\n"); </P>

<P>return EXCEPTION_EXECUTE_HANDLER; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Increment the page count, and advance lpNxtPage </P>

<P>* to the next page. </P>

<P>*/ </P>

<P></P>

<P>dwPages++; </P>

<P>lpNxtPage += PAGESIZE; </P>

<P></P>

<P>/* Continue execution where the page fault occurred. */ </P>

<P></P>

<P>return EXCEPTION_CONTINUE_EXECUTION; </P>

<P></P>

<P>} </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
