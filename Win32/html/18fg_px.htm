<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Defining the Clipping Region</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="18fg_px"></A><B>Defining the Clipping Region</B></P>

<P>When the user selects the Define Clip Region option, Windows issues a <A HREF="71v.3j.htm">WM_COMMAND</A> message. The <I>wParam</I> parameter of this message contains an application-defined constant, IDM_DEFINE, that indicates that the user selected this option from the menu. The application processes this input by setting a Boolean flag, fDefineRegion, as shown in the following code sample. </P>

<P>case WM_COMMAND:  </P>

<P>switch (wParam) { </P>

<P></P>

<P>case IDM_DEFINE: </P>

<P>fDefineRegion = TRUE; </P>

<P>break; </P>

<P></P>

<P>After selecting the Define Clipping Region option, the user can begin drawing the rectangle by clicking and dragging the mouse while the cursor is in the application's client area. </P>

<P>When the user presses the left button, Windows issues a <A HREF="065j6u.htm">WM_LBUTTONDOWN</A> message. The <I>lParam</I> parameter of this message contains the cursor coordinates, which correspond to the upper left corner of a rectangle used to define the clipping region. The application processes the WM_LBUTTONDOWN message, as follows. </P>

<P>/* These variables are required for clipping. */  </P>

<P></P>

<P>static POINT ptUpperLeft; </P>

<P>static POINT ptLowerRight; </P>

<P>static POINT aptRect[5]; </P>

<P>static POINT ptTmp; </P>

<P>static POINTS ptsTmp; </P>

<P>static BOOL fDefineRegion; </P>

<P>static BOOL fRegionExists; </P>

<P>static HRGN hrgn; </P>

<P>static RECT rctTmp; </P>

<P>int i; </P>

<P></P>

<P>switch (message) { </P>

<P></P>

<P>case WM_LBUTTONDOWN: </P>

<P>if (fDefineRegion) { </P>

<P></P>

<P>/* Retrieve the new upper left corner. */ </P>

<P></P>

<P>ptsTmp = MAKEPOINTS(lParam); </P>

<P>ptUpperLeft.x = (LONG) ptsTmp.x; </P>

<P>ptUpperLeft.y = (LONG) ptsTmp.y; </P>

<P>} </P>

<P></P>

<P>if (fRegionExists) { </P>

<P></P>

<P>/* Erase the previous rectangle. */ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P>SetROP2(hdc, R2_NOTXORPEN); </P>

<P></P>

<P>if (!Polyline(hdc, (CONST POINT *) aptRect, 5)) </P>

<P>errhandler("Polyline Failed", hwnd); </P>

<P>ReleaseDC(hwnd, hdc); </P>

<P></P>

<P>/* Clear the rectangle coordinates. */ </P>

<P></P>

<P>for (i = 0; i &lt; 4; i++) { </P>

<P>aptRect[i].x = 0; </P>

<P>aptRect[i].y = 0; </P>

<P>} </P>

<P></P>

<P>/* Clear the temporary point structure. */ </P>

<P></P>

<P>ptTmp.x = 0; </P>

<P>ptTmp.y = 0; </P>

<P></P>

<P>/* Clear the lower right coordinates. */ </P>

<P></P>

<P>ptLowerRight.x = 0; </P>

<P>ptLowerRight.y = 0; </P>

<P></P>

<P>/* Reset the flag. */ </P>

<P></P>

<P>fRegionExists = FALSE; </P>

<P>fDefineRegion = TRUE; </P>

<P></P>

<P>/* Retrieve the new upper left corner. */ </P>

<P></P>

<P>ptsTmp = MAKEPOINTS(lParam); </P>

<P>ptUpperLeft.x = (LONG) ptsTmp.x; </P>

<P>ptUpperLeft.y = (LONG) ptsTmp.y; </P>

<P>} </P>

<P>break; </P>

<P></P>

<P>As the user drags the mouse, Windows issues <A HREF="1mq_iq2.htm">WM_MOUSEMOVE</A> messages and stores the new cursor coordinates in the <I>lParam</I> parameter. Each time the application receives a new WM_MOUSEMOVE message, it erases the previous rectangle (if one exists) and draws the new rectangle by calling the <A HREF="62r.i2.htm"><B>Polyline</B></A> function, passing it the coordinates of the four corners of the rectangle. The application performs the following tasks. </P>

<P>/* These variables are required for clipping. */  </P>

<P></P>

<P>static POINT ptUpperLeft; </P>

<P>static POINT ptLowerRight; </P>

<P>static POINT aptRect[5]; </P>

<P>static POINT ptTmp; </P>

<P>static POINTS ptsTmp; </P>

<P>static BOOL fDefineRegion; </P>

<P>static BOOL fRegionExists; </P>

<P>static HRGN hrgn; </P>

<P>static RECT rctTmp; </P>

<P>int i; </P>

<P></P>

<P>switch (message) { </P>

<P></P>

<P>case WM_MOUSEMOVE: </P>

<P></P>

<P>if (wParam &amp; MK_LBUTTON &amp;&amp; fDefineRegion) { </P>

<P></P>

<P>/* Get a window DC. */ </P>

<P></P>

<P>hdc = GetDC(hwnd); </P>

<P></P>

<P>if (!SetROP2(hdc, R2_NOTXORPEN)) </P>

<P>errhandler("SetROP2 Failed", hwnd); </P>

<P></P>

<P></P>

<P>/* </P>

<P>* If previous mouse movement occurred, store the original </P>

<P>* lower right corner coordinates in a temporary structure. </P>

<P>*/ </P>

<P></P>

<P>if (ptLowerRight.x) { </P>

<P>ptTmp.x = ptLowerRight.x; </P>

<P>ptTmp.y = ptLowerRight.y; </P>

<P>} </P>

<P></P>

<P>/* </P>

<P>* Get the new coordinates of the clipping region's lower </P>

<P>* right corner. </P>

<P>*/ </P>

<P></P>

<P>ptsTmp = MAKEPOINTS(lParam); </P>

<P>ptLowerRight.x = (LONG) ptsTmp.x; </P>

<P>ptLowerRight.y = (LONG) ptsTmp.y; </P>

<P></P>

<P></P>

<P>/* </P>

<P>* If previous mouse movement occurred, erase the original </P>

<P>* rectangle. </P>

<P>*/ </P>

<P></P>

<P>if (ptTmp.x) { </P>

<P>aptRect[0].x = ptUpperLeft.x; </P>

<P>aptRect[0].y = ptUpperLeft.y; </P>

<P>aptRect[1].x = ptTmp.x; </P>

<P>aptRect[1].y = ptUpperLeft.y; </P>

<P>aptRect[2].x = ptTmp.x; </P>

<P>aptRect[2].y = ptTmp.y; </P>

<P>aptRect[3].x = ptUpperLeft.x; </P>

<P>aptRect[3].y = ptTmp.y; </P>

<P>aptRect[4].x = aptRect[0].x; </P>

<P>aptRect[4].y = aptRect[0].y; </P>

<P></P>

<P>if (!Polyline(hdc, (CONST POINT *) aptRect, 5)) </P>

<P>errhandler("Polyline Failed", hwnd); </P>

<P>} </P>

<P></P>

<P>aptRect[0].x = ptUpperLeft.x; </P>

<P>aptRect[0].y = ptUpperLeft.y; </P>

<P>aptRect[1].x = ptLowerRight.x; </P>

<P>aptRect[1].y = ptUpperLeft.y; </P>

<P>aptRect[2].x = ptLowerRight.x; </P>

<P>aptRect[2].y = ptLowerRight.y; </P>

<P>aptRect[3].x = ptUpperLeft.x; </P>

<P>aptRect[3].y = ptLowerRight.y; </P>

<P>aptRect[4].x = aptRect[0].x; </P>

<P>aptRect[4].y = aptRect[0].y; </P>

<P></P>

<P>if (!Polyline(hdc, (CONST POINT *) aptRect, 5)) </P>

<P>errhandler("Polyline Failed", hwnd); </P>

<P></P>

<P>ReleaseDC(hwnd, hdc); </P>

<P>} </P>

<P>break; </P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
