<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>CryptEncrypt [New - Windows NT] [New - Windows 95, OEM Service Release 2]</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="1wqjmsg"></A><B>CryptEncrypt  <A HREF="1lrrrs6.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="ovgpq4.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="aeymi7.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>[New - Windows NT]</P>

<P>[New - Windows 95, OEM Service Release 2]</P>

<P>The <B>CryptEncrypt</B> function is used to encrypt data. The algorithm used to encrypt the data is designated by the key held by the CSP module, which is referenced by the <I>hKey</I> parameter.</P>

<P><B>BOOL CRYPTFUNC CryptEncrypt(</B></P>

<TABLE cols=2 width=223>

<TR VALIGN="top">
<TD width=85%><B>HCRYPTKEY </B><I>hKey</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    HCRYPTHASH </B><I>hHash</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    BOOL </B><I>Final</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwFlags</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    BYTE *</B><I>pbData</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD *</B><I>pdwDataLen</I><B>,</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>    DWORD </B><I>dwBufLen</I></TD>
<TD width=15%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=85%><B>   );</B></TD>
<TD width=15%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters </B></P>

<P><I>hKey</I></P>

<P>[in] A handle to the key to use for the encryption. An application obtains this handle by using either the <A HREF="dnbayj.htm"><B>CryptGenKey</B></A> or the <A HREF="8mc1bn.htm"><B>CryptImportKey</B></A> function.</P>

<P>This key specifies the encryption algorithm that is used.</P>

<P><I>hHash</I></P>

<P>[in] A handle to a hash object. This parameter is used only if a hash of the data is to be computed at the same time the encryption is being performed. See the "Remarks" section for more information.</P>

<P>If no hash is to be done, this parameter must be zero.</P>

<P><I>Final</I></P>

<P>[in] The Boolean value that specifies whether this is the last section in a series being encrypted. This should be TRUE if this is the last or only block, and FALSE if it is not. See the "Remarks" section for more information.</P>

<P><I>dwFlags</I></P>

<P>[in] The flag values. This parameter is reserved for future use and should always be zero.</P>

<P><I>pbData</I></P>

<P>[in/out] The buffer holding the data to be encrypted. Once the encryption has been performed, the encrypted data is placed back in this same buffer.</P>

<P>The size of this buffer is specified by <I>dwBufLen</I>. The number of bytes of data to be encrypted is specified by <I>pdwDataLen</I>.</P>

<P>This parameter can be NULL if all you are doing is determining the number of bytes required for the returned data.</P>

<P><I>pdwDataLen</I></P>

<P>[in/out] The address of the data length. Before calling this function, the caller should set this parameter to the number of bytes to be encrypted. Upon return, this address will contain the number of bytes of encrypted data.</P>

<P>If the buffer specified by <I>pbData</I> is not large enough to hold the data, the function returns the ERROR_MORE_DATA error code (through <A HREF="11c2vs7.htm"><B>GetLastError</B></A>) and stores the required buffer size, in bytes, into the variable pointed to by <I>pdwDataLen</I>.</P>

<P>If <I>pbData</I> is NULL, then no error is returned, and the function stores the size of the data, in bytes, in the variable pointed to be <I>pdwDataLen</I>. This lets an application determine the correct buffer size unambiguously.</P>

<P>When a block cipher is used, this data length must be a multiple of the block size, unless this is the final section of data to be encrypted and the <I>Final</I> flag is TRUE.</P>

<P><I>dwBufLen</I></P>

<P>[in] The number of bytes in the <I>pbData</I> buffer.</P>

<P>Note that, depending on the algorithm used, the encrypted text can be slightly larger than the original plaintext. In this case, the <I>pbData</I> buffer needs to be sized accordingly.</P>

<P>As a rule, if a stream cipher is used the ciphertext will be the same size as the plaintext. If a block cipher is used, the ciphertext will be up to a "block length" larger than the plaintext.</P>

<P></P>

<P><B>Remarks</B></P>

<P>If data is to be hashed and encrypted simultaneously, a handle to a hash object can be passed in the <I>hHash</I> parameter. The hash value will be updated with the plaintext passed in. This option is useful when generating signed and encrypted text.</P>

<P>Prior to calling <B>CryptEncrypt</B>, the application should obtain a handle to the hash object by calling the <A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A> function. Once the encryption is complete, the hash value can be obtained through the <A HREF="51c6k9e.htm"><B>CryptGetHashParam</B></A> function or the hash can be signed using the <A HREF="bod3zd.htm"><B>CryptSignHash</B></A> function.</P>

<P>When a large amount of data needs to be encrypted, it can be done in sections. This is done by calling <B>CryptEncrypt</B> repeatedly. The <I>Final</I> parameter should be set to TRUE only on the last invocation of <B>CryptEncrypt</B>, so the encryption engine can properly finish the encryption process. The following extra actions are performed when <I>Final</I> is TRUE:</P>

<P>·If the key is a block cipher key, the data will be padded to a multiple of the block size of the cipher. To find the block size of a cipher, use <B>CryptGetKeyParam</B> to get the KP_BLOCKLEN parameter of the key.</P>

<P>·If the cipher is operating in a chaining mode, the next <B>CryptEncrypt</B> operation will reset the cipher's feedback register to the KP_IV value of the key.</P>

<P>·If the cipher is a stream cipher, the next <B>CryptEncrypt</B> will reset the cipher to its initial state.</P>

<P></P>

<P><B>Return Values</B></P>

<P>If the function succeeds, the return value is nonzero.</P>

<P>If the function fails, the return value is zero. To retrieve extended error information, use the <A HREF="11c2vs7.htm"><B>GetLastError</B></A> function.</P>

<P>The following table lists the error codes most commonly returned by the <B>GetLastError</B> function. The error codes prefaced by "NTE" are generated by the particular CSP you are using.</P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=43%><B>Error</B></TD>
<TD width=57%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=43%>ERROR_INVALID_HANDLE</TD>
<TD width=57%>One of the parameters specifies an invalid handle. </TD>
</TR>

<TR VALIGN="top">
<TD width=43%>ERROR_INVALID_PARAMETER</TD>
<TD width=57%>One of the parameters contains an invalid value. This is most often an illegal pointer.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_ALGID</TD>
<TD width=57%>The <I>hKey</I> session key specifies an algorithm that this CSP does not support.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_DATA</TD>
<TD width=57%>The data to be encrypted is invalid. For example, when a block cipher is used and the <I>Final</I> flag is FALSE, the value specified by <I>pdwDataLen</I> must be a multiple of the block size.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_FLAGS</TD>
<TD width=57%>The <I>dwFlags</I> parameter is nonzero.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_HASH</TD>
<TD width=57%>The <I>hHash</I> parameter contains an invalid handle.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_KEY</TD>
<TD width=57%>The <I>hKey</I> parameter does not contain a valid handle to a key.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_LEN</TD>
<TD width=57%>The size of the output buffer is too small to hold the generated ciphertext.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_BAD_UID</TD>
<TD width=57%>The CSP context that was specified when the key was created cannot be found.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_DOUBLE_ENCRYPT</TD>
<TD width=57%>The application attempted to encrypt the same data twice.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_FAIL</TD>
<TD width=57%>The function failed in some unexpected way.</TD>
</TR>

<TR VALIGN="top">
<TD width=43%>NTE_NO_MEMORY</TD>
<TD width=57%>The CSP ran out of memory during the operation.</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Example</B></P>

<P>See "Encryption Example" in the section <A HREF="ovgpq4.htm">Encrypting and Decrypting Data</A>.</P>

<P><B>See Also</B></P>

<P><A HREF="4hq3.7.htm"><B>CryptCreateHash</B></A>, <A HREF="nqjmsg.htm"><B>CryptDecrypt</B></A>, <A HREF="dnbayj.htm"><B>CryptGenKey</B></A>, <A HREF="51c6k9e.htm"><B>CryptGetHashParam</B></A>, <A HREF="8mc1bn.htm"><B>CryptImportKey</B></A>, <A HREF="bod3zd.htm"><B>CryptSignHash</B></A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
