<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Data Management</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="esl8nk"></A><B>Data Management</B></P>

<P>Because DDE uses memory objects to pass data from one application to another, the DDEML provides a set of functions that DDE applications can use to create and manage DDE objects. </P>

<P>All transactions that involve the exchange of data require the application supplying the data to create a local buffer containing the data and then to call the <A HREF="hlu46s.htm"><B>DdeCreateDataHandle</B></A> function. This function allocates a DDE object, copies the data from the buffer to the object, and returns a data handle. A data handle is a doubleword value that the DDEML uses to provide access to data in the DDE object. To share the data in a DDE object, an application passes the data handle to the DDEML, and the DDEML passes the handle to the DDE callback function of the application that is receiving the data transaction. </P>

<P>The following example shows how to create a DDE object and obtain a handle of the object. During the <A HREF="15b.tlh.htm">XTYP_ADVREQ</A> transaction, the callback function converts the current time to an ASCII string, copies the string to a local buffer, and then creates a DDE object that contains the string. The callback function returns the handle of the DDE object (HDDEDATA) to the DDEML, which passes the handle to the client application. </P>

<P>typedef struct tagTIME  </P>

<P>{  </P>

<P>INT     hour;   /* 0 - 11 hours for analog clock */ </P>

<P>INT     hour12; /* 12-hour format */ </P>

<P>INT     hour24; /* 24-hour format */ </P>

<P>INT     minute; </P>

<P>INT     second; </P>

<P>INT     ampm;   /* 0 - AM , 1 - PM */ </P>

<P>} TIME; </P>

<P></P>

<P>HDDEDATA EXPENTRY DdeCallback(uType, uFmt, hconv, hsz1, hsz2, </P>

<P>hdata, dwData1, dwData2) </P>

<P>UINT uType; </P>

<P>UINT uFmt; </P>

<P>HCONV hconv; </P>

<P>HSZ hsz1; </P>

<P>HSZ hsz2; </P>

<P>HDDEDATA hdata; </P>

<P>DWORD dwData1; </P>

<P>DWORD dwData2; </P>

<P>{ </P>

<P></P>

<P>CHAR szBuf[32]; </P>

<P></P>

<P>switch (uType) { </P>

<P></P>

<P>case XTYP_ADVREQ: </P>

<P>if ((hsz1 == hszTime &amp;&amp; hsz2 == hszNow) &amp;&amp; </P>

<P>(uFmt == CF_TEXT)) { </P>

<P></P>

<P>/* Copy the formatted string to a buffer. */ </P>

<P></P>

<P>itoa(tmTime.hour, szBuf, 10); </P>

<P>lstrcat(szBuf, ":"); </P>

<P>if (tmTime.minute &lt; 10) </P>

<P>lstrcat(szBuf, "0"); </P>

<P>itoa(tmTime.minute, &amp;szBuf[lstrlen(szBuf)], 10); </P>

<P>lstrcat(szBuf, ":"); </P>

<P>if (tmTime.second &lt; 10) </P>

<P>strcat(szBuf, "0"); </P>

<P>itoa(tmTime.second, &amp;szBuf[lstrlen(szBuf)], 10); </P>

<P>szBuf[lstrlen(szBuf)] = '\0'; </P>

<P></P>

<P>/* Create a global object and return its data handle. */ </P>

<P></P>

<P>return (DdeCreateDataHandle( </P>

<P>idInst, </P>

<P>(LPBYTE) szBuf,     /* instance identifier   */ </P>

<P>lstrlen(szBuf) + 1, /* source buffer length  */ </P>

<P>0,                  /* offset from beginning */ </P>

<P>hszNow,             /* item name string      */ </P>

<P>CF_TEXT,            /* clipboard format      */ </P>

<P>0));                /* no creation flags     */ </P>

<P>} else </P>

<P>return (HDDEDATA) NULL; </P>

<P></P>

<P>. </P>

<P>. /* Process other transactions. */ </P>

<P>. </P>

<P></P>

<P>} </P>

<P></P>

<P>} </P>

<P></P>

<P>The receiving application obtains a pointer to the DDE object by passing the data handle to the <A HREF="e421.j.htm"><B>DdeAccessData</B></A> function. The pointer returned by <B>DdeAccessData</B> provides read-only access. The application should use the pointer to review the data and then call the <A HREF="zegaia.htm"><B>DdeUnaccessData</B></A> function to invalidate the pointer. The application can copy the data to a local buffer by using the <A HREF="323wqdx.htm"><B>DdeGetData</B></A> function. </P>

<P>The following example obtains a pointer to the DDE object identified by the <I>hData</I> parameter, copies the contents to a local buffer, and then invalidates the pointer. </P>

<P>HDDEDATA hdata;  </P>

<P>LPBYTE lpszAdviseData;  </P>

<P>DWORD cbDataLen; </P>

<P>DWORD i; </P>

<P>char szData[32]; </P>

<P></P>

<P>. </P>

<P>. </P>

<P>. </P>

<P>case XTYP_ADVDATA: </P>

<P>lpszAdviseData = DdeAccessData(hdata, &amp;cbDataLen); </P>

<P>for (i = 0; i &lt; cbDataLen; i++) </P>

<P>szData[i] = *lpszAdviseData++; </P>

<P>DdeUnaccessData(hdata); </P>

<P>return (HDDEDATA) TRUE; </P>

<P>. </P>

<P>. </P>

<P>. </P>

<P></P>

<P>Usually, when an application that created a data handle passes that handle to the DDEML, the handle becomes invalid in the creating application. This situation is not a problem if the application must share data with only a single application. If an application must share the same data with multiple applications, however, the creating application should specify the HDATA_APPOWNED flag in <A HREF="hlu46s.htm"><B>DdeCreateDataHandle</B></A>. Doing so gives ownership of the DDE object to the creating application and prevents the DDEML from invalidating the data handle. The application can then pass the data handle any number of times after calling <B>DdeCreateDataHandle</B> only once. </P>

<P>If an application specifies the HDATA_APPOWNED flag in the <I>afCmd</I> parameter of <B>DdeCreateDataHandle</B>, it must call the <A HREF="16wlv6r.htm"><B>DdeFreeDataHandle</B></A> function to free the memory handle, regardless of whether it passed the handle to the DDEML. Before it terminates, an application must call <B>DdeFreeDataHandle</B> to free any data handle that it created but did not pass to the DDEML. </P>

<P>An application that has not yet passed the handle of a DDE object to the DDEML can add data to the object or overwrite data in the object by using the <A HREF="ar_o8r.htm"><B>DdeAddData</B></A> function. Typically, an application uses <B>DdeAddData</B> to fill an uninitialized DDE object. After an application passes a data handle to the DDEML, the DDE object identified by the handle cannot be changed; it can only be freed. </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
