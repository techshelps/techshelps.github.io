<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Receiver Code Example</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="h3c0nu"></A><B>Receiver Code Example</B></P>

<P>This section illustrates the code needed on the destination user side to implement the three-phase key exchange protocol. The details of the communication between sending user and the destination user are not shown, because these will be different for each implementation.</P>

<P>#include &lt;wincrypt.h&gt;</P>

<P></P>

<P>HCRYPTPROV hProv = 0;</P>

<P>#define NAME_SIZE 256</P>

<P>BYTE pbDestName[NAME_SIZE];</P>

<P>DWORD dwDestNameLen;</P>

<P>BYTE pbSendName[NAME_SIZE];</P>

<P>DWORD dwSendNameLen;</P>

<P>HCRYPTKEY hSendPubKey = 0;</P>

<P>HCRYPTKEY hKeyA = 0;</P>

<P>HCRYPTKEY hKeyB = 0;</P>

<P>#define BLOB_SIZE 256</P>

<P>BYTE pbKeyBlob[BLOB_SIZE];</P>

<P>DWORD dwBlobLen;</P>

<P>#define HASH_SIZE 256</P>

<P>BYTE pbHash[HASH_SIZE];</P>

<P>DWORD dwHashLen;</P>

<P>BYTE pbSendHash[HASH_SIZE];</P>

<P>DWORD dwSendHashLen;</P>

<P>HCRYPTHASH hHash = 0;</P>

<P>// Get handle to the default provider.</P>

<P>CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0);</P>

<P>// Obtain the sending user's exchange public key. Import it into the</P>

<P>// CSP and place a handle to it in 'hSendPubKey'.</P>

<P>...</P>

<P>// Obtain the sending user's name. This is usually done at the </P>

<P>// same time the public key was obtained. Place this in </P>

<P>// 'pbSendName' and set 'dwSendNameLen' to the number of bytes in </P>

<P>// the name.</P>

<P>...</P>

<P>// Place the destination user's name in 'pbDestName' and set</P>

<P>// 'dwDestNameLen' to the number of bytes in the name.</P>

<P>...</P>

<P>// Receive a key blob containing session key A from the sending user</P>

<P>// and place it in 'pbKeyBlob'. Set 'dwBlobLen' to the number of </P>

<P>// bytes in the key blob.</P>

<P>...</P>

<P>// Import the key blob into the CSP.</P>

<P>CryptImportKey(hProv, pbKeyBlob, dwBlobLen, 0, 0, &amp;hKeyA);</P>

<P>// Create a random session key (session key B). Because this key is</P>

<P>// going to be used solely for key exchange and not encryption, it </P>

<P>// does not matter which algorithm you specify here.</P>

<P>CryptGenKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &amp;hKeyB);</P>

<P>// Export session key B into a simple key blob.</P>

<P>dwBlobLen = BLOB_SIZE;</P>

<P>CryptExportKey(hKeyB, hSendPubKey, SIMPLEBLOB, 0, pbKeyBlob, &amp;dwBlobLen);</P>

<P>// Transmit key blob containing session key B to the sending user.</P>

<P>...</P>

<P>//</P>

<P>// Compute hash value and transmit it to the sending user.</P>

<P>//</P>

<P>// Create hash object.</P>

<P>CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash);</P>

<P>// Add session key A to hash.</P>

<P>CryptHashSessionKey(hHash, hKeyA, 0);</P>

<P>// Add destination user's name to hash.</P>

<P>CryptHashData(hHash, pbDestName, dwDestNameLen, 0);</P>

<P>// Add session key B to hash.</P>

<P>CryptHashSessionKey(hHash, hKeyB, 0);</P>

<P>// Add sending user name to hash.</P>

<P>CryptHashData(hHash, pbSendName, dwSendNameLen, 0);</P>

<P>// Add "phase 2" text to hash.</P>

<P>CryptHashData(hHash, "phase 2", 7, 0);</P>

<P>// Complete the hash computation and retrieve the hash value.</P>

<P>dwHashLen = HASH_SIZE;</P>

<P>CryptGetHashParam(hHash, HP_HASHVALUE, pbHash, &amp;dwHashLen, 0);</P>

<P>// Destroy the hash object.</P>

<P>CryptDestroyHash(hHash);</P>

<P>// Transmit the hash value to the sending user.</P>

<P>...</P>

<P>// Wait for the sending user to respond.</P>

<P>...</P>

<P>// Receive a hash value from the sending user and place it in</P>

<P>// 'pbSendHashValue'. Set 'dwSendHashLen' to the number of bytes in</P>

<P>// the hash value.</P>

<P>...</P>

<P>//</P>

<P>// Verify hash value received from the sending user.</P>

<P>//</P>

<P>// Create hash object.</P>

<P>CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash);</P>

<P>// Add session key B to hash.</P>

<P>CryptHashSessionKey(hHash, hKeyB, 0);</P>

<P>// Add sending user's name to hash.</P>

<P>CryptHashData(hHash, pbSendName, dwSendNameLen, 0);</P>

<P>// Add destination user's name to hash.</P>

<P>CryptHashData(hHash, pbDestName, dwDestNameLen, 0);</P>

<P>// Add "phase 3" text to hash.</P>

<P>CryptHashData(hHash, "phase 3", 7, 0);</P>

<P>// Complete the hash computation and retrieve the hash value.</P>

<P>dwHashLen = HASH_SIZE;</P>

<P>CryptGetHashParam(hHash, HP_HASHVALUE, pbHash, &amp;dwHashLen, 0);</P>

<P>// Destroy the hash object.</P>

<P>CryptDestroyHash(hHash));</P>

<P>//</P>

<P>// Compare the hash value received from the sending user with the</P>

<P>// hash value that we just computed. If they do not match, then </P>

<P>// terminate the protocol.</P>

<P>//</P>

<P>if(dwHashLen!=dwSendHashLen || memcmp(pbHash, pbSendHash, dwHashLen)) {</P>

<P>printf("Key exchange protocol failed in phase 3!\n");</P>

<P>printf("Aborting protocol!\n");</P>

<P>return;</P>

<P>}</P>

<P>//</P>

<P>// Use session key B to encrypt messages sent to the sender.</P>

<P>// Use session key A to decrypt messages received from the sender.</P>

<P>//</P>

<P>...</P>

<P>// Destroy session keys.</P>

<P>CryptDestroyKey(hKeyA);</P>

<P>CryptDestroyKey(hKeyB);</P>

<P>// Destroy handle to sending user's public key.</P>

<P>CryptDestroyKey(hSharedKey);</P>

<P>// Release provider handle.</P>

<P>CryptReleaseContext(hProv, 0);</P>

<P></P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
