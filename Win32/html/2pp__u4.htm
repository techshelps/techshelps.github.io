<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Debugging Functions</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="2pp__u4"></A><B>Debugging Functions</B></P>

<P>Although most of the Windows debugging functions are used to create a debugger, several functions are designed for use in the process being debugged. </P>

<P>To start a process and debug it, a debugger must use <A HREF="5fbj_xx.htm"><B>CreateProcess</B></A>, as described in the previous section. </P>

<P>To debug a process that is already executing, the debugger should use <A HREF="hfkv1a.htm"><B>DebugActiveProcess</B></A> with the process identifier retrieved by <A HREF="9mlgut.htm"><B>OpenProcess</B></A>. <B>DebugActiveProcess</B> attaches the debugger to the active process. In this case, only the active process can be debugged; its child processes cannot. The debugger must have appropriate access to the executing process to use <B>DebugActiveProcess</B>. For more information about access rights, see <A HREF="1966ja.htm">Security</A>. </P>

<P>After the debugger has either created or attached itself to the process it intends to debug, the kernel notifies the debugger of all debugging events that occur in the process, and, if specified, in any child processes. For more information about debugging events, see <A HREF="12lnrzz.htm">Debugging Events</A>. </P>

<P>The debugger uses the <A HREF="2bhs1hv.htm"><B>WaitForDebugEvent</B></A> function at the beginning of its main loop. This function blocks the debugger until a debugging event occurs. When the debugging event occurs, the system suspends all threads in the process being debugged and notifies the debugger of the event. The debugger can call the <A HREF="x_awl_.htm"><B>SetDebugErrorLevel</B></A> function to set the minimum error level at which Windows will pass the debugging event to it. </P>

<P>The debugger can interact with the user, or manipulate the state of the process being debugged, by using the <A HREF="h1g8jb.htm"><B>GetThreadContext</B></A>, <A HREF="1lj7t0p.htm"><B>GetThreadSelectorEntry</B></A>, <A HREF="2rlm_kf.htm"><B>ReadProcessMemory</B></A>, <A HREF="0wtukc.htm"><B>SetThreadContext</B></A>, and <A HREF="_4c4hp.htm"><B>WriteProcessMemory</B></A> functions. <B>GetThreadSelectorEntry</B> returns the descriptor table entry for a specified selector and thread. Debuggers use the descriptor table entry to convert a segment-relative address to a linear virtual address. The <B>ReadProcessMemory</B> and <B>WriteProcessMemory</B> functions require linear virtual addresses. </P>

<P>Debuggers frequently read the memory of the process being debugged and write the memory that contains instructions to the instruction cache. After the instructions are written, the debugger calls <B>FlushInstructionCache</B> to execute the cached instructions. </P>

<P>The debugger uses the <A HREF="1ims3jn.htm"><B>ContinueDebugEvent</B></A> function at the end of its main loop. This function allows the process being debugged to continue executing. </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
