<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>JournalPlaybackProc</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFC8" TEXT="#341717">



<P><A NAME="lesnkt"></A><B>JournalPlaybackProc  <A HREF="iz66_5.htm"><IMG SRC="../images/bm1.gif" ALT="" BORDER=0></A>  <A HREF="qpp.yo.htm"><IMG SRC="../images/bm3.gif" ALT="" BORDER=0></A>  <A HREF="rnpdgc.htm"><IMG SRC="../images/bm2.gif" ALT="" BORDER=0></A></B></P>

<P>The <B>JournalPlaybackProc</B> hook procedure is a callback function that inserts mouse and keyboard messages into the system message queue. Typically, an application uses this hook procedure to play back a series of mouse and keyboard messages recorded previously by the <A HREF="32huo95.htm"><B>JournalRecordProc</B></A> hook procedure. As long as a <B>JournalPlaybackProc</B> hook procedure is installed, regular mouse and keyboard input is disabled. </P>

<P><B>LRESULT CALLBACK JournalPlaybackProc(</B></P>

<TABLE cols=2 width=430>

<TR VALIGN="top">
<TD width=38%><B>int</B> <I>code</I><B>,</B></TD>
<TD width=62%>// hook code</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    WPARAM</B> <I>wParam</I><B>,</B></TD>
<TD width=62%>// undefined</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>    LPARAM</B> <I>lParam</I> </TD>
<TD width=62%>// address of message being processed</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>   );</B></TD>
<TD width=62%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P></P>

<P><B>Parameters</B></P>

<P><I>code</I></P>

<P>Specifies a code the hook procedure uses to determine how to process the message. This parameter can be one of the following values: </P>

<TABLE cols=2>

<TR VALIGN="top">
<TD width=35%><B>Value</B></TD>
<TD width=65%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=35%>HC_GETNEXT</TD>
<TD width=65%>The hook procedure must copy the current mouse or keyboard message to the <A HREF="r9bm84.htm"><B>EVENTMSG</B></A> structure pointed to by the <I>lParam</I> parameter. </TD>
</TR>

<TR VALIGN="top">
<TD width=35%>HC_NOREMOVE</TD>
<TD width=65%>An application has called the <A HREF="0x9xxx.htm"><B>PeekMessage</B></A> function with <I>wRemoveMsg</I> set to PM_NOREMOVE, indicating that the message is not removed from the message queue after <B>PeekMessage</B> processing. </TD>
</TR>

<TR VALIGN="top">
<TD width=35%>HC_SKIP</TD>
<TD width=65%>The hook procedure must prepare to copy the next mouse or keyboard message to the <A HREF="r9bm84.htm"><B>EVENTMSG</B></A> structure pointed to by <I>lParam</I>. Upon receiving the HC_GETNEXT code, the hook procedure must copy the message to the structure.  </TD>
</TR>

<TR VALIGN="top">
<TD width=35%>HC_SYSMODALOFF</TD>
<TD width=65%>A system-modal dialog box has been destroyed. The hook procedure must resume playing back the messages.</TD>
</TR>

<TR VALIGN="top">
<TD width=35%>HC_SYSMODALON</TD>
<TD width=65%>A system-modal dialog box is being displayed. Until the dialog box is destroyed, the hook procedure must stop playing back messages.</TD>
</TR>
</TABLE><BR>

<P></P>

<P>If <I>code</I> is less than zero, the hook procedure must pass the message to the <A HREF="2ebdbc.htm"><B>CallNextHookEx</B></A> function without further processing and should return the value returned by <B>CallNextHookEx</B>. </P>

<P><I>wParam</I></P>

<P>Specifies a NULL value. </P>

<P><I>lParam</I></P>

<P>Points to an <A HREF="r9bm84.htm"><B>EVENTMSG</B></A> structure that represents a message being processed by the hook procedure. This parameter is valid only when the <I>code</I> parameter is HC_GETNEXT. </P>

<P></P>

<P><B>Return Values</B></P>

<P>To have the system wait before processing the message, the return value must be the amount of time, in clock ticks, that the system should wait. (This value can be computed by calculating the difference between the <B>time</B> members in the current and previous input messages.) To process the message immediately, the return value should be zero. The return value is used only if the hook code is HC_GETNEXT; otherwise, it is ignored. </P>

<P><B>Remarks</B></P>

<P>A <B>JournalPlaybackProc</B> hook procedure should copy an input message to the <I>lParam</I> parameter. The message must have been previously recorded by using a <A HREF="32huo95.htm"><B>JournalRecordProc</B></A> hook procedure, which should not modify the message. </P>

<P>To retrieve the same message over and over, the hook procedure can be called several times with the <I>code</I> parameter set to HC_GETNEXT without an intervening call with <I>code</I> set to HC_SKIP. </P>

<P>If <I>code</I> is HC_GETNEXT and the return value is greater than zero, the system sleeps for the number of milliseconds specified by the return value. When the system continues, it calls the hook procedure again with <I>code</I> set to HC_GETNEXT to retrieve the same message. The return value from this new call to <B>JournalPlaybackProc</B> should be zero; otherwise, the system will go back to sleep for the number of milliseconds specified by the return value, call <B>JournalPlaybackProc</B> again, and so on. The system will appear to be hung. </P>

<P>Unlike most other global hook procedures, the <B>JournalRecordProc</B> and <B>JournalPlaybackProc</B> hook procedures are always called in the context of the thread that set the hook. </P>

<P>After the hook procedure returns control to the system, the message continues to be processed. If <I>code</I> is HC_SKIP, the hook procedure must prepare to return the next recorded event message on its next call. </P>

<P>An application installs a <B>JournalPlaybackProc</B> hook procedure by specifying the <A HREF="17p7nrh.htm">WH_JOURNALPLAYBACK hook</A> type and the address of the hook procedure in a call to the <A HREF="2d7__i2.htm"><B>SetWindowsHookEx</B></A> function. </P>

<P>A Win32 <B>JournalRecordProc</B> hook procedure does not need to live in a dynamic-link library. A Win32 <B>JournalRecordProc</B> hook procedure can live in the application itself. </P>

<P>If the user presses CTRL+ESC or CTRL+ALT+DEL during journal playback, the system stops the playback, unhooks the journal playback procedure, and posts a <A HREF="31phbfw.htm">WM_CANCELJOURNAL</A> message to the journaling application. </P>

<P>If the hook procedure returns a message in the range WM_KEYFIRST to WM_KEYLAST, the following conditions apply:</P>

<P>·The <I>paramL</I> member of the EVENTMSG structure specifies the virtual key code of the key that was pressed.</P>

<P>·The <I>paramH</I> member of the EVENTMSG structure specifies the scan code.</P>

<P>·There's no way to specify a repeast count. The event is always taken to represent one key event.</P>

<P></P>

<P><B>JournalPlaybackProc</B> is a placeholder for an application-defined or library-defined function name. </P>

<P><B>See Also</B></P>

<P><A HREF="2ebdbc.htm"><B>CallNextHookEx</B></A>, <A HREF="r9bm84.htm"><B>EVENTMSG</B></A>, <A HREF="32huo95.htm"><B>JournalRecordProc</B></A>, <A HREF="0x9xxx.htm"><B>PeekMessage</B></A>, <A HREF="2d7__i2.htm"><B>SetWindowsHookEx</B></A>, <A HREF="31phbfw.htm">WM_CANCELJOURNAL</A> </P>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
