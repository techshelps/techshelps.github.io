<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.1 Retrieve Unique Records Using Only a Select Query"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body><H3 class="docSection1Title">6.1 Retrieve Unique Records Using Only a Select Query</H3>
<P>I need to figure out which customers have invoices. The problem is that when I join the Customers with the Orders tables, I get the customers listed for each order. I only want each customer listed once. How do I return only those customers who have orders, but only once?</P>
<H4 class="docSection2Title"> Technique</H4>
<P>For this How-To, you will be using the <TT>DISTINCT</TT> clause on a SQL <TT>SELECT</TT> statement to limit the data to unique values. When you include the <TT>DISTINCT</TT> clause, SQL Server uses the columns that are returned to determine how to limit the data.</P>
<P>For the opposite affect, you can include the <TT>ALL</TT> clause, although it is not necessary because this is the default. You will create two <TT>SELECT</TT> statements for this task. The first one is for all records:</P>
<pre>
SELECT Customers.CompanyName FROM Customers INNER JOIN Orders ON Customers .CustomerID = 
<IMG BORDER="0" ALIGN="left" WIDTH="18" HEIGHT="11" src="FILES/ccc.gif" ALT="graphics/ccc.gif">Orders.CustomerID
</pre>
<P>To limit the records, use the <TT>DISTINCT</TT> clause:</P>
<pre>
SELECT DISTINCT Customers.CompanyName
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID
</pre>
<H4 class="docSection2Title"> Steps</H4>
<P>Open and run the Visual Basic .NET-Chapter 6 solution. From the main form, click on the button with the caption How-To 6.1. When the form loads, you will see two option buttons, Show All and Distinct, with Show All selected. The <TT>SELECT</TT> statement showing an inner join between customers and order is displayed in a Label control. You will also see a DataGrid control filled with multiple entries of customers displayed (see Figure 6.1).</P>
<CENTER><H5 class="docFigureTitle">Figure 6.1. A common problem with inner joins is retrieving multiple records when you want to see just one per occurrence.</H5><p><IMG BORDER="0" WIDTH="408" HEIGHT="424" src="FILES/06fig01.jpg" ALT="graphics/06fig01.jpg"></p>
</CENTER>
<P>If you click on the option button labeled Use Distinct, then the DataGrid control will be refreshed, but only one customer per set of orders will be displayed.</P>





<span style="font-weight:bold"><OL class="docList" START="1">
<LI><span style="font-weight:normal" value="1"><P>Create a Windows Form. Then place the controls listed in Table 6.1 with the following properties set, as displayed in Figures 6.1 and 6.2.</P>
<CENTER><H5 class="docFigureTitle">Figure 6.2. Using the <TT>DISTINCT</TT> clause gives you control over displaying unique records.</H5><p><IMG BORDER="0" WIDTH="408" HEIGHT="424" src="FILES/06fig02.jpg" ALT="graphics/06fig02.jpg"></p>
</CENTER>
<P><TABLE BORDER="1" align="center" CELLPADDING="6" CELLSPACING="0">
<CAPTION><h5 class="docTableTitle">Table 6.1. Control Property Settings for How-To 6.1</h5></CAPTION><COLGROUP span="3">
<TR>
<TH class="docTableHeader" align="left" valign="top">
<P>Object</P>
</TH>
<TH class="docTableHeader" align="left" valign="top">
<P>Property</P>
</TH>
<TH class="docTableHeader" align="left" valign="top">
<P>Setting</P>
</TH>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>RadioButton</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>Name</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>rbShowAll</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">&nbsp;</TD>
<TD class="docTableCell" valign="top">
<P><TT>Checked</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>True</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>RadioButton</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>Name</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>rbDistinct</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>Label</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>Text</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>SQL Statement</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>Label</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>Name</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>lblSQLString</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>Label</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>Text</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>Results</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>DataGrid</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>Name</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P><TT>dgResults</TT></P>
</TD>
</TR>
</COLGROUP>
</TABLE></P></span></LI><LI><span style="font-weight:normal" value="2"><P>As with some of the other chapters' projects, you need to build a support routine to create the Connection string. Called <TT>BuildCnnStr</TT>, the function can been seen in Listing 6.1. This function takes a server and database name passed to it and creates a connection string.</P>
<H5 class="docExampleTitle">Listing 6.1 <TT>modGeneralRoutines.vb</TT>: Creating a Connection String</H5>
<PRE>
Function BuildCnnStr(ByVal strServer As String, _
          ByVal strDatabase As String) As String

        Dim strTemp As String
        strTemp = "Provider=SQLOleDB; Data Source=" &amp; strServer &amp; ";"
        strTemp &amp;= "Initial Catalog=" &amp; strDatabase &amp; ";"
        strTemp &amp;= "Integrated Security=SSPI"

        Return strTemp
    End Function
</PRE>
<P>Although you could create a routine that would pass back a <TT>Connection</TT> object, a more versatile method would be to pass back a string. The reason for this is that for some objects, you are asked only for a <TT>Connection</TT> object, but other objects want just a string.</P></span></LI><LI><span style="font-weight:normal" value="3"><P>Add the code in Listing 6.2 to the Load event of the form. (Double-click on the form to bring up the code.)</P>
<H5 class="docExampleTitle">Listing 6.2 <TT>frmHowTo6_1.vb</TT>: Loading the Form</H5>
<PRE>
Private Sub frmHowTo6_1_Load(ByVal sender As System.Object,
                    ByVal e As System.EventArgs) Handles MyBase.Load

        GenerateData(Me.rbDistinct.Checked)

End Sub
</PRE></span></LI><LI><span style="font-weight:normal" value="4"><P>Add the code in Listing 6.3 to the class module of the page, creating the GenerateData routine. This routine creates the necessary SQL <TT>SELECT</TT> statement based on whether <TT>blnUseDistinct</TT> is <TT>true</TT> or <TT>false</TT>. If you look back at Listing 6.2, you will see that this is the value of option button rbDistinct. After the SQL string is created, it is assigned to <TT>lblSQLString</TT> to display the string, and then it is used in a data adapter to fill a dataset. Last, the SQL string is assigned as the data source for the data grid <TT>dgResults</TT>.</P>
<H5 class="docExampleTitle">Listing 6.3 <TT>frmHowTo6_1.vb</TT>: Building the SQL String for Retrieving the Data</H5>
<PRE>
Sub GenerateData(ByVal blnUseDistinct As Boolean)

        '-- Build the SQL String
        Dim strSQL As String

        strSQL = "SELECT "

        If blnUseDistinct Then
            strSQL += "DISTINCT "
        End If

        strSQL += "Customers.CompanyName FROM Customers "
        strSQL += "INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID"

        '-- Store the SQL String
        Me.lblSQLString.Text = strSQL

        '-- Use the SQL String to build the data adapter and fill the data table.
        Dim odaResults As New OleDb.OleDbDataAdapter(Me.lblSQLString.Text, _
                                  BuildCnnStr("(local)", "Northwind"))
        Dim dtResults As New DataTable()

        odaResults.Fill(dtResults)

        '-- Assign the data table to the data grid's DataSource property
        Me.dgResults.DataSource = dtResults

End Sub
</PRE></span></LI><LI><span style="font-weight:normal" value="5"><P>Add the code in Listing 5.4 to the <TT>CheckChanged</TT> event of the rbDistinct Radio Button control.</P>
<H5 class="docExampleTitle">Listing 6.4 <TT>frmHowTo6_1.vb</TT>: Regenerating the Data Based on the Radio Button That Is Checked</H5>
<PRE>
Private Sub rbDistinct_CheckedChanged(ByVal sender As System.Object, _
                ByVal e As System.EventArgs) Handles rbDistinct.CheckedChanged


        GenerateData(Me.rbDistinct.Checked)

End Sub
</PRE>
<div class="docNote"><p class="docNoteTitle">Tip</p>
<p><table border="0" align="center" cellpadding="6" cellspacing="0"><tr>
<td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" WIDTH="100" HEIGHT="100" src="FILES/tip_icon.gif" ALT="graphics/tip_icon.gif"></td>
<td valign="top"><P>You might have noticed that besides the loading of the form, I only call the <TT>GenerateData</TT> routine when the rbDistinct option button is changed, and not when the rbShowAll option button is changed. Because only two buttons are available, you only have to program one of the control's events. If you put it on both, you will have the routine called twice, which is not a good thing in this case.</P>
</td>
</tr></table></p>
</div></span></LI></OL></span>
<H4 class="docSection2Title"> Comments</H4>
<P>It is hard to believe that just one word can affect the data that a SQL statement returns. For the most part, you will want to see all of the records that a <TT>SELECT</TT> statement returns, but it is nice to have the <TT>DISTINCT</TT> clause when you need to limit the data.</P>
<ul></ul>
</body></html>
