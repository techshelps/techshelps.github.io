<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="9.6 Validate Data Passed to Properties and Communicate Errors to Developers"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body><H3 class="docSection1Title">9.6 Validate Data Passed to Properties and Communicate Errors to Developers</H3>
<P>To make a class that wraps up access to a table, it is critical that the class-and not the developer who is using the class-makes sure that all data is valid before writing it to the database.</P>
<P>For example, in the Customers table, the CustomerID field must be five characters in length-no more, no less-and, of course, it must be unique.</P>
<P>Phone numbers and fax numbers must also be validated. Although we don't necessarily know how many digits are in a phone number (France has eight-digit numbers, Spain has nine, and the U.S. has ten), we do know that only numbers and characters such as periods, parentheses, and hyphens are allowed.</P>
<P>You also need to communicate with other developers when their data is not valid. It is the data class's job to make sure that invalid data doesn't make it to the database.</P>
<P>This section presents three tasks: adding code to make sure that data passed to an object matches the column properties in the database, adding code that validates complex data types and business rules, and communicating errors to the class's consumers.</P>
<H4 class="docSection2Title"> Technique</H4>
<P>First, you need to pass errors back up the call stack. In Visual Basic 6, the accepted method was to use Err.Raise, which propagates an error number and an error message. This technique is still available to Visual Basic developers, but it retains all the old problems. If you aren't careful, programmers who are working on different components can raise the same error numbers, making error handling a potential nightmare. (If you aren't careful, <span class="docEmphasis">you</span> can end up raising the same error number in your <span class="docEmphasis">own</span> code.)</P>
<P>You learned how to use structured exception handling in earlier chapters, but the beauty is that you can define your own exceptions as needed, with almost no code. Also, because exceptions have a name as opposed to a number, it is far easier for developers to work with your code. Finally, because exceptions are defined with a Namespace, even if two projects define an <TT>InvalidCustomerIDException</TT>, each exception will be unique.</P>
<P>Second, you need to write code to check whether a value is valid. For the CustomerID, you simply need to check the length of the string. (Later on, you'll need to add code to check whether the ID already exists.) For phone numbers, you'll need to examine the string for invalid characters.</P>
<H4 class="docSection2Title"> Steps</H4>
<P>Because validating the maximum allowable length for all of our properties is simplest, tackle this task first.</P>









<span style="font-weight:bold"><OL class="docList" START="1">
<LI><span style="font-weight:normal" value="1"><P>Define a new exception class by inheriting from <TT>System.ApplicationException</TT>. As mentioned before, Microsoft recommends that all custom exceptions inherit from <TT>ApplicationException</TT> rather than Exception. <TT>System.ApplicationException</TT> has most of the methods and properties that you will need to communicate an exception to consumers of this class. The only property that a consumer might find useful is one that exposes what the maximum length of the property is. This would allow the consumer to communicate the error back to the user or truncate the string without having to hard-code the maximum length into his code. Adding the name of the property and the value is also a good idea. Some developers who are using your class might write one long Try...Catch block, so this information will help debug going forward. Paste the code in Listing 9.33 defining the <TT>MaximumStringLengthExceededException</TT> into your code.</P>
<H5 class="docExampleTitle">Listing 9.33 <TT>frmHowTo9_6.vb</TT>: Class Declaration for the <TT>MaximumStringLengthExceededException</TT></H5>
<PRE>
Public Class MaximumStringLengthExceededException
    Inherits System.ApplicationException

    Private nMaxLen As Integer

    Public Sub New(ByVal pMaxLen As Integer, ByVal pPropertyName As String,
     ByVal pValue As String)
        ' You need to initialize the base class of this exception.
        ' If you do not specifically call a constructor of the base
        ' class, the default constructor (the one without parameters)
        ' will be called, if it exists. MyBase must precede the call to
        ' the base class's constructor so that the .NET runtime knows not
        ' to call a constructor in the derived class.
        MyBase.new("The value specified, " &amp; pValue &amp; _
          ", exceeds the maximum " &amp;
          "length of " &amp; pMaxLen &amp; " allowable by the " &amp; _
          pPropertyName &amp; " property.")
    End Sub

    Public ReadOnly Property MaxLength() As Integer
        Get
            Return nMaxLen
        End Get
    End Property
End Class
</PRE></span></LI><LI><span style="font-weight:normal" value="2"><P>Next, modify the set block of each property in the class to check the length of the new value to see if it exceeds the maximum length of the column in the Customers table. If the length of the new value does exceed the maximum length, throw a new instance of the <TT>MaximumStringLengthExceededException</TT>. To do this, simply create an <TT>If...Then</TT> block that checks the maximum length into your class.</P>
<P>When you have modified all of your properties, they should look like the <TT>ContactName</TT> property in Listing 9.34.</P>
<H5 class="docExampleTitle">Listing 9.34 <TT>frmHowTo9_6.vb</TT>: The <TT>ContactName</TT> Property Validates for the Maximum Length of the Column and Throws an Exception if the Value Passed to the Property Exceeds That Maximum Value</H5>
<PRE>
Public Property ContactName() As String Implements ICustomer9_6.ContactName
    Get
        Return mstrContactName
    End Get
    Set(ByVal Value As String)
        If Value.Length &lt;= 30 Then
            mstrContactName = Value
        Else
            Throw New MaximumStringLengthExceededException(30, "ContactName", Value)
        End If
    End Set
End Property
</PRE></span></LI><LI><span style="font-weight:normal" value="3"><P>Validating a phone number or fax number requires more than just checking the maximum length of the column. You need to make sure that only numbers and other allowable characters are in the value. First, create a new exception for invalid phone numbers by adding the code from Listing 9.35 to <TT>frmHowTo9_6.vb</TT>.</P>
<H5 class="docExampleTitle">Listing 9.35 <TT>frmHowTo9_6.vb</TT>: The <TT>InvalidPhoneNumberException</TT></H5>
<PRE>
Public Class InvalidPhoneNumberException
    Inherits System.ApplicationException

    Public Sub New(ByVal pstrPhone As String)
        MyBase.New("The phone number specified, " &amp; pstrPhone &amp; ", is not valid.")
    End Sub

End Class
</PRE></span></LI><LI><span style="font-weight:normal" value="4"><P>Next, add a private method called <TT>ValidatePhoneNumber</TT> to check a phone number string for invalid characters, such as letters or punctuation marks, as shown in Listing 9.36.</P>
<H5 class="docExampleTitle">Listing 9.36 <TT>frmHowTo9_6.vb</TT>: A Function That Validates Phone Numbers</H5>
<PRE>
Private Function ValidatePhoneNumber(ByVal pstrPhone As String) As Boolean

    ' Create a string array that contains the numbers 0 to 9, as well as
    ' a hyphen, period, space, and parentheses.
    Dim cValidChars() As String
    cValidChars = New String(14) {"1", "2", "3", "4", "5", _
     "6", "7", "8", "9", "0", "(", ")", "-", " ", "."}

    Dim i As Integer = 0
    Dim nUBound As Integer = cValidChars.GetUpperBound(0)
    Dim nLBound As Integer = cValidChars.GetLowerBound(0)

    ' Loop through the array of valid characters and remove them
    ' from a phone number string. If characters are left
    ' in the string, the phone number is invalid.
    For i = nLBound To nUBound Step 1
        pstrPhone = pstrPhone.Replace(cValidChars(i), "")
    Next
    pstrPhone = pstrPhone.Trim()
    If pstrPhone.Length &gt; 0 Then
        Return False
    Else
        Return True
    End If

End Function
</PRE></span></LI><LI><span style="font-weight:normal" value="5"><P>Modify the set blocks of the Fax and Phone properties to call the <TT>ValidatePhoneNumber</TT> method and throw an <TT>InvalidPhoneNumberException</TT> if the phone number is not valid. Your code should look like Listing 9.37.</P>
<H5 class="docExampleTitle">Listing 9.37 <TT>frmHowTo9_6.vb</TT>: The Phone Property That Validates Phone Numbers</H5>
<PRE>
Public Property Phone() As String Implements ICustomer.Phone
    Get
        Return mstrPhone
    End Get
    Set(ByVal Value As String)
        If Value.Length &lt;= 24 Then
            If ValidatePhoneNumber(Value) Then
                mstrPhone = Value
            Else
                Throw New InvalidPhoneNumberException(Value)
            End If
        Else
            Throw New MaximumStringLengthExceededException(24, "Phone", Value)
        End If
    End Set
End Property
</PRE></span></LI><LI><span style="font-weight:normal" value="6"><P>The last piece of data that you need to validate is the CustomerID. You need to validate for the string length, and for new customers, you need to validate for the uniqueness of the proposed CustomerID.</P>
<P>Validating for the proper length of a CustomerID is simple. First, add a new exception called <TT>InvalidCustomerIDException</TT>, as shown in Listing 9.38.</P>
<H5 class="docExampleTitle">Listing 9.38 <TT>frmHowTo9_6.vb</TT>: Declaration of the <TT>InvalidCustomerIDException</TT></H5>
<PRE>
Public Class InvalidCustomerIDException
    Inherits System.ApplicationException

    Public Sub New(ByVal pstrID As String)
        MyBase.New("The customer ID specified, " &amp; pstrID &amp; ", is not valid")
    End Sub

End Class
</PRE></span></LI><LI><span style="font-weight:normal" value="8"><P>Then add the method from Listing 9.39, which checks the length of a CustomerID string and ensures that the string has no whitespace.</P>
<H5 class="docExampleTitle">Listing 9.39 <TT>frmHowTo9_6.vb</TT>: The <TT>ValidateCustomerID</TT> Method</H5>
<PRE>
Private Function ValidateCustomerID(ByVal pstrID As String) As Boolean
    ' Strip out any leading or trailing spaces.
    pstrID = pstrID.Trim

    ' A CustomerID must have five characters.
    If pstrID.Length = 5 Then
        Return True
    Else
        Return False
    End If

End Function
</PRE></span></LI><LI><span style="font-weight:normal" value="9"><P>Now add code like that in Listing 9.40 to your constructor that validates the CustomerID, and, if that value is invalid, throws an <TT>InvalidCustomerIDException</TT>.</P>
<H5 class="docExampleTitle">Listing 9.40 <TT>frmHowTo9_6.vb</TT>: An <TT>If...Then</TT> Block to Wrap Around Your Constructor Code</H5>
<PRE>
If ValidateCustomerID(pCustomerIDToRetrieve) Then

    ' Your original constructor code goes here.

Else
    Throw New InvalidCustomerIDException(pCustomerIDToRetrieve)
End If
</PRE></span></LI><LI><span style="font-weight:normal" value="10"><P>The final piece of validation code you need to add is a function that checks for the existence of a CustomerID before a new Customer object is instantiated. You could use the data access objects you defined in CCustomerData, but for performance purposes, you should create a new command object and use the <TT>ExecuteScalar</TT> method as shown in Listing 9.41; this method requires less interaction with the database.</P>
<H5 class="docExampleTitle">Listing 9.41 <TT>frmHowTo9_6.vb</TT>: The <TT>DoesCustomerIDExist</TT> Function</H5>
<PRE>
Private Function DoesCustomerIDExist(ByVal pstrID As String) As Boolean

    Dim strSQL As String = "SELECT COUNT(*) FROM Customers " &amp; _
                            "WHERE CustomerID = '" &amp;
      pstrID &amp; "'"
    Dim cmd As New System.Data.OleDb.OleDbCommand(strSQL, oleCnn)
    Dim fExists As Boolean

    oleCnn.Open()
    fExists = CBool(cmd.ExecuteScalar())
    oleCnn.Close()
    Return fExists

End Function
</PRE>
<P>Add an extra <TT>If...Then</TT> block in the constructor used to create a new Customer row and you're ready to start testing your new code.</P>
<P>Your existing code for <TT>frmHowTo9_6</TT> should suffice for testing. You made sure to handle exceptions thrown from properties in section 9.2.</P></span></LI></OL></span>
<H4 class="docSection2Title"> How It Works</H4>
<P>Much of the code in this section qualifies and extends the properties you have already defined and implemented. This section has two key concepts.</P>
<P>Validating data is a critical part of any application, although the examples in this section use validation techniques you should already be familiar with. The next section will take data validation to a new level.</P>
<P>The most important concept is declaring your own exceptions. Communicating errors to other parts of the application is, perhaps, more important than the business logic you implement. When it works, it works, but when something goes wrong, providing enough information about the error is far more important. Creating new exceptions is an elegant and readable way to communicate and handle errors.</P>
<H4 class="docSection2Title"> Comments</H4>
<P>Hardcoding the maximum column length into the property set block as recommended in this section isn't necessarily the best solution to this problem. If you decide to increase or decrease the length of the column in the database, you must search through all of your source code to find every place that value was hard coded. Using constants is one way around this, but your options still are fairly limited.</P>
<P>The strongly typed dataset you created earlier has the potential to provide an elegant solution to this problem. The XSD that underlies the dataset could define many of the data rules in your tables, including the maximum length of columns. Also, the actual dataset exposes this information in its properties and methods. The problem is that Visual Studio .NET does not generate XSDs with such strict definitions.</P>
<ul></ul>
</body></html>
