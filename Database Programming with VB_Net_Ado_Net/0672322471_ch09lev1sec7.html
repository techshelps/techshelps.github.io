<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="9.7 Write Data Validation Code That Can Be Reused in Other Classes"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body><H3 class="docSection1Title">9.7 Write Data Validation Code That Can Be Reused in Other Classes</H3>
<P>As you were writing the PhoneNumber and CustomerID validation code in the previous section, you might have thought that this code would be extraordinarily useful in other parts of the Northwind application. For example, the Suppliers and Employees tables also have Phone and Fax fields, and the CustomerID column is also defined in the Orders table.</P>
<H4 class="docSection2Title"> Technique</H4>
<P>In this section, you will pull the data validation code you wrote for both the PhoneNumber and CustomerID columns and create independent objects that encapsulate your existing validation logic. Then you will update the <TT>CCustomer</TT> class to make use of these new classes.</P>
<P>The <TT>CCustomerID</TT> class will be a simple class that performs two functions: checking the length of the ID and looking in the database to see if the CustomerID exists.</P>
<P>For the PhoneNumber data validation, you will learn how to create an entire object model that will provide you with data validation for different types of phone numbers with a bare minimum of code. And, just for the fun of it, you will learn how to use the same base class you use to validate phone numbers to validate Social Security numbers.</P>
<H4 class="docSection2Title"> Steps</H4>



















<span style="font-weight:bold"><OL class="docList" START="1">
<LI><span style="font-weight:normal" value="1"><P>Add a new class file to your project by right-clicking on the project in the Solution Explorer window and selecting Add Class from the Add submenu. Name the new class <TT>CCustomerID.vb</TT>.</P></span></LI><LI><span style="font-weight:normal" value="2"><P>Copy the <TT>DoesCustomerIDExist</TT> and <TT>ValidateCustomerID</TT> methods from the <TT>CCustomer</TT> class into the <TT>CCustomerID</TT> class. Rename them <TT>Exists</TT> and <TT>Validate</TT>, respectively.</P></span></LI><LI><span style="font-weight:normal" value="3"><P>Copy the <TT>InvalidCustomerIDException</TT> from <TT>CustomerClass.vb</TT> and paste it <span class="docEmphasis">inside</span> the <TT>CCustomerID</TT> class. This makes your exceptions directly related to the CCustomerID.</P></span></LI><LI><span style="font-weight:normal" value="4"><P>One gap in splitting off the <TT>CustomerID</TT> property into its own class is that some parts of your application might want a read/write <TT>CustomerID</TT> property, whereas others, such as the <TT>CCustomer</TT> class, need a <TT>ReadOnly</TT> property. Instead of having a Boolean set to lock the property, a more flexible way is to add an event to your class that is called before setting the property, allowing a containing class to cancel the change.</P>
<pre>
Public Event BeforeUpdate(ByVal pstrCustomerID As String, ByRef pfCancel As Boolean)
</pre></span></LI><LI><span style="font-weight:normal" value="5"><P>Now add a new property called <TT>CustomerID</TT> to the <TT>CCustomerID</TT> class, as shown in Listing 9.42. This property should raise the <TT>BeforeUpdate</TT> event, and if the changes are not cancelled, call the <TT>Validate</TT> method and throw an <TT>InvalidCustomerIDException</TT> if the <TT>CustomerID</TT> is invalid.</P>
<H5 class="docExampleTitle">Listing 9.42 <TT>CCustomerID.vb</TT>: The <TT>CustomerID</TT> Property of the <TT>CCustomerID</TT> Class</H5>
<PRE>
Property CustomerID() As String
    Get
        Return mstrCustomerID
    End Get
    Set(ByVal Value As String)

        Dim fCanceled As Boolean
        RaiseEvent BeforeUpdate(Value, fCanceled)

        If Not fCanceled Then

            mfValid = Validate(Value)
            If mfValid Then
                mstrCustomerID = Value
            Else
                Throw New InvalidCustomerIDException(Value)
            End If

        End If
    End Set
End Property
</PRE></span></LI><LI><span style="font-weight:normal" value="6"><P>Then add a new constructor that accepts a CustomerID as a parameter. That constructor, shown in Listing 9.43, should call the property statement, which will handle validation.</P>
<H5 class="docExampleTitle">Listing 9.43 <TT>CCustomerID.vb</TT>: The Constructor for the CCustomerID</H5>
<PRE>
ClassPublic Sub New(ByVal pID As String)
    Me.CustomerID = pID
End Sub
</PRE></span></LI><LI><span style="font-weight:normal" value="7"><P>You're almost finished with the <TT>CCustomerID</TT> class, except for one subtle issue: pointers. Everything you've written in this chapter so far has used base datatypes, so you haven't had to worry about copying values between function calls. But objects work differently than base datatypes do.</P>
<P>The issue is with <TT>ByVal</TT> and <TT>ByRef</TT>. With base datatypes, the distinction is fairly straightforward: <TT>ByVal</TT> passes a copy of the value of the variable to the function. The called function could do whatever it pleased to the passed value without impacting the value of the variable in the calling function. <TT>ByRef</TT> passes the called function a pointer instead of the value, so any change made to the variable in the called function is made to the variable in the calling function.</P>
<P>With objects such as <TT>CCustomerID</TT>, it's completely different. Whether you use <TT>ByVal</TT> <span class="docEmphasis">or</span> <TT>ByRef</TT>, you're still working with a pointer. The called function will <span class="docEmphasis">always</span> modify the object that the calling function passes.</P>
<P>The difference is in reassigning the pointer. <TT>ByVal</TT> passes a pointer to an object. If the called function changes the pointer to a new object, the calling function will still point at the original object. <TT>ByRef</TT> passes a pointer to a pointer to an object. If the called function changes the pointer to a new object, the calling function will now point at the new object instead of the original object.</P>
<P>The point(er) here is in the constructors. You want to provide a way for other developers to create copies of the class easily, or you might end up with the same <TT>CCustomerID</TT> object being used simultaneously in a potentially conflicting fashion. The solution? Add a constructor to the <TT>CCustomerID</TT> class that accepts a <TT>CCustomerID</TT> object as a parameter, as shown in Listing 9.44.</P>
<H5 class="docExampleTitle">Listing 9.44 <TT>CCustomerID.vb</TT>: An Object-Based Constructor for the <TT>CCustomerID</TT> Class</H5>
<PRE>
Public Sub New(ByVal pID As CCustomerID)
    ' Both ByVal and ByRef pass object pointers, so if you
    ' want to create a new CustomerID instance based on an
    ' existing instance, you need to copy the values of the
    ' base datatypes to a new instance.
    Me.CustomerID = pID.CustomerID
End Sub
</PRE></span></LI><LI><span style="font-weight:normal" value="8"><P>Updating the <TT>CCustomer</TT> class is not difficult, but it does require many small, similar changes, including the following:</P>
<UL>
<LI><P>Retyping variables</P></LI>
<LI><P>Removing code validating CustomerIDs and related exception throwing</P></LI>
<LI><P>Calling CCustomerID's object-based constructor from Listing 9.43 each time a <TT>CCustomerID</TT> object is passed into a <TT>CCustomer</TT> object</P></LI>
<LI><P>Adding <TT>.CustomerID</TT> after every <TT>CCustomerID</TT> variable where the string value is needed</P></LI>
</UL>
<P>The constructor in Listing 9.45 that you use to create new customers in the database is a good example of all of these changes.</P>
<H5 class="docExampleTitle">Listing 9.45 <TT>CCustomerID.vb</TT>: An Excerpt of a CCustomer Constructor as Modified to Use the <TT>CCustomerID</TT> Class</H5>
<PRE>
Public Sub New(ByVal pCustomerID As CCustomerID,
           ByVal pCompanyName As String)
    ' Change A: retyping variables
    ' Instead of accepting a string that has to be validated,
    ' this constructor accepts a CCustomerID object that by
    ' definition is valid.

    If pCustomerID.Exists Then
        ' Change B: removing code validating CustomerIDs
        ' If you recall, there used to be an additional condition
        ' in this If... Then that checked the length of the CustomerID.
        ' Now, the CCustomerID guarantees a valid CustomerID.
        mdsCust = New dsCustomers()
        mfNew = True

        ' Change C: using the object-based constructor
        ' Just to make sure, create a new CCustomerID object. If you
        ' don't, consumers of this class will retain a pointer to this
        ' object instance, allowing that consumer to change the value
        ' of the shared CCustomerID object unbeknownst to the CCustomer object.
        mCustomerID = New CCustomerID(pCustomerID)

        Me.CompanyName = pCompanyName
    Else
        ' Change D: calling the CustomerID property when you need a string.
        ' When you throw an InvalidCustomerIDEException, you won't necessarily
        ' have a valid CustomerID, so this exception has to accept a string
        ' instead of an object. This InvalidCustomerIDException is used to express
        ' that the CustomerID for the new customer already exists in the database.
        Throw New CCustomerID.InvalidCustomerIDException(pCustomerID.CustomerID)
    End If

End Sub
</PRE>
<div class="docNote"><p class="docNoteTitle">Tip</p>
<p><table border="0" align="center" cellpadding="6" cellspacing="0"><tr>
<td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" WIDTH="100" HEIGHT="100" src="FILES/tip_icon.gif" ALT="graphics/tip_icon.gif"></td>
<td valign="top"><P>One way to identify all these changes is to change the type of the <TT>CustomerID</TT> property in the ICustomer interface, as well as the name of the class-level variable in the <TT>CCustomer</TT> class that holds CustomerID values. Because this will invalidate much of the code utilizing CustomerIDs, Visual Studio .NET will put a wavy blue line under the code you need to modify.</P>
</td>
</tr></table></p>
</div></span></LI><LI><span style="font-weight:normal" value="9"><P>You will also need to redeclare the <TT>mCustomerID</TT> variable using the <TT>WithEvents</TT> keyword and add an event handler that cancels the change, as shown in Listing 9.46.</P>
<H5 class="docExampleTitle">Listing 9.46 <TT>frmHowTo9_7.vb</TT>: Adding Event Handlers to <TT>CCustomer</TT> to Handle the <TT>CCustomerID BeforeUpdate</TT> Event</H5>
<PRE>
Private WithEvents mCustomerID As CCustomerID

Private Sub mCustomerID_BeforeUpdate(ByVal pstrCustomerID As String,
 ByRef fCancel As Boolean) Handles mCustomerID.BeforeUpdate
    fCancel = True
End Sub
</PRE>
<P>The next task in this section is to provide similar validation functionality for phone numbers that can be used throughout your application. At the end of this task, you will have four separate classes, all of which extend the functionality of a fifth base class. Before you begin coding so many classes, it is always a good idea to plan precisely what you want to write.</P>
<P>Figure 9.8 is a class diagram that describes the classes you're going to write and their relationship to each other. The class at the top of the diagram is our base class. The base class has only one purpose: It contains a method that checks a string of numbers to see whether the string has invalid characters. All of the other classes will inherit this validation method, but each class will change the definition of valid characters in the string.</P>
<CENTER><H5 class="docFigureTitle">Figure 9.8. A class diagram describing the classes to be developed in section 9.7.</H5><p><IMG BORDER="0" WIDTH="500" HEIGHT="493" src="FILES/09fig08.gif" ALT="graphics/09fig08.gif"></p>
</CENTER>
<P>According to the class diagram, this class has only seven members: two variables (<TT>cValidChars</TT> and <TT>mstrValue</TT>), one property (<TT>StringValue</TT>), three methods (<TT>IsValid</TT>, <TT>ThrowException</TT>, and <TT>DefineValidChars</TT>), and one member class (<TT>InvalidNumberStringException</TT>).</P>
<P>You might have noticed a symbol before each member declaration. This symbol refers to the accessibility of the member. A minus sign (-) means the member is Private, a number sign (#) means Protected, and a plus sign (+) means Public. If this doesn't make sense at the moment, don't worry. It will be much clearer when you see the code.</P></span></LI><LI><span style="font-weight:normal" value="10"><P>Because all of the classes rely on code in the base class, you should start by defining the <TT>CNumberString</TT> class. This class will be the most complex in this hierarchy, so you will walk through it step-by-step. First, right-click on your project in the Solution Explorer and select Add Class from the Add submenu. Name the class <TT>PhoneDatatypes.vb</TT>.</P></span></LI><LI><span style="font-weight:normal" value="11"><P>Declare the <TT>CNumberString</TT> class block, as well as the <TT>InvalidNumberStringException</TT> member class, using the <TT>MustInherit</TT> keyword, as shown in Listing 9.47. The <TT>MustInherit</TT> keyword means that the <TT>CNumberString</TT> class cannot be instantiated directly. Instead, the class must be inherited by another class for its members to be accessed.</P>
<H5 class="docExampleTitle">Listing 9.47 <TT>PhoneDatatypes.vb</TT>: Declaration of the <TT>CNumberString</TT> Abstract Class</H5>
<PRE>
Public MustInherit Class CNumberString

    Public MustInherit Class InvalidNumberStringException
        Inherits System.ApplicationException

        Protected Sub New(ByVal pstrMessage As String)
            MyBase.New(pstrMessage)
        End Sub

    End Class

End Class
</PRE>
<P>A class that is declared with the <TT>MustInherit</TT> keyword is known as an abstract class, and it is best described as a hybrid between an interface and a class(see Table 9.3). Like an interface, instances of an abstract class cannot be created directly, and its methods and properties need not have code. Like a regular class, an abstract class does contain some implemented methods and properties, and even though it cannot be instantiated, it can have constructors.</P>
<P><TABLE BORDER="1" align="center" CELLPADDING="6" CELLSPACING="0">
<CAPTION><h5 class="docTableTitle">Table 9.3. Visual Basic .NET Class Inheritance Permission Keywords</h5></CAPTION><COLGROUP span="2">
<TR>
<TH class="docTableHeader" align="left" valign="top">
<P>Keyword</P>
</TH>
<TH class="docTableHeader" align="left" valign="top">
<P>Definition</P>
</TH>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>MustInherit</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P>Instances of the class cannot be created directly, and the class must be inherited to be used.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>NotInheritable</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P>The class is in a finalized state and cannot be used as a base class.</P>
</TD>
</TR>
</COLGROUP>
</TABLE></P></span></LI><LI><span style="font-weight:normal" value="12"><P>Declare the two class-level variables: <TT>cValidChars</TT> and <TT>mstrValue</TT>. Note that both variables are declared as protected. This means that the variables will only be accessible to derived classes because those classes will need to modify the list of valid characters and might need to access the string value.</P></span></LI><LI><span style="font-weight:normal" value="13"><P>Declare the <TT>DefineValidChars</TT>, <TT>IsValid</TT>, and <TT>ThrowException</TT> methods as shown in Listing 9.48. You might also want to add an Event declaration that fires before updating the <TT>StringValue</TT> property. (If you do not, you won't be able to catch changes made to properties in CCustomer; thus, you won't be able to check for the maximum length of the <TT>Phone</TT> and <TT>Fax</TT> properties.)</P>
<H5 class="docExampleTitle">Listing 9.48 <TT>PhoneDatatypes.vb</TT>: Declaration of the <TT>IsValid</TT>, <TT>DefineValidChars</TT>, and <TT>ThrowException</TT> Methods</H5>
<PRE>
Public Sub New()
    DefineValidChars()
End Sub

Public Event StringValueBeforeUpdate(ByVal pstrValue As String, _
 ByRef pCancel As Boolean)

Protected Overridable Sub DefineValidChars()
    cValidChars = New String(9) {"1", "2", "3", "4", "5", _
     "6", "7", "8", "9", "0"}
End Sub

Public Overridable Function IsValid(ByVal pstrNumber As String) As Boolean

    Dim i As Integer = 0
    Dim nUBound As Integer = cValidChars.GetUpperBound(0)
    Dim nLBound As Integer = cValidChars.GetLowerBound(0)

    For i = nLBound To nUBound Step 1
        pstrNumber = pstrNumber.Replace(cValidChars(i), "")
    Next
    pstrNumber = pstrNumber.Trim()
    If pstrNumber.Length &gt; 0 Then
        Return False
    Else
        Return True
    End If
End Function

Public MustOverride Function ThrowException() As InvalidNumberStringException
</PRE>
<P>The <TT>IsValid</TT> method is the key to the whole thing, and is really just the <TT>ValidatePhoneNumber</TT> method from the previous section. The <TT>DefineValidChars</TT> method populates the list of valid characters. It has been separated from the <TT>IsValid</TT> method so that derived classes can easily redefine the list of valid characters without having to rewrite the <TT>IsValid</TT> method.</P>
<P>Both of these methods have been declared as Overrideable. This means that a derived class has the option of redefining either of these methods. In previous sections, you regularly overrode constructors when you created custom exceptions based on the <TT>ApplicationException</TT>. (Actually, constructors of a base class are never exposed as constructors of a derived class, so they are overridden by default). If you recall, you can still access the overridden constructor within your class by using the <TT>MyBase</TT> keyword. The same goes for methods: You can call the overridden method within your class by using the <TT>MyBase</TT> keyword.</P>
<P>The <TT>ThrowException</TT> method is declared using the <TT>MustOverride</TT> keyword (see Table 9.4), and it is an abstract method. Any class that inherits from the <TT>CNumberString</TT> class must implement this method. This works just like a method that is declared in an interface, except that you do not need to use the Implements keyword in the method declaration.</P>
<P><TABLE BORDER="1" align="center" CELLPADDING="6" CELLSPACING="0">
<CAPTION><h5 class="docTableTitle">Table 9.4. Visual Basic .NET Member Override Keywords</h5></CAPTION><COLGROUP span="2">
<TR>
<TH class="docTableHeader" align="left" valign="top">
<P>Keyword</P>
</TH>
<TH class="docTableHeader" align="left" valign="top">
<P>Definition</P>
</TH>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>Overrides</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P>The method overrides the member of the base class with the same signature.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>Overrideable</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P>The method can be overridden in a derived class.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>MustOverride</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P>The method must be overridden in every derived class.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell" valign="top">
<P><TT>NotOverrideable</TT></P>
</TD>
<TD class="docTableCell" valign="top">
<P>The method can never be overridden by a derived class.</P>
</TD>
</TR>
</COLGROUP>
</TABLE></P></span></LI><LI><span style="font-weight:normal" value="14"><P>The last member to implement is the <TT>StringValue</TT> property defined in Listing 9.49. Note that properties cannot be overridden.</P>
<H5 class="docExampleTitle">Listing 9.49 <TT>PhoneDatatypes.vb</TT>: The <TT>StringValue</TT> Property</H5>
<PRE>
Public Property StringValue() As String
    Get
        Return mstrValue
    End Get
    Set(ByVal Value As String)

        Dim fCancelChange As Boolean

        If isValid(Value) Then
            RaiseEvent StringValueBeforeUpdate(Value, fCancelChange)
            If Not fCancelChange Then
                mstrValue = Value
            End If
        Else
            Throw ThrowException(Value)
        End If

    End Set
End Property
</PRE>
<P>It doesn't look like much is going on here, but this is the most interesting member in the class. Why? This member is responsible for all data validation, including validation kicked that constructors kick off. All of the methods called in this member are overrideable, though. In other words, the <TT>IsValid</TT> method that it looks like you're calling could be any <TT>IsValid</TT> method from any derived class. And the <TT>ThrowException</TT> method isn't even defined in this class. The actual method called always will be defined in a derived class.</P></span></LI><LI><span style="font-weight:normal" value="15"><P>The simplest derivation of the <TT>CNumberString</TT> class is a class that handles phone number extensions. (You will use this as part of a <TT>BusinessPhone</TT> number class later.) A phone extension contains only numbers, so you don't need to modify the <TT>IsValid</TT> method or the <TT>DefineValidChars</TT> method. As you can see in Listing 9.50, all you need is to define an exception, a method to throw it, and a constructor that calls the constructor of the <TT>CNumberString</TT> class and the <TT>StringValue</TT> property.</P>
<H5 class="docExampleTitle">Listing 9.50 <TT>PhoneDatatypes.vb</TT>: A Simple Class for Phone Number Extensions Derived from the <TT>CNumberString</TT> Class</H5>
<PRE>
Public Class CExtension
    Inherits CNumberString

    Public Class InvalidPhoneExtensionException
        Inherits CNumberString.InvalidNumberStringException

        Public Sub New(ByVal pstrPhoneNumber As String)
            MyBase.New("The phone extension specified, " &amp; pstrPhoneNumber &amp;
                       ", contains invalid characters.")
        End Sub

    End Class

    Sub New(ByVal pstrExtension As String)
        MyBase.New()
        Me.StringValue = pstrExtension
    End Sub

    Public Overrides Function ThrowException(ByVal pstrInvalidExt As String)
     As InvalidNumberStringException
        Throw New InvalidPhoneExtensionException(pstrInvalidExt)
    End Function

End Class
</PRE>
<P>So what's going on? The CExtension constructor calls the constructor of the <TT>CNumberString</TT> class, which calls <TT>CNumberString.DefineValidChars</TT>. Then, the string value is passed to the <TT>CNumberString.StringValue</TT> property, where its validity is checked. (If that doesn't make sense, create an instance of the class and step through it line by line.)</P></span></LI><LI><span style="font-weight:normal" value="16"><P>To take the example a step further, create a phone number class that inherits from the <TT>CNumberString</TT> class. As in the <TT>CExtension</TT> class from Listing 9.50, , you will need to declare an exception, a method to throw it, and a constructor to create the class. The only substantive change in Listing 9.51 is the addition of several new valid characters-including parentheses, periods, and hyphens-to the list of valid characters.</P>
<H5 class="docExampleTitle">Listing 9.51 <TT>PhoneDatatypes.vb</TT>: An International Phone Number Extension of the <TT>CNumberString</TT> Class</H5>
<PRE>
Public Class CPhoneNo
    Inherits CNumberString

    Public Class InvalidPhoneNumberException
        Inherits CNumberString.InvalidNumberStringException

        Public Sub New(ByVal pstrPhoneNumber As String)
            MyBase.New("The phone number specified, " &amp; pstrPhoneNumber &amp; _
             ", contains invalid characters.")
        End Sub

    End Class

    Sub New(ByVal pstrPhoneNo As String)
        MyBase.new()
        Me.StringValue = pstrPhoneNo
    End Sub

    Sub New(ByVal pPhoneNo As CPhoneNo)
        Me.New(pPhoneNo.StringValue)
    End Sub

    Public Overrides Function ThrowException(ByVal pstrInvalidPhone As String) _
     As InvalidNumberStringException
        Throw New InvalidPhoneNumberException(pstrInvalidPhone)
    End Function


    ' This is the only substantive change. This sub redefines the DefineValidChars
    ' method so that when this method is called in the base class's constructor, it will
    ' call this method instead of the original method.
    Protected Overrides Sub DefineValidChars()
        cValidChars = New String(14) {"1", "2", "3", "4", "5", _
         "6", "7", "8", "9", "0", _
         "(", ")", " ", ".", "-"}
    End Sub
End Class
</PRE>
<P>What's going on? The <TT>CPhoneNo</TT> constructor calls the constructor of the <TT>CNumberString</TT> class, but because you overrode <TT>DefineValidChars</TT>, <TT>CNumberString.New</TT> <span class="docEmphasis">actually</span> calls <TT>CPhoneNo.DefineValidChars</TT> instead of <TT>CNumberString.DefineValidChars</TT>.</P>
<div class="docNote"><p class="docNoteTitle">Tip</p>
<p><table border="0" align="center" cellpadding="6" cellspacing="0"><tr>
<td width="60" valign="top"><IMG BORDER="0" ALIGN="LEFT" WIDTH="100" HEIGHT="100" src="FILES/tip_icon.gif" ALT="graphics/tip_icon.gif"></td>
<td valign="top"><P>You can combine the <TT>CExtension</TT> and <TT>CPhoneNo</TT> classes to create a <TT>CBusinessPhone</TT> class that would be far more useful in an application of this sort. A sample of this code is included in <TT>PhoneDatatypes.vb</TT>.</P>
</td>
</tr></table></p>
</div></span></LI><LI><span style="font-weight:normal" value="17"><P>Utilizing the phone number class in your existing code is a process similar to what you did to integrate the <TT>CCustomerID</TT> class in earlier in this section.</P>
<P>Again, you will need to do the following:</P>
<UL>
<LI><P>Retype variables.</P>
</LI>
<LI><P>Remove code validating phone numbers and related exception throwing.</P>
</LI>
<LI><P>Add <TT>.StringValue</TT> after every <TT>CPhoneNo</TT> variable where the string value is needed.</P>
</LI>
<LI><P>Calling CPhoneNo's object-based constructor from Listing 9.51 each time a <TT>CCustomerID</TT> object is passed into a <TT>CCustomer</TT> object.</P>
</LI>
</UL></span></LI><LI><span style="font-weight:normal" value="18"><P>More important, you will need to move the maximum length validation to event handlers, as shown in Listing 9.52. The value of the phone number-contained in the <TT>CphoneNo</TT> class-can be changed without changing the phone number property, which is just a pointer.</P>
<H5 class="docExampleTitle">Listing 9.52 <TT>PhoneDatatypes.vb</TT>: An Event Handler for the <TT>mFax</TT> Variable in the <TT>CCustomer</TT> Class</H5>
<PRE>
Private Sub mFax_StringValueBeforeUpdate(ByVal pstrValue As String,
 ByRef pCancel As Boolean) Handles mFax.StringValueBeforeUpdate

    If pstrValue.Length &lt;= 24 Then
        pCancel = False
    Else
        pCancel = True
        Throw New MaximumStringLengthExceededException(24, "Fax", pstrValue)
    End If

End Sub
</PRE></span></LI><LI><span style="font-weight:normal" value="19"><P>The final code example of this chapter will take another look at the <TT>CNumberString</TT> base class and suggest another potential use for it: Social Security numbers. A Social Security number is similar to a phone number in that it is a string of numbers formatted with a limited set of characters. In the Northwind database, you did not have the option of strictly validating a phone number because you could not be sure of the specific format that the customer's country might use. A Social Security number is a different story: Two hyphens must be present at specific locations in the string. The complete <TT>CsocialSecurityNo</TT> class is defined under Listing 9.53.</P>
<H5 class="docExampleTitle">Listing 9.53 <TT>PhoneDatatypes.vb</TT>: Another Extension of the <TT>CNumberString</TT> Class, This Time for SSNs</H5>
<PRE>
Public Class CSocialSecurityNo
    Inherits CNumberString

    Public Class InvalidSSNException
        Inherits CNumberString.InvalidNumberStringException

        Sub New(ByVal pstrSSN As String)
            MyBase.New("The SSN specified, " &amp; pstrSSN &amp; ", is not valid.")
        End Sub

    End Class

    Sub New(ByVal pstrSSN As String)
        MyBase.new()
        StringValue = pstrSSN
    End Sub

    Sub New(ByVal ssn as CSocialSecurityNo)
        MyBase.New(ssn.StringValue)
    End Sub

    Public Overrides Function IsValid(ByVal pstrSSN As String) As Boolean
        If MyBase.IsValid(pstrSSN) Then

            Dim nFirstHyphen As Integer = pstrSSN.IndexOf("-")

            ' An SSN must have a hyphen at index 3 and 6.
            If nFirstHyphen = 3 Then
                If pstrSSN.IndexOf("-", nFirstHyphen + 1) = 6 Then

                    If pstrSSN.Chars(0) = "0" Then
                        Return False
                    Else
                        Return True
                    End If

                Else
                    Return False
                End If
            Else
                Return False
            End If
        End If

    End Function

    Public Overrides Function _
     ThrowException(ByVal pstrInvalidSSN As String)
     As InvalidNumberStringException
        Throw New InvalidSSNException(pstrInvalidSSN)
    End Function

    Protected Overrides Sub DefineValidChars()
        cValidChars = New String(10) {"1", "2", "3", _
         "4", "5", "6", "7", "8", "9", "0", _
         "-"}
    End Sub

End Class
</PRE>
<P>Just like the CPhoneNo example, the <TT>DefineValidChars</TT> is overridden to allow a hyphen to be valid character.</P>
<P>The real change is in the overridden <TT>IsValid</TT> method. First, the <TT>IsValid</TT> method for the base class (<TT>CNumberString.IsValid</TT>) is called to verify that the string only contains numbers and hyphens. Then, the string is checked to verify that the hyphens are in the proper location.</P>
<P>When the <TT>StringValue</TT> property is set, the overridden <TT>IsValid</TT> method in <TT>CSocialSecurityNo</TT> is called, which in turn calls the <TT>IsValid</TT> method in <TT>CNumberString</TT>.</P></span></LI></OL></span>
<H4 class="docSection2Title"> How It Works</H4>
<P>The CCustomerID example in the beginning of this section is a perfect example of encapsulation and a simple example of the goal of object-oriented code. One piece of business logic-the definition of a CustomerID and a way to determine its uniqueness and/or existence-is wrapped up in one piece of small, reusable code. Any other class that represents a table containing a CustomerID can utilize the <TT>CCustomerID</TT> class and is guaranteed to always have a valid value whose existence in the database can be verified painlessly.</P>
<P>The <TT>CNumberString</TT> class, in combination with its derived classes, extends the reusability concepts exhibited in the <TT>CCustomerID</TT> class. Inheritance might be a new concept and a new way of thinking about code, but the implementation of inheritance is simple. Any time that you inherit from another class, all the code in that base class is immediately available to you.</P>
<H4 class="docSection2Title"> Comments</H4>
<P>Inheritance is a powerful, flexible way to write code, not only quickly, but in a way that is much easier for other developers to understand. If the earlier samples make sense, you might be tempted to design extraordinarily complex object models utilizing a substantial amount of inheritance, polymorphism, and abstraction.</P>
<P>Two notes of caution:</P>
<UL>
<LI><P>There is slightly more runtime overhead with derived classes because the CLR must resolve which members of the object must actually be called. This cannot be done at compile time, because in many cases, the specific type of the object is ambiguous in static source code.</P></LI>
<LI><P>The clarity and readability of object-oriented code can be countered by an overly complex object model. Always keep it simple. If that means a bit of "editor inheritance" here and there, so be it. It's better than object-oriented spaghetti code.</P></LI>
</UL>
<ul></ul>
</body></html>
