<HTML>
<HEAD>
<TITLE>Manipulating Shapes In PowerPoint</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06c.htm" , "ch06e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="234"><h1>Manipulating Shapes In PowerPoint</h1></A>
<p>PowerPoint's programming model centers around two objects: <i>Shape</i> and <i>
TextRange</i>. Although Word and Excel each provide a <i>Shapes</i> collection object
that is consistent with PowerPoint's <i>Shapes</i> collection object, shapes
aren't the main content type in these two applications: text and cells are,
respectively. In PowerPoint, the <i>Shape</i> object is vital because all content in a presentation, including text, exists in a shape. Even if a slide has nothing but text, the text is contained in a shape of a specific type. </p>

<p>To access text, first you have to access the shape in the <i>Shapes</i> collection object on a slide, and then access the text in a shape using the <i>TextRange</i> 
object. The <i>TextRange</i> object represents a continuous area of text within a shape. The <i>TextRange</i> object, which is very similar to and nearly as robust as Word's <i>Range</i> object, allows you to retrieve or set text, as well as apply formatting to text, in any shape in a presentation. You can only access the <i>TextRange</i> object by first accessing a shape.</p>

<p>
<div class="tip"><blockquote><b>TIP</b><hr>
The code listed here that describes how to insert and manipulate
presentation content in PowerPoint is also found in the PpContnt.bas code module in the
Chapter 6 practice folder on the CD that comes with this book.</blockquote></div>
</p>

<A NAME="235"><h2>The Shapes Collection</h2></A>
<p>Each slide in a PowerPoint presentation contains a <i>Shapes</i> collection. To
access a <i>Shapes</i> collection, you first need to access a specific slide in a
presentation's <i>Slides</i> collection. A shape represents any object on a slide,
including a text box, an AutoShape, an OLE object, a picture, a table, or a chart. You
can access a <i>Shape</i> object using the <i>Shapes</i> collection or the <i>
ShapeRange</i> collection. The <i>Shapes</i> collection represents all shapes on a
slide, and a <i>ShapeRange</i> collection can represent all or a subset of shapes on a
slide. As you'll see in this section, the <i>ShapeRange</i> collection is useful in
cases where formatting is applied to multiple shapes.</p>

<A NAME="236"><h2><i>Set Properties to Multiple Shapes in a Selection</i></h2></A>
<p>The <i>ShapeRange</i> collection object usually consists of a subset of shapes that
exist in the <i>Shapes</i> collection for a particular slide. When you work with
selected shapes in the active window, you'll commonly work with the <i>
ShapeRange</i> collection. Users generally select multiple shapes and apply settings to
the shapes in the selection. Before running the following procedure, insert a number of
different shapes on the slide in the active window, such as a rectangle, <i>ActiveX</i>
control, line, WordArt, and text box. Then select all shapes and run the following
procedure from a module in the Visual Basic Editor in PowerPoint:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub SetShapeProperties()
    If ActiveWindow.Selection.Type &lt;&gt; _
        ppSelectionShapes Then Exit Sub
        
    With ActiveWindow.Selection.ShapeRange
        With .Fill
            .ForeColor.RGB = RGB(255, 0, 102)
            .OneColorGradient Style:=msoGradientHorizontal, _
                Variant:=2, Degree:=0.23
        End With
        .Line.ForeColor.RGB = RGB(200, 100, 150)
        
        With .TextFrame.TextRange
            With .Font
                .Name = &quot;Arial&quot;
                .Size = 24
                .Bold = msoTrue
                .Color.RGB = RGB(255, 255, 0)
            End With
        End With
    End With
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The preceding procedure sets properties such as fill color, fill gradient, line
border color, and font attributes to the selected shapes. Although some properties may
not apply to specific shapes in the selection, using the <i>ShapeRange</i> collection
object saves you from having to filter which shapes certain properties don't apply.
Therefore, you can write your code generically and PowerPoint will determine if the
property can or can't be applied to a specific shape in the <i>ShapeRange</i>
collection. This is the same as the course of action in PowerPoint when you select a
number of different types of shapes on a slide and click on the Fill Color button on
the Drawing toolbar or the Bold button on the Formatting toolbar.</p>

<A NAME="237"><h3>Shape Ranges</h3></A>
<p>In some cases, you may want to iterate through the selected shapes, and apply
property settings only to a specific shape. The following procedure determines if the
slide title shape is in the selection of shapes in the active window. If the slide
title shape <i>is</i> in the selection, the procedure positions the title shape back to
specific left and top coordinates. You can change the code within the nested
If&#8230;Then block to set or retrieve any property of the title shape.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub CheckIfShapeExistsInShapeRange()
    Dim shp As Shape
    If ActiveWindow.Selection.Type &lt;&gt; _
        ppSelectionShapes Then Exit Sub
    For Each shp In ActiveWindow.Selection.ShapeRange
        If shp.Type = msoPlaceholder Then
            If shp.PlaceholderFormat _
                .Type = ppPlaceholderTitle Then
                shp.Left = 53.5
                shp.Top = 36
            End If
        End If
    Next shp
End Sub
</pre>
</td></tr>
</table>
</p>

<p>This example uses the objects and properties associated with placeholders to
determine if a specific shape is found on a slide or in a selection. Placeholders are
described after the following example.</p>

<A NAME="238"><h2><i>Work with the Slide Master and Default Properties</i></h2></A>
<p>You can extend the previous example and make it more robust. To do so, set the left
and top coordinates of the slide title shape to the default position of
the title shape on the slide master of the presentation. This procedure is useful in
scenarios where you may want to reset the position of a placeholder, such as the slide
title, back to its default coordinates (based on the slide master).</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub WorkingWithSlideMaster()
    Dim shp As Shape, sldMaster As Master
    
    If ActiveWindow.Selection.Type &lt;&gt; _
        ppSelectionShapes Then Exit Sub
        
    For Each shp In ActiveWindow.Selection.ShapeRange
        If shp.Type = msoPlaceholder Then
            If shp.PlaceholderFormat _
                .Type = ppPlaceholderTitle Then
                Set sldMaster = ActiveWindow.View.Slide.Master
                With sldMaster.Shapes _
                    .Placeholders(ppPlaceholderTitle)
                    shp.Left = .Left
                    shp.Top = .Top
                End With
            End If
        End If
    Next shp
End Sub
</pre>
</td></tr>
</table>
</p>

<p>You can view the master for the slides in the presentation by clicking Master on the
View menu and then selecting Slide Master from the submenu in PowerPoint. In the
preceding procedure, you declare the variable <i>sldMaster</i> as a <i>Master</i>
object. It's set to the master of the slide in the active window. The slide title
shape's coordinates are set to the coordinates of the title shape on the slide
master. </p>

<p>Because the nested If&#8230;Then only looks for the placeholder of type
ppPlaceholderTitle, the <i>sldMaster</i> will always be set to the master that's in
view when you click Slide Master on PowerPoint's Master submenu. If the slide
layout is a title slide (see the discussion on slide layout later in the chapter), the
slide title shape would be of the placeholder type ppPlaceholderCenterTitle.</p>

<A NAME="239"><h2>Placeholders</h2></A>
<p>Placeholders are special kinds of shapes specific to PowerPoint and aren't found
in Word's or Excel's <i>Shapes</i> collection. Placeholders are tied to the
layout of a slide. For example, you commonly insert slides with either the title layout
or, more commonly, the body layout. The body layout has both a title placeholder and a
body placeholder. When you work with text and insert new slides in Outline view, slides
are created with the body layout by default. </p>

<p>Using placeholders, you can access shapes like the slide title or body placeholder
shape no matter where the placeholder shape is in the collection. When you change the
z-order of a shape on the slide, the index position of a placeholder or any other shape
in the <i>Shapes</i> collection changes. As a result, it's easier to use in your
code the <i>Placeholders</i> collection, accessed from the <i>Shapes</i> collection, to
access the most common shape elements on a slide.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub InsertSlideAndAccessPlaceholders()
    Dim sldNew As Slide
    Set sldNew = ActivePresentation.Slides _
        .Add(Index:=1, Layout:=ppLayoutText)
    With sldNew.Shapes
        .Placeholders(1) _
            .TextFrame.TextRange.Text = &quot;Ideas...&quot;
        .Placeholders(2) _
            .TextFrame.TextRange.Text = &quot;Use VBA.&quot;
        With .AddShape(msoShapeCloudCallout, _
            50, 50, 120, 100)
            .TextFrame.TextRange.Text = &quot;Thoughts?&quot;
        End With
    End With
End Sub
</pre>
</td></tr>
</table>
</p>

<p>This procedure inserts a new slide with the layout ppLayoutText. This layout
represents a slide with the title and body placeholders. You then use the <i>
Placeholders</i> collection to insert text in the title and body placeholders. The
procedure adds a new AutoShape and positions it near the top left of the body
placeholder.</p>

<A NAME="240"><h2><i>Iterate Through Title and Body Placeholders and Print to a Text File</i></h2></A>

<p>To retrieve the main text in a presentation, you usually need to access the 
title and body placeholder on a slide. Some slides, however, may not have 
the title or body placeholder. And because there are up to 16 different placeholder
PpPlaceholderType constants that represent the possible placeholder types, you may also
be searching for other placeholders on a slide. The three procedures listed in this
section work together to iterate through the slides in the active presentation and
retrieve the slide title and body placeholder text, if either exists. They print the
retrieved text to a text file under the Temp folder on the C: drive. You can change the
file path &quot;C:\Temp&quot; to an appropriate path on your machine. </p>

<p>In this example, the procedure sends the content of a PowerPoint presentation to a text
file, but you can use the content of a PowerPoint presentation to be the basis of a new
Word document. This functionality is similar to pointing to Send To on the File menu
and then clicking Microsoft Word on the submenu in PowerPoint. <A HREF="ch07a.htm">Chapter 7</A> describes the
reverse operation; that is, you use a Word document as a basis for creating a new
PowerPoint presentation. </p>

<p>The first of the following three procedures is the main one. You set the variable <i>
sOutputFile</i> to the output text file and use the Open statement to open the text
file in Output mode. The Output mode indicates that if the file exists on disk, its
content will be overwritten. The For Each&#8230;Next loop iterates through each slide in
the presentation. The first line within the For Each&#8230;Next loop prints the slide
title in the text file. The procedure retrieves the slide title by using the function
<i>SlideTitle</i>. The section &quot;<A HREF="ch06d.htm#245">Iterate Through Titles in a Presentation</A>&quot;
later in this chapter describes the <i>SlideTitle</i> function.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub PrintContentsOfPresentationToTextFile()
    Dim sld As Slide, shpBodyPlaceHolder As Shape
    Dim iFreeFile As Integer, sOutputFile As String
    sOutputFile = &quot;C:\Temp\ActivePresentationText.txt&quot;
    iFreeFile = FreeFile
    Open sOutputFile For Output As iFreeFile
        
    For Each sld In ActivePresentation.Slides
        Print #iFreeFile, SlideTitle(sld)
        If PlaceholderExists(sld.Shapes, _
            ppPlaceholderBody, shpBodyPlaceHolder) Then
            Print #iFreeFile, shpBodyPlaceHolder _
                .TextFrame.TextRange.Text
        End If
        Print #iFreeFile,
    Next sld
    
    Close #iFreeFile
    
    ' ShellExecute 0, &quot;Open&quot;, sOutputFile, &quot;&quot;, &quot;&quot;, 1
End Sub

Function PlaceholderExists(shpColl As Shapes, _
    iType As PpPlaceholderType, _
    shpPlaceHolder As Shape) As Boolean
    
    For Each shpPlaceHolder In shpColl.Placeholders
        If shpPlaceHolder.PlaceholderFormat.Type = iType Then
            PlaceholderExists = True
            Exit Function
        End If
    Next shpPlaceHolder
End Function

Function SlideTitle(sld As Slide) As String
    Dim sPrefix As String, sSlideTitle As String
    
    If sld.Shapes.HasTitle Then
        sSlideTitle = sld.Shapes.Title.TextFrame.TextRange.Text
    End If
    
    sPrefix = sld.SlideNumber &amp; &quot;. &quot;
    If Len(sSlideTitle) Then
        SlideTitle = sPrefix &amp; sSlideTitle
    Else
        SlideTitle = sPrefix &amp; &quot;Slide &quot; &amp; sld.SlideNumber
    End If
End Function
</pre>
</td></tr>
</table>
</p>

<p>After the slide title is retrieved, the If&#8230;Then block in the first procedure
then uses the <i>PlaceholderExists</i> function to determine if the body placeholder
exists. Because this function is generic, you can use it to determine if any
placeholder exists. You need to pass three arguments to the function. The first is the
<i>Shapes</i> collection of the slide you want to search on for a specific type of
placeholder; the second is the placeholder type you want to search for; and the third
is an object declared as type <i>Shape</i>. If the <i>PlaceholderExists</i> function
finds the specified placeholder type, the procedure sets the object variable <i>
shpPlaceholder</i> to the placeholder. If the placeholder exists, the procedure prints
the text contents in the body placeholder to the output text file, followed by a blank line. </p>

<p>Copy the three preceding procedures in a code module in the Visual Basic Editor in
PowerPoint, switch back to PowerPoint, and click New on the File menu. In the
Presentations tab, select a presentation that's installed on your machine. Click
OK. Switch back to the Visual Basic Editor and run the <i>
PrintContentsOfPresentationToTextFile</i> procedure. Navigate to the output text file
in the Microsoft Windows Explorer to see the results.</p>

<A NAME="241"><h3>Opening and Displaying the Output Text File from Code</h3></A>
<p>You can extend the preceding example to automatically open the text file 
after it's been closed for output. This is the same operation you saw in <A HREF="ch04a.htm">Chapter 4</A>,
where the program automatically opens the HTML document saved to disk in the Web
browser installed on your machine. The last line in the first procedure in the
preceding example contains the following line, which is commented out:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
ShellExecute 0, &quot;Open&quot;, sOutputFile, &quot;&quot;, &quot;&quot;, 1
</pre>
</td></tr>
</table>
</p>

<p>Remove the comment from the beginning of the line, and then add the following
Windows API to the top of the code module:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Declare Function ShellExecute Lib &quot;shell32.dll&quot; _
    Alias &quot;ShellExecuteA&quot; ( _
        ByVal Hwnd As Long, _
        ByVal lpOperation As String, _
        ByVal lpFile As String, _
        ByVal lpParameters As String, _
        ByVal lpDirectory As String, _
        ByVal nShowCmd As Long _
    ) As Long
</pre>
</td></tr>
</table>
</p>

<p>Run the <i>PrintContentsOfPresentationToTextFile</i> procedure again. This time, the
output text file should be opened and displayed in Microsoft Notepad. You can use this
functionality in any scenario, no matter where you write Visual Basic code.</p>

<A NAME="242"><h2>Slides</h2></A>
<p>As discussed earlier in this chapter, PowerPoint's content breakdown is similar
to Excel's. Excel organizes content in worksheets, and PowerPoint uses slides. In
PowerPoint, the <i>Slides</i> collection allows your code to iterate through and work
with specific slides in a presentation. You can also use the <i>Slides</i> collection
object to add a new slide and, hence, new content.</p>

<A NAME="243"><h2><i>Iterate Through the Slides Collection</i></h2></A>
<p>The following procedure iterates through slides in the <i>Slides</i> collection
object. The procedure assigns each slide to the variable <i>sld</i> and prints the
slide name, number, and index to the Immediate window in the Visual Basic Editor in
PowerPoint.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub IterateThroughSlides()
    Dim sld As Slide
    For Each sld In ActivePresentation.Slides
        Debug.Print &quot;Slide name: &quot; &amp; sld.Name
        Debug.Print &quot;Slide number: &quot; &amp; sld.SlideNumber
        Debug.Print &quot;Slide Index: &quot; &amp; sld.SlideIndex
    Next sld
End Sub
</pre>
</td></tr>
</table>
</p>

<p>By default, PowerPoint gives a new name to each slide created, although there's
no way to change a slide's name through the menus, toolbars, or dialog boxes. You
can only do that by setting the Name property through Visual 
Basic code. You can also use the value returned by the Name property as the <i>
index</i> argument in the Slides(<i>index</i>) property on the <i>Presentation</i>
object so that your code can return a specific <i>Slide</i> object. 

<p>The SlideIndex property returns a number representing the position of 
the slide in the <i>Slides</i> collection. The SlideIndex number is directly related to
the position of the slide on screen. The Name property returns the name of the slide.
The SlideNumber property on the <i>Slide</i> object returns the slide number visible on
the slide. You can set the slide number in PowerPoint by selecting the Slide number
check box in the Slide tab of the Header and Footer dialog box. You can access this
dialog box by clicking Header and Footer on the View menu.</p>

<A NAME="244"><h2><i>Insert Slides</i></h2></A>
<p>You use the <i>Add</i> method of the <i>Slides</i> collection to insert a new slide
in the presentation. The <i>Add</i> method takes two arguments, <i>Index</i> and <i>
Layout</i>, and you need both. The <i>Index</i> argument represents the position of the
new slide in the <i>Slides</i> collection. If you want to add the slide to the end of
the <i>Slides</i> collection, you need to set the <i>Index</i> argument to the number
of the slides in the collection plus one. The code would appear as:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
With ActivePresentation.Slides
    Set sldNew = .Add(Index:=.Count + 1, _
        Layout:=ppLayoutText)
End With
</pre>
</td></tr>
</table>
</p>

<p>If you want to insert a new slide at the end of the <i>Slides</i> collection,
replace the Set sldNew statement in the following procedure with the With&#8230;End block above.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub InsertSlide()
    Dim sldNew As Slide
    Set sldNew = ActivePresentation.Slides _
        .Add(Index:=1, Layout:=ppLayoutText)
    With sldNew
        .Shapes(1).TextFrame.TextRange.Text = &quot;Ideas...&quot;
        .Shapes(2).TextFrame.TextRange.Text = &quot;Use VBA.&quot;
        With .Shapes.AddShape(msoShapeCloudCallout, _
            50, 50, 120, 100)
            .TextFrame.TextRange.Text = &quot;Thoughts?&quot;
        End With
    End With
End Sub
</pre>
</td></tr>
</table>
</p>

<p>
<A HREF="javascript:fullSize('G06ovb03x.htm')"> <img src="images/G06ovb03.JPG" width=404 height=241 border=0 ALT = "Click to view at full size."> </A>
</p>


<p>The <i>Layout</i> argument allows your code to specify the slide layout for the new
slide. Every slide in PowerPoint has a slide layout. You need to set a <i>
Layout</i> argument to a PpSlideLayout constant. When you insert a new slide in PowerPoint by
clicking New Slide on the Insert menu in PowerPoint's application window, the New
Slide dialog box displays all the possible slide layouts. The name of the layout
appears at the right in the dialog box. Most layout names in the dialog box are similar
to their associated PpSlideLayout constant. In the preceding procedure, the
PpSlideLayout constant ppLayoutText represents the Bulleted List layout in the New Slide dialog box.</p>

<A NAME="245"><h2><i>Iterate Through Titles in a Presentation</i></h2></A>
<p>A slide's title and body placeholder are two elements you'll commonly find
on slides. The slide title is commonly used to display a list of <i>Slides</i> in a
presentation. The following procedure allows you to return a list of slide titles
exactly like the list you'll find in the Slide Navigator in Slide Show. In Slide
Show view, right-click on the slide, click Go, and click Slide Navigator on the
submenu. </p>

<p>
<img src="images/G06ovb04.JPG" width=238 height=291 border="0">
</p>


<p>You can also see a list of slide titles in the Insert Hyperlink dialog box by
clicking Hyperlink on the Insert menu and then selecting Place in This Document on the
Link To bar at the left of the dialog box. In the Visual Basic Editor in PowerPoint,
run the following procedure. The list of slide titles is printed in the Immediate
window.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub RetrieveSlideTitleList()
    Dim sld As Slide
    Dim sPrefix As String, sSlideTitle As String
    
    For Each sld In ActivePresentation.Slides
        If sld.Shapes.HasTitle Then
            sSlideTitle = sld.Shapes.Title _
                .TextFrame.TextRange.Text
        End If
        
        sPrefix = sld.SlideNumber &amp; &quot;. &quot;
        If Len(sSlideTitle) Then
            Debug.Print sPrefix &amp; sSlideTitle
        Else
            Debug.Print sPrefix &amp; &quot;Slide &quot; &amp; _
                sld.SlideNumber
        End If
    Next sld
End Sub
</pre>
</td></tr>
</table>
</p>

<p>PowerPoint provides a shortcut that allows you to easily determine if a slide title
exists and if so, to access the title shape. Instead of using the Shapes<i>(Index)</i>
property on the <i>Slide</i> object or the Placeholders(Index) property on the <i>
Shapes</i> collection object to return the slide title, you can use the Title property
on the <i>Shapes</i> object. This property provides a shortcut to the Title shape.</p>

<p>Even though the majority of slides have a slide title, some may not. Either the
slide layout is blank (ppSlideLayoutBlank) or the user deleted the slide title shape.
Therefore, before you access the slide title shape using the Title property on the <i>
Shapes</i> object, your code should first use the HasTitle property. If the slide does
have a title, the string variable <i>sSlideTitle</i> is set to the text of the slide
title shape. The If&#8230;Then&#8230;Else block determines if the length of text assigned
to the variable <i>sSlideTitle</i> is greater than zero. If so, the procedure prints
the slide title to the Immediate window. If not, it prints the slide number to the
Immediate window.</p>

<A NAME="246"><h2>Handling Text</h2></A>
<p>In a PowerPoint presentation, all text has to exist in a shape. The <i>TextRange</i>
object allows you to insert or manipulate text content in a shape. You can set the <i>
TextRange</i> object so that it represents all or only a portion of a range of text. A
<i>TextRange</i> object can consist of text that represents a single paragraph (a
bulleted list item, for example) or all text in a shape (such as all bulleted
items). </p>

<p>Within every <i>TextRange</i> object, you can return more granular units of
text&#8212;just as you can in Word with the <i>Range</i> object. The <i>TextRange</i>
object allows you to iterate through units of text as large as all the text in a shape
and as small as a paragraph (usually a bulleted item), a sentence, a word, and,
finally, a character. The <i>TextRange</i> object in PowerPoint is equivalent in
purpose to the <i>Range</i> object in Word. Many methods and properties on both of
these objects are similar as well.</p>

<A NAME="247"><h2><i>Determine If a Shape Can Contain Text and Set Bullets of Unindented Items</i></h2></A>
<p>You can't apply a number of properties on the <i>Shape</i> or <i>ShapeRange</i>
object to all shapes. You can use the Paragraphs, Sentences, Words, or Character
properties on the <i>TextRange</i> object to return the collection of paragraphs,
sentences, words, or characters from a range of text. However, you can't access the
text range on shapes like a line, WordArt, bitmap placeholder, or <i>ActiveX</i>
control. Before you try to access text in a range of shapes&#8212;in a selection, for
example &#8212;you need to determine if a shape can contain text. </p>

<p>To access text, you need to first access the <i>TextFrame</i> object. In hierarchical
object terms, a <i>Shape</i> object contains a <i>TextFrame</i>. The <i>TextFrame</i>
contains a <i>TextRange</i> object that actually represents text. Some shapes don't
contain 
a <i>TextFrame</i> object. To determine if a shape does contain one, and therefore can
contain text, you can use the HasTextFrame property on the <i>Shape</i> object.
Thereafter, if a shape does contain text, you can access the text in the shape and set
its properties.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub IterateParagraphsAndSetBullets()
    Dim para As TextRange
    Dim shp As Shape, iCount As Integer
    
    If ActiveWindow.Selection.Type &lt;&gt; _
        ppSelectionShapes Then Exit Sub
    For Each shp In ActiveWindow.Selection.ShapeRange
        If shp.HasTextFrame Then
            iCount = 0
            
            For Each para In shp.TextFrame _
                .TextRange.Paragraphs
                If para.IndentLevel = 1 Then
                    With para.ParagraphFormat.Bullet
                        If .Type &lt;&gt; ppBulletNone Then 
                           .Font.Name = &quot;Arial&quot;
                           .RelativeSize = 0.75
                           iCount = iCount + 1
                           .Character = 48 + iCount
                        End If
                   End With
               End If
            Next para
            
        End If
    Next shp
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Before running this procedure, insert different shapes on the active slide, such as
a line, an <i>ActiveX</i> control, some WordArt, and a rectangle. Add text to the
rectangle, the title, and the body placeholder, if they exist. Select all shapes on the
slide and then run the procedure. Make sure that the body text is bulleted. The
procedure determines if the selection in the active window is a range of shapes. If so,
the first For Each&#8230;Next loop iterates through the shapes in the selected shape
range. If the shape contains a text frame, the nested For Each&#8230;Next loop iterates
through the paragraphs in the text range of the selected shape. </p>

<p>The If&#8230;Then statement evaluating the bullet Type property is used to 
determine if there is a bullet visible for the paragraph. If there is, then the
For&#8230;Each loop proceeds to add a number as the bullet. If a bullet does not exist,
the bullet of the paragraph is unaffected. Every bulleted item in a shape, including
those that are indented below a main bulleted item, is considered a paragraph. You
access the list of bulleted items by using the Paragraphs property on the <i>
TextRange</i> object. The Paragraphs property returns the collection of paragraphs in
the text range of a shape. You can use the IndentLevel property to return specific
paragraphs in a shape. The preceding procedure sets the bullet character to a number if
the bullet exists for the paragraph. This procedure mimics the functionality of
automatically numbering bulleted items in a shape.</p> 

<p>
<A HREF="javascript:fullSize('G06ovb05x.htm')"> <img src="images/G06ovb05.JPG" width=404 height=304 border=0 ALT = "Click to view at full size."> </A>
</p>


<A NAME="248"><h2><i>Navigate Through the Units of Text</i></h2></A>
<p>Unlike in Word, in PowerPoint your code can only navigate down the text
&quot;hierarchy&quot; tree. For example, if you select a bulleted item on a slide in
the active window, you can access the sentence, word, and character collections in the
bulleted item. However, if you had selected a word, you cannot return the sentence or
paragraph the word belonged to. The <i>Range</i> object in Word, on the other hand,
allows you to return the paragraph where a range of text, such as a word, is
contained. </p>

<p>The following procedure prints to the Immediate window in the Visual Basic Editor in
PowerPoint the first paragraph, sentence, and word of a text selection. For example, in
a body placeholder on a slide, type in two bulleted items where the first item has two
or more sentences. Select all of the text in the shape and then run the following
procedure in a module in the Visual Basic Editor.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub NavigateDownTextHierarchy()
    Dim rng As TextRange
    If ActiveWindow.Selection.Type = ppSelectionText Then
        Set rng = ActiveWindow.Selection.TextRange
        Debug.Print rng.Paragraphs(1)
        Debug.Print rng.Sentences(1)
        Debug.Print rng.Words(1)
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="249"><h2><i>Iterate Through Words</i></h2></A>
<p>PowerPoint is similar to Word in that a unit of text representing a word consists of
the text of the word followed by the space between the text and the next word. If you
double-click on a word in a Word document or in a shape in PowerPoint, the text and the
space after the text is highlighted. The same principle holds for sentences. A sentence
in Word and PowerPoint consists of the sentence's text followed by the space
between the period and the next sentence. A paragraph includes the text, space after
the end of the text (if any), and the paragraph marker.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub SpaceAfterTextUnits()
    Dim rng As TextRange
    If ActiveWindow.Selection.Type = ppSelectionText Then
        Set rng = ActiveWindow.Selection.TextRange
        Debug.Print rng.Words(1) &amp; Chr(34)
        Debug.Print rng.Words(1).TrimText &amp; Chr(34)
        Debug.Print rng.Sentences(1) &amp; Chr(34)
        Debug.Print rng.Paragraphs(1) &amp; Chr(34)
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Before running this procedure, add text to a body placeholder and add two sentences
to the first bulleted item. Select all text in the bulleted item and run the procedure.
The procedure prints the text of the first word, sentence, and paragraph (which
represents the bulleted item) to the Immediate window, followed by a quote. <font face="courier new" size="-1">Chr(34)</font>
represents the quote character (&quot;), which allows you to see the spaces after each
unit of text. </p>

<p>Unlike in Word, in PowerPoint you can use the TrimText property to remove all spaces
and paragraph markers before and after a unit text. The built-in <i>Trim$</i> function
in the Visual Basic for Applications language works only for removing spaces before and
after a text string. The TrimText property in PowerPoint also removes paragraph markers
after, for example, a sentence or paragraph. The TrimText property is useful when you
retrieve the last paragraph in a shape and don't want the paragraph marker along
with the text.</p>

<A NAME="250"><h2><i>Insert Paragraphs</i></h2></A>
<p>When you build presentation content programmatically, you commonly have to insert
paragraphs. PowerPoint, like Word, provides two convenient methods for creating a new
paragraph before or after an existing one: <i>InsertBefore</i> and <i>InsertAfter</i>.
When you access a range representing an existing paragraph or the beginning or end of
one, you can use either of these two methods to insert a new paragraph. </p>

<p>The following procedure assumes that the active presentation contains at least two
slides and two shapes on the second slide. The procedure also assumes that the second
shape on the second slide has at least two bulleted items. The code inserts a new
paragraph at the end of the text range in the shape using the <i>InsertAfter</i> method
on the <i>TextRange</i> object. The <i>InsertAfter</i> method takes one argument
representing the new text to be added in the new paragraph. This procedure adds a new
paragraph after the first paragraph in the shape. Note that in the text string assigned
to the variable <i>sNewPara</i>, a carriage return, represented by <font face="courier new" size="-1">Chr(13)</font>, is added to
the end of the text. When the text string is set to the new paragraph, the carriage
return ensures that the new paragraph is separate from the paragraph after the new
paragraph.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub InsertNewParagraphBetweenParagraphs()
    Dim shp As Shape, rngText As TextRange
    Dim sNewPara As String
    
    sNewPara = &quot;New paragraph between items.&quot; &amp; Chr(13)
    Set shp = ActivePresentation.Slides(2).Shapes(2)
    With shp.TextFrame.TextRange.Paragraphs(1)
        Set rngText = .InsertAfter(NewText:=sNewPara)
        rngText.Font.Italic = msoTrue
        rngText.IndentLevel = 2
    End With
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Another very common task in programming solutions is to insert content at the end of
text in the body placeholder or any shape. The following procedure inserts text at the
end of a text range using the <i>InsertAfter</i> method. However, in this case it adds
the carriage return character at the beginning of the text string assigned to the
string variable <i>sNewPara</i>.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub InsertNewParagraphAtEndOfTextRange()
    Dim shp As Shape, rngText As TextRange
    Dim sNewPara As String
    
    sNewPara = Chr(13) &amp; &quot;New paragraph.&quot;
    Set shp = ActivePresentation.Slides(2).Shapes(2)
    With shp.TextFrame.TextRange
        Set rngText = .InsertAfter(NewText:=sNewPara)
        rngText.Font.Italic = msoTrue
    End With
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="251"><h2>Tables</h2></A>
<p>PowerPoint 2000 is the first version of PowerPoint that offers a way of creating
tables that's similar to the functionality provided by the Draw Table command on
Word's Tables And Borders toolbar. The following two procedures create a simple
five-row by three-column table. They create the table on a new slide inserted at the
end of the <i>Slides</i> collection in the active presentation. You should note that
your code can insert a table that has up to 25 rows and 25 columns. This is also the
row and column limit that's set when you create the table using the Tables And
Borders toolbar.</p>

<A NAME="252"><h2><i>Insert Tables</i></h2></A>
<p>First you set the new table to the <i>Table</i> variable <i>tbl</i>. PowerPoint
doesn't provide the ability to apply predefined formats to your table as Word does
using the Table AutoFormat on the Table menu. Since you can't format a table with a
preset 
table format, you need to explicitly format the table through code. You do this by
using the <i>SetTableFormatting</i> procedure. You call the procedure <i>
InsertTableData</i> to fill the second and third columns with random values after you
apply formatting. </p>

<p>As described in this chapter's Word and Excel table examples, you could, for
example, replace the code in <i>InsertTableData</i> with code that accesses data in an
Access database.</p>

<p>
<div class="note"><blockquote>
<b>NOTE</b><hr>
The result of the table appears in the following graphic. Note
the formatting applied to specific sets of cells. For example, the text in the first
row is bold and italicized. The text in the first column is left aligned, while the
text in the second and third columns is center aligned.</blockquote></div>
</p>

<p>
<A HREF="javascript:fullSize('G06ovb06x.htm')"> <img src="images/G06ovb06.JPG" width=404 height=304 border=0 ALT = "Click to view at full size."> </A>
</p>


<p>
<div class="note"><blockquote>
<b>NOTE</b><hr>
The code to create this table is listed below and is also found
in the PpContnt.bas code module under the Chapter 6 practice folder on the CD that
comes with this book. Also note that the first two lines in the code belong at the top
of the standard code module. If Option Explicit is already listed at the top of your
code module, you do not need to type it again. However, the module-level variable, <i>
m_sldSales,</i> is used in the other procedures listed below.</blockquote></div>
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Option Explicit
Dim m_sldSales As Slide

Sub InsertTable()
    Dim tbl As Table
    Dim iNumOfRows As Integer, iNumOfColumns As Integer
    
    ' create new slide and add title text
    With ActivePresentation
        Set m_sldSales = .Slides.Add( _
            Index:=.Slides.Count + 1, _
            Layout:=ppLayoutTitleOnly)
    End With
    m_sldSales.Shapes.Title.TextFrame _
        .TextRange = &quot;Q2 Sales: Increase (%)&quot;

    ' insert table
    iNumOfRows = 5: iNumOfColumns = 3
    Set tbl = m_sldSales.Shapes.AddTable(iNumOfRows, _
        iNumOfColumns, 54, 156, 612, 324).Table
    
    SetHeadingRowText tbl
    SetFirstColumnText tbl
    InsertTableData tbl
End Sub

Sub InsertTableData(tbl As Table)
    ' fill cells with random data
    Dim x As Integer, y As Integer
    For x = 2 To tbl.Rows.Count
        For y = 2 To tbl.Columns.Count
            tbl.Cell(x, y).Shape.TextFrame.TextRange _
                .Text = Format$(Rnd(), &quot;###0.00&quot;)
        Next y
    Next x
End Sub
</pre>
</td></tr>
</table>
</p>

<p>
<div class="warning"><blockquote>
<b>IMPORTANT</b><hr>
When you select a set of cells in a table on a slide and
click on the Bold button on the Formatting toolbar, for example, PowerPoint applies
formatting to all cells in the selection. However, PowerPoint doesn't allow you to
mimic the same behavior through code. You have to explicitly create a shape range of
cells and apply formatting to the set of cells. The code provides a good structure to
apply formatting to a specific set of cells in a table. The remaining procedures are
called from the preceding <i>SetTableFormatting</i> procedure. 

<p>The <i>GetRowArray</i>, <i>GetColumnArray</i> and <i>GetTableCellArray</i> procedures
return an array used to create a collection of shapes within a <i>ShapeRange</i>
object. Using the <i>ShapeRange</i> object, you can apply formatting to all cells at
once. The <i>GetRowArray</i> and <i>GetColumnArray</i> procedures are designed to allow
your code to specify what row or column of table cells should be returned as a shape
range. The procedures also allow your code to specify if the shape range of a row or
column of cells should skip the first cell. For example, if the first cell in a column
is part of a heading row, you may want to skip formatting the cell like the others in a
column.</p></blockquote></div>
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub SetHeadingRowText(tbl As Table)
    tbl.Cell(1, 1).Shape.TextFrame _
        .TextRange.Text = &quot;Region&quot;
    tbl.Cell(1, 2).Shape.TextFrame _
        .TextRange.Text = &quot;Projected&quot;
    tbl.Cell(1, 3).Shape.TextFrame _
        .TextRange.Text = &quot;Actual&quot;
End Sub
Sub SetFirstColumnText(tbl As Table)
    tbl.Cell(2, 1).Shape.TextFrame _
        .TextRange.Text = &quot;Northwest&quot;
    tbl.Cell(3, 1).Shape.TextFrame _
        .TextRange.Text = &quot;Northeast&quot;
    tbl.Cell(4, 1).Shape.TextFrame _
        .TextRange.Text = &quot;Southwest&quot;
    tbl.Cell(5, 1).Shape.TextFrame _
        .TextRange.Text = &quot;Southeast&quot;
End Sub
</pre>
</td></tr>
</table>
</p>

<p><div class="sidebar"><blockquote> 
<b>Table Cell Borders in PowerPoint </b>
<p>Because tables are a group of shapes, you can use the <i>Shape</i> object to manipulate
cell formatting such as the line format of the shape representing a cell. You should
not, however, use the <i>LineFormat</i> of the <i>Shape</i> object to manipulate the
borders of a cell in a table. Doing so results in unpredictable behavior for the
borders of a cell. Instead, use the Borders property of the <i>Cell</i> object, which
can be accessed from the <i>Table</i> object.</p>

<p>The following procedure uses the Borders property to remove the left and
right border for each cell in the table created by the previous set of procedures. For
the following procedure to work, you need to make sure you select the entire table,
switch back to the Visual Basic Editor in PowerPoint, insert the cursor in the
procedure, and then press <font size="-2">F5</font> to run it.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub TableCellBorders()
    Dim tbl As Table
    Dim iRow As Integer, iCol As Integer
    
    Set tbl = ActiveWindow.Selection.ShapeRange.Table
    For iRow = 1 To tbl.Rows.Count
        For iCol = 1 To tbl.Columns.Count
            With tbl.Cell(iRow, iCol)
                .Borders(ppBorderLeft).Visible = msoFalse
                .Borders(ppBorderRight).Visible = msoFalse
            End With
        Next iCol
    Next iRow
End Sub
</pre>
</td></tr>
</table>
</p>
</blockquote></div></p>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>






