<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>Repeating Actions with Loops</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02d.htm" , "ch02f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="63"><h1>Repeating Actions with Loops</h1></A>
<p>You'll often find occasions where you'll want to continually change a value
and run some code repeatedly with the incremented value. At other times you'll want
to delay running code until the value of a variable meets certain conditions. In Visual
Basic, looping structures come in a variety of options to suit either case.</p>

<A NAME="64"><h2><i>Count with For&#8230;Next</i></h2></A>
<p>The For&#8230;Next loop both runs a block of code repeatedly and incrementally
increases or decreases a variable you specify. The incremental changes in value to the
variable can be in steps with positive or negative integers. By default, the
incremental step value is +1.</p>

<ol>
<p><li> Create a new procedure called <i>ForNext</i>.</li></p>

<p><li> Within the procedure, declare the two integers i and iTotal by adding the
following two lines of code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Dim iTotal As Integer
Dim i As Integer
</pre>
</td></tr>
</table>
</p>

<p><li> Add the following For&#8230;Next loop:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
For i = 1 To 5
    iTotal = iTotal + i ^ 2
Next i
</pre>
</td></tr>
</table>
</p>

<p>The For&#8230;Next loop increments the integer variable <i>i</i> by a value of 1.
The loop has a range from 1 to 5. Thus, <i>i</i> is initially assigned a value of 1 the
first time the loop runs, and then in the following loop <i>i</i> has a value of 2, and
so on. The variable <i>iTotal</i> is used to sum the square of each of the values from
1 to 5 (the range of the For...Next loop).</p>

<p><li> Add a message box after the For&#8230;Next loop to display the final value
of the variable <i>iTotal</i> by adding the following line of code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
MsgBox iTotal
</pre>
</td></tr>
</table>
</p>

<p>The complete procedure should look like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub ForNext()
     Dim iTotal As Integer    
     Dim i As Integer
     For i = 1 To 5
        iTotal = iTotal + i ^ 2
    Next i
    MsgBox iTotal
End Sub
</pre>
</td></tr>
</table>
</p>

<p><li> Press <font size="-2">F5</font>.</li></p>

<p>The final value of <i>iTotal</i> is 55. The line within the loop, 
<font face="courier new" size="-1">iTotal = iTotal + i ^ 2</font>, adds the square of the numbers between 1 and 5 (that is, 1 + 4 + 9 + 16 +
25).</p>
</ol>

<p>
<div class="note"><blockquote>
<b>NOTE</b><hr>
You could also step backward by setting the range from 5 to 1
and adding the keyword Step and -1 just after the range. The resulting code would look
like this: 

<p><table cellpadding=5><tr><td>
<PRE>For i = 5 To 1 Step -1</PRE>
</td></tr></table></p>

<p>The variable <i>i</i> is initially assigned a value of 5, then 4, then 3, and so on.
In this case, stepping through backward would produce the same result as the procedure
you wrote.</p>
</blockquote></div>
</p>

<A NAME="65"><h2><i>Step Out Early</i></h2></A>
<p>If you want to exit the loop when the value of <i>iTotal</i> is greater than 5, you
can add an If&#8230;Then condition within the loop. If the condition is met, Visual
Basic will exit the For&#8230;Next loop.</p>

<ol>
<p><li> In the procedure you just created, add the following If&#8230;Then
condition block within the For&#8230;Next loop, just after the line <font face="courier new" size="-1">iTotal = iTotal + i
^ 2</font>:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
If iTotal &gt; 5 Then
    MsgBox i
    Exit For
End If
</pre>
</td></tr>
</table>
</p>

<p>The code <font face="courier new" size="-1">Exit</font> For tells Visual Basic to exit the For&#8230;Next loop that's
currently running. The message box just before the Exit For statement shows the value
of iCount just before exiting the loop.</p>

<p><li> Press <font size="-2">F5</font>.</li></p>

<p>Now you'll see two message boxes. The first shows the value of the counter <i>
i</i> used in the For&#8230;Next loop, which is 3. The second displays the value of <i>
iTotal</i>, which is 14. Once you jump from a loop, you usually continue with an action
right after the loop and use the values altered in the loop in the following
actions.</p>
</ol>

<A NAME="66"><h2>Using the Do&#8230;Loop</h2></A>
<p>The Do&#8230;Loop structure continues to run code within the loop structure until a
certain condition is met. Unless you specify a condition for exiting or stopping a
Do&#8230;Loop structure, it loops without stopping. You can specify such a condition in
three ways: repeat until something changes, continue while things are the same, and
leave a loop early.</p>

<A NAME="67"><h2><i>Repeat Until Something Changes</i></h2></A>
<p>The first way to exit a loop structure is to add the keyword Until after the word
Loop and then specify the condition.</p>

<ol>
<p><li> Create a procedure called <i>DoLoopUntil</i>.</li></p>

<p><li> Declare the variable <i>iCount</i> as an integer and create a
Do&#8230;Loop structure by adding the following lines of code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Dim iCount As Integer
Do
    iCount = iCount + 2
Loop Until iCount &gt; 100
</pre>
</td></tr>
</table>
</p>

<p>In the Do&#8230;Loop structure, the program increments the variable <i>iCount</i> by
a value of 2 each time through the loop. When the value of <i>iCount</i> is greater
than 100, the loop exits.</p>

<p><li> Just after the line <font face="courier new" size="-1">iCount = iCount + 2 </font>in the Do&#8230;Loop structure,
add the following:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Debug.Print iCount
</pre>
</td></tr>
</table>
</p>

<p>During each successive loop, <font face="courier new" size="-1">Debug.Print</font> prints the value of <i>iCount</i> in the
Immediate window so you can see <i>iCount</i> being incremented.</p>

<p><li> If the Immediate window isn't displayed, in the Visual Basic Editor,
on the View menu, click Immediate Window (or press <font size="-2">CTRL+G</font> as a shortcut).</li></p>

<p><li> Add a message box after the Do&#8230;Loop structure indicating that the
loop has finished:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
MsgBox &quot;The loop has finished.&quot;
</pre>
</td></tr>
</table>
</p>

<p>The complete procedure should look like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub DoLoopUntil()
    Dim iCount As Integer
    Do
        iCount = iCount + 2
        Debug.Print iCount
    Loop Until iCount &gt; 100
    MsgBox &quot;The loop has finished.&quot;
End Sub
</pre>
</td></tr>
</table>
</p>

<p><li> Press <font size="-2">F5</font> to run the procedure.</li></p>
</ol>

<A NAME="68"><h2><i>Continue While Things Are the Same</i></h2></A>
<p>The second way to exit a Do&#8230;Loop structure is to add the keyword While after
the word Loop and then specify the condition.</p>

<ol>
<p><li> In the Do&#8230;Loop structure you just created, delete the line <font face="courier new" size="-1">Loop
Until iCount &gt; 100 </font>and replace it with:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Loop While iCount &lt;= 100
</pre>
</td></tr>
</table>
</p>

<p><li> Press <font size="-2">F5</font>. The procedure performs like the one in the previous
example.</li></p>
</ol>

<p>If you closely compare the logic of the Until condition and the While condition,
you'll see that they specify the same condition and produce the same result.</p>

<p>
<div class="warning"><blockquote>
<b>IMPORTANT</b><hr>
In both previous cases, you could place the keywords <i>
Until</i> and <i>While</i> (plus the condition following them) after the word <i>Do</i>
instead of <i>Loop</i>. You can type <b>Until</b> or <b>While</b> after the word <i>
Do</i> or after the word <i>Loop,</i> but not after both words in one procedure. The
difference this makes to your code is that if you place <i>Until</i> and <i>While</i>
after the word <i>Loop,</i> the program evaluates the statements at least once before
reaching the Until or While condition. If you place them after the word <i>Do,</i> the
program evaluates the condition following the keyword <i>Until</i> or <i>While</i>
immediately, before any lines within the Do&#8230;Loop structure run. If the condition
is false, the program won't execute the loop at all. For more information, in the
Visual Basic Editor, ask the Assistant for help using the words &quot;Using Do...Loop
Statements.&quot;</blockquote></div>
</p>

<A NAME="69"><h2><i>Exit a Loop Early</i></h2></A>
<p>The third way to exit a Do&#8230;Loop structure is to use only a condition statement
in the lines of code within the Do&#8230;Loop structure.</p>

<ol>
<p><li> In the Do&#8230;Loop structure, delete the line <font face="courier new" size="-1">Loop While Count &lt;= 100</font>
and replace it with the following If&#8230;Then condition and Loop statements:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
If iCount &gt; 100 Then Exit Do
Loop
</pre>
</td></tr>
</table>
</p>

<p>The complete procedure looks like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Sub DoLoopUntil()
    Dim iCount As Integer
    Do
        iCount = iCount + 2
        Debug.Print iCount
        If iCount &gt; 100 Then Exit Do
    Loop
    MsgBox &quot;The loop has finished.&quot;
End Sub
</pre>
</td></tr>
</table>
</p>

<p><li> Press <font size="-2">F5</font>. The procedure performs the same as the ones in the two
preceding examples.</li></p>

<p><li> Exit PowerPoint.</li></p>
</ol>

<A NAME="70"><h2>Parsing Filenames with For&#8230;Next</h2></A>
<p>You may find that your program handles files and filenames in many scenarios. For
example, your program may prompt the user to specify a filename under which information
will be saved. To verify that the specified pathname of the filename is valid, you need
to parse the filename string for the pathname. To <i>parse</i> means to separate into
more easily processed components (groups of characters, in this case) and to analyze
them. The section <A HREF="ch04b.htm#119">File Management</A>  in Chapter 4 describes more ways to parse all parts
of a filename. The following example examines one way to parse any text string (in this
case, a file name).</p>

<A NAME="71"><h2><i>Parse Filenames</i></h2></A>
<p>Once you develop a function to extract the pathname from a filename string, you use
the debugging tools of the Visual Basic Editor to step through each line of code and
see the different values assigned to variables.</p>

<ol>
<p><li> Open the Visual Basic Editor in any Microsoft Office application. (The
following code and steps work identically in each application.)</li></p>

<p><li> Insert a new code module. In the Code window, type <b>Sub
ParseFileName</b> and press <font size="-2">ENTER</font> to create a new procedure.</li></p>

<p><li> Add the following line of code to the procedure:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
MsgBox GetPath(&quot;C:\Temp\Test.txt&quot;)
</pre>
</td></tr>
</table>
</p>

<p>The string value you specified as the first argument of the MsgBox statement is the
value returned from the function <i>GetPath</i>. (<i>GetPath</i> is a <i>Function</i>
procedure that you'll create in the steps below. Recall that a <i>Function</i>
procedure is like a <i>Sub</i> procedure except that it returns a value.) <i>
GetPath</i> takes one string argument, representing the filename. In this case, the
value you pass to the <i>GetPath</i> function is &quot;C:\Temp\Test.txt&quot;, which
does not necessarily exist on your system but is used as a test to verify that the <i>
GetPath</i> function works.</p>

<p><li> Below the End Sub statement of the <i>ParseFileName</i> procedure, add a
blank line by pressing <font size="-2">ENTER</font>. Create a new function by typing <b>Function
GetPath(sFileName As String) As String</b> and pressing <font size="-2">ENTER</font>.</li></p>

<p>The function <i>GetPath</i> accepts an argument, <i>sFileName</i>, which is
declared as a String data type. The <i>GetPath</i> function is itself declared as a
String data type, which indicates that you assign a string to <i>GetPath</i>. By
default, the value of <i>GetPath</i> is initially an empty string, or
&quot;&quot;.</p>

<p><li> Within the <i>GetPath</i> function, add the following declaration
statements:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Dim sChar As String, i As Integer
</pre>
</td></tr>
</table>
</p>

<p><li> After the declarations in the <i>GetPath</i> function, add the following
For&#8230;Next loop:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
For i = Len(sFileName) To 1 Step _1
Next i
</pre>
</td></tr>
</table>
</p>

<p>Because you specify the Step keyword and a step value at the end of the For
statement, the loop iterates from the value representing the length of the string
sFileName down to 1. The Visual Basic function <i>Len</i> is built into the Visual
Basic language. The <i>Len</i> function returns the number of characters in the string
you specify. In this case, the variable <i>sFileName</i>, or
&quot;C:\Temp\Test.txt&quot;, is the string value, and its length is 16.</p>

<p><li> Within the For&#8230;Next loop, add the following line:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
sChar = Mid$(sFileName, i, 1)
</pre>
</td></tr>
</table>
</p>

<p>The program assigns the variable <i>sChar</i> to the value returned by the Visual
Basic built-in <i>Mid$</i> function. The <i>Mid$</i> function accepts three arguments:
<i>string</i>, <i>start</i>, and <i>length</i>. The arguments are used to return a
specified number of characters from the string. The <i>string</i> argument represents
the string from which you want to extract a subset of characters. The <i>start</i>
argument specifies the character position in the string at which to start extracting
characters. The <i>length</i> argument indicates the number of characters to
extract.</p>

<p>In the preceding <i>Mid$</i> function, Visual Basic extracts one character from the
string value represented by sFileName, or &quot;C:\Temp\Test.txt&quot;, starting from
the position i. The value of i is set by the For&#8230;Next loop.</p>


<p><li> After the <i>Mid$</i> function, add the following If&#8230;Then condition
block:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
If sChar = &quot;\&quot; Then
End If
</pre>
</td></tr>
</table>
</p>

<p>The If&#8230;Then condition block indicates that if the string sChar equals a
backslash, the statements within the block run.</p>

<p><li> Within the If&#8230;Then condition block, add the following two
lines:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
GetPath = Left$(sFileName, i - 1)
Exit For
</pre>
</td></tr>
</table>
</p>

<p>Although the Visual Basic function <i>Left$</i> is similar to the <i>Mid$</i>
function, it accepts only two arguments: <i>string</i> and <i>length</i>. The <i>
Left$</i> function extracts the number of characters specified by the <i>length</i>
argument, starting at the left end of the string.</p>

<p>When you enter the If&#8230;Then condition block, you assign to the <i>GetPath</i>
function the pathname (the pathname is a subset of the filename previously passed to
the <i>GetPath</i> function) and the For&#8230;Next loop exits.</p>

<p><li> Place the cursor in the <i>ParseFileName</i> procedure and press <font size="-2">F5</font>.</li></p>

<p>You'll see a message box with the string value &quot;C:\Temp&quot;. The <i>
GetPath</i> function iterates through the specified filename string, evaluating each
character in the filename string, starting from the right-most character and working
backward. When it finds a character equal to a backslash, it extracts the characters to
the left of the backslash in the filename string, which indicates the pathname. The
pathname is assigned to <i>GetPath</i>, and a message box displays the result of <i>
GetPath</i>.</p>
</ol>

<p>
<div class="tip"><blockquote><b>TIP</b><hr>
If you want to extract only the portion of the filename without
the path in the string &quot;C:\Temp\Test.txt&quot;, you can change the line with the
<i>Left$</i> function to the following: <font face="courier new" size="-1">GetPath = Right$(sFileName, Len(sFileName) -
i)</font>. The <i>Right$</i> function is similar to the <i>Left$</i> function, but it extracts
the number of characters specified by the <i>length</i> argument, starting at the right
end of the string. Notice also that you can nest functions inside other functions. In
this case, the result of <i>Len</i> is an argument to the <i>Right$</i>
function.</blockquote></div>
</p>

</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-1');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>






