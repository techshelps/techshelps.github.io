
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=cp1252" />
    <title>Call Protocol</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Number Protocol" href="number.html" />
    <link rel="prev" title="Object Protocol" href="object.html" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/call.html" />
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="number.html" title="Number Protocol"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="object.html" title="Object Protocol"
             accesskey="P">previous</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.9.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" accesskey="U">Abstract Objects Layer</a> &#187;</li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="call-protocol">
<span id="call"></span><h1>Call Protocol</h1>
<p>CPython supports two different calling protocols:
<em>tp_call</em> and vectorcall.</p>
<div class="section" id="the-tp-call-protocol">
<h2>The <em>tp_call</em> Protocol</h2>
<p>Instances of classes that set <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> are callable.
The signature of the slot is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_call</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">callable</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">);</span>
</pre></div>
</div>
<p>A call is made using a tuple for the positional arguments
and a dict for the keyword arguments, similarly to
<code class="docutils literal notranslate"><span class="pre">callable(*args,</span> <span class="pre">**kwargs)</span></code> in Python code.
<em>args</em> must be non-NULL (use an empty tuple if there are no arguments)
but <em>kwargs</em> may be <em>NULL</em> if there are no keyword arguments.</p>
<p>This convention is not only used by <em>tp_call</em>:
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> and <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>
also pass arguments this way.</p>
<p>To call an object, use <a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a> or other
<a class="reference internal" href="#capi-call"><span class="std std-ref">call API</span></a>.</p>
</div>
<div class="section" id="the-vectorcall-protocol">
<span id="vectorcall"></span><h2>The Vectorcall Protocol</h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
<p>The vectorcall protocol was introduced in <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0590"><strong>PEP 590</strong></a> as an additional protocol
for making calls more efficient.</p>
<p>As rule of thumb, CPython will prefer the vectorcall for internal calls
if the callable supports it. However, this is not a hard rule.
Additionally, some third-party extensions use <em>tp_call</em> directly
(rather than using <a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a>).
Therefore, a class supporting vectorcall must also implement
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>.
Moreover, the callable must behave the same
regardless of which protocol is used.
The recommended way to achieve this is by setting
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> to <a class="reference internal" href="#c.PyVectorcall_Call" title="PyVectorcall_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyVectorcall_Call()</span></code></a>.
This bears repeating:</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A class supporting vectorcall <strong>must</strong> also implement
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> with the same semantics.</p>
</div>
<p>A class should not implement vectorcall if that would be slower
than <em>tp_call</em>. For example, if the callee needs to convert
the arguments to an args tuple and kwargs dict anyway, then there is no point
in implementing vectorcall.</p>
<p>Classes can implement the vectorcall protocol by enabling the
<a class="reference internal" href="typeobj.html#Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> flag and setting
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a> to the offset inside the
object structure where a <em>vectorcallfunc</em> appears.
This is a pointer to a function with the following signature:</p>
<dl class="type">
<dt id="c.vectorcallfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="descname">(*vectorcallfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em>&nbsp;*args</em>, size_t<em>&nbsp;nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kwnames</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<ul class="simple">
<li><em>callable</em> is the object being called.</li>
<li><dl class="first docutils">
<dt><em>args</em> is a C array consisting of the positional arguments followed by the</dt><dd>values of the keyword arguments.
This can be <em>NULL</em> if there are no arguments.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>nargsf</em> is the number of positional arguments plus possibly the</dt><dd><code class="xref py py-const docutils literal notranslate"><span class="pre">PY_VECTORCALL_ARGUMENTS_OFFSET</span></code> flag.
To get the actual number of positional arguments from <em>nargsf</em>,
use <a class="reference internal" href="#c.PyVectorcall_NARGS" title="PyVectorcall_NARGS"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyVectorcall_NARGS()</span></code></a>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwnames</em> is a tuple containing the names of the keyword arguments;</dt><dd>in other words, the keys of the kwargs dict.
These names must be strings (instances of <code class="docutils literal notranslate"><span class="pre">str</span></code> or a subclass)
and they must be unique.
If there are no keyword arguments, then <em>kwnames</em> can instead be <em>NULL</em>.</dd>
</dl>
</li>
</ul>
<dl class="macro">
<dt id="c.PY_VECTORCALL_ARGUMENTS_OFFSET">
<code class="descname">PY_VECTORCALL_ARGUMENTS_OFFSET</code></dt>
<dd><p>If this flag is set in a vectorcall <em>nargsf</em> argument, the callee is allowed
to temporarily change <code class="docutils literal notranslate"><span class="pre">args[-1]</span></code>. In other words, <em>args</em> points to
argument 1 (not 0) in the allocated vector.
The callee must restore the value of <code class="docutils literal notranslate"><span class="pre">args[-1]</span></code> before returning.</p>
<p>For <a class="reference internal" href="#c.PyObject_VectorcallMethod" title="PyObject_VectorcallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VectorcallMethod()</span></code></a>, this flag means instead that
<code class="docutils literal notranslate"><span class="pre">args[0]</span></code> may be changed.</p>
<p>Whenever they can do so cheaply (without additional allocation), callers
are encouraged to use <code class="xref py py-const docutils literal notranslate"><span class="pre">PY_VECTORCALL_ARGUMENTS_OFFSET</span></code>.
Doing so will allow callables such as bound methods to make their onward
calls (which include a prepended <em>self</em> argument) very efficiently.</p>
</dd></dl>

<p>To call an object that implements vectorcall, use a <a class="reference internal" href="#capi-call"><span class="std std-ref">call API</span></a>
function as with any other callable.
<a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Vectorcall()</span></code></a> will usually be most efficient.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In CPython 3.8, the vectorcall API and related functions were available
provisionally under names with a leading underscore:
<code class="docutils literal notranslate"><span class="pre">_PyObject_Vectorcall</span></code>, <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code>,
<code class="docutils literal notranslate"><span class="pre">_PyObject_VectorcallMethod</span></code>, <code class="docutils literal notranslate"><span class="pre">_PyVectorcall_Function</span></code>,
<code class="docutils literal notranslate"><span class="pre">_PyObject_CallOneArg</span></code>, <code class="docutils literal notranslate"><span class="pre">_PyObject_CallMethodNoArgs</span></code>,
<code class="docutils literal notranslate"><span class="pre">_PyObject_CallMethodOneArg</span></code>.
Additionally, <code class="docutils literal notranslate"><span class="pre">PyObject_VectorcallDict</span></code> was available as
<code class="docutils literal notranslate"><span class="pre">_PyObject_FastCallDict</span></code>.
The old names are still defined as aliases of the new, non-underscored names.</p>
</div>
<div class="section" id="recursion-control">
<h3>Recursion Control</h3>
<p>When using <em>tp_call</em>, callees do not need to worry about
<a class="reference internal" href="exceptions.html#recursion"><span class="std std-ref">recursion</span></a>: CPython uses
<a class="reference internal" href="exceptions.html#c.Py_EnterRecursiveCall" title="Py_EnterRecursiveCall"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EnterRecursiveCall()</span></code></a> and <a class="reference internal" href="exceptions.html#c.Py_LeaveRecursiveCall" title="Py_LeaveRecursiveCall"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_LeaveRecursiveCall()</span></code></a>
for calls made using <em>tp_call</em>.</p>
<p>For efficiency, this is not the case for calls done using vectorcall:
the callee should use <em>Py_EnterRecursiveCall</em> and <em>Py_LeaveRecursiveCall</em>
if needed.</p>
</div>
<div class="section" id="vectorcall-support-api">
<h3>Vectorcall Support API</h3>
<dl class="function">
<dt id="c.PyVectorcall_NARGS">
Py_ssize_t <code class="descname">PyVectorcall_NARGS</code><span class="sig-paren">(</span>size_t<em>&nbsp;nargsf</em><span class="sig-paren">)</span></dt>
<dd><p>Given a vectorcall <em>nargsf</em> argument, return the actual number of
arguments.
Currently equivalent to:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Py_ssize_t</span><span class="p">)(</span><span class="n">nargsf</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PY_VECTORCALL_ARGUMENTS_OFFSET</span><span class="p">)</span>
</pre></div>
</div>
<p>However, the function <code class="docutils literal notranslate"><span class="pre">PyVectorcall_NARGS</span></code> should be used to allow
for future extensions.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyVectorcall_Function">
<a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc">vectorcallfunc</a> <code class="descname">PyVectorcall_Function</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*op</em><span class="sig-paren">)</span></dt>
<dd><p>If <em>op</em> does not support the vectorcall protocol (either because the type
does not or because the specific instance does not), return <em>NULL</em>.
Otherwise, return the vectorcall function pointer stored in <em>op</em>.
This function never raises an exception.</p>
<p>This is mostly useful to check whether or not <em>op</em> supports vectorcall,
which can be done by checking <code class="docutils literal notranslate"><span class="pre">PyVectorcall_Function(op)</span> <span class="pre">!=</span> <span class="pre">NULL</span></code>.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyVectorcall_Call">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyVectorcall_Call</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*tuple</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*dict</em><span class="sig-paren">)</span></dt>
<dd><p>Call <em>callable</em>&rsquo;s <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a> with positional and keyword
arguments given in a tuple and dict, respectively.</p>
<p>This is a specialized function, intended to be put in the
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> slot or be used in an implementation of <code class="docutils literal notranslate"><span class="pre">tp_call</span></code>.
It does not check the <a class="reference internal" href="typeobj.html#Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> flag
and it does not fall back to <code class="docutils literal notranslate"><span class="pre">tp_call</span></code>.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.8.</span></p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="object-calling-api">
<span id="capi-call"></span><h2>Object Calling API</h2>
<p>Various functions are available for calling a Python object.
Each converts its arguments to a convention supported by the called object &ndash;
either <em>tp_call</em> or vectorcall.
In order to do as litle conversion as possible, pick one that best fits
the format of data you have available.</p>
<p>The following table summarizes the available functions;
please see individual documentation for details.</p>
<table border="1" class="docutils align-default">
<colgroup>
<col width="44%" />
<col width="19%" />
<col width="21%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">callable</th>
<th class="head">args</th>
<th class="head">kwargs</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>tuple</td>
<td>dict/<code class="docutils literal notranslate"><span class="pre">NULL</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#c.PyObject_CallNoArgs" title="PyObject_CallNoArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallNoArgs()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>&mdash;</td>
<td>&mdash;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#c.PyObject_CallOneArg" title="PyObject_CallOneArg"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallOneArg()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>1 object</td>
<td>&mdash;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#c.PyObject_CallObject" title="PyObject_CallObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallObject()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>tuple/<code class="docutils literal notranslate"><span class="pre">NULL</span></code></td>
<td>&mdash;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#c.PyObject_CallFunction" title="PyObject_CallFunction"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallFunction()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>format</td>
<td>&mdash;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#c.PyObject_CallMethod" title="PyObject_CallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethod()</span></code></a></td>
<td>obj + <code class="docutils literal notranslate"><span class="pre">char*</span></code></td>
<td>format</td>
<td>&mdash;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#c.PyObject_CallFunctionObjArgs" title="PyObject_CallFunctionObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallFunctionObjArgs()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>variadic</td>
<td>&mdash;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#c.PyObject_CallMethodObjArgs" title="PyObject_CallMethodObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodObjArgs()</span></code></a></td>
<td>obj + name</td>
<td>variadic</td>
<td>&mdash;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#c.PyObject_CallMethodNoArgs" title="PyObject_CallMethodNoArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodNoArgs()</span></code></a></td>
<td>obj + name</td>
<td>&mdash;</td>
<td>&mdash;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#c.PyObject_CallMethodOneArg" title="PyObject_CallMethodOneArg"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodOneArg()</span></code></a></td>
<td>obj + name</td>
<td>1 object</td>
<td>&mdash;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Vectorcall()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>vectorcall</td>
<td>vectorcall</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#c.PyObject_VectorcallDict" title="PyObject_VectorcallDict"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VectorcallDict()</span></code></a></td>
<td><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></td>
<td>vectorcall</td>
<td>dict/<code class="docutils literal notranslate"><span class="pre">NULL</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#c.PyObject_VectorcallMethod" title="PyObject_VectorcallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VectorcallMethod()</span></code></a></td>
<td>arg + name</td>
<td>vectorcall</td>
<td>vectorcall</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="c.PyObject_Call">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_Call</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kwargs</em><span class="sig-paren">)</span></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with arguments given by the
tuple <em>args</em>, and named arguments given by the dictionary <em>kwargs</em>.</p>
<p><em>args</em> must not be <em>NULL</em>; use an empty tuple if no arguments are needed.
If no named arguments are needed, <em>kwargs</em> can be <em>NULL</em>.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This is the equivalent of the Python expression:
<code class="docutils literal notranslate"><span class="pre">callable(*args,</span> <span class="pre">**kwargs)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallNoArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallNoArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em><span class="sig-paren">)</span></dt>
<dd><p>Call a callable Python object <em>callable</em> without any arguments. It is the
most efficient way to call a callable Python object without any argument.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallOneArg">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallOneArg</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*arg</em><span class="sig-paren">)</span></dt>
<dd><p>Call a callable Python object <em>callable</em> with exactly 1 positional argument
<em>arg</em> and no keyword arguments.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em><span class="sig-paren">)</span></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with arguments given by the
tuple <em>args</em>.  If no arguments are needed, then <em>args</em> can be <em>NULL</em>.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This is the equivalent of the Python expression: <code class="docutils literal notranslate"><span class="pre">callable(*args)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallFunction">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallFunction</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, const char<em>&nbsp;*format</em>, ...<span class="sig-paren">)</span></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with a variable number of C arguments.
The C arguments are described using a <a class="reference internal" href="arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> style format
string.  The format can be <em>NULL</em>, indicating that no arguments are provided.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This is the equivalent of the Python expression: <code class="docutils literal notranslate"><span class="pre">callable(*args)</span></code>.</p>
<p>Note that if you only pass <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> args,
<a class="reference internal" href="#c.PyObject_CallFunctionObjArgs" title="PyObject_CallFunctionObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallFunctionObjArgs()</span></code></a> is a faster alternative.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 3.4: </span>The type of <em>format</em> was changed from <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethod">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallMethod</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em>, const char<em>&nbsp;*name</em>, const char<em>&nbsp;*format</em>, ...<span class="sig-paren">)</span></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call the method named <em>name</em> of object <em>obj</em> with a variable number of C
arguments.  The C arguments are described by a <a class="reference internal" href="arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> format
string that should produce a tuple.</p>
<p>The format can be <em>NULL</em>, indicating that no arguments are provided.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This is the equivalent of the Python expression:
<code class="docutils literal notranslate"><span class="pre">obj.name(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code>.</p>
<p>Note that if you only pass <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> args,
<a class="reference internal" href="#c.PyObject_CallMethodObjArgs" title="PyObject_CallMethodObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodObjArgs()</span></code></a> is a faster alternative.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 3.4: </span>The types of <em>name</em> and <em>format</em> were changed from <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallFunctionObjArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallFunctionObjArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, ...<span class="sig-paren">)</span></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with a variable number of
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> arguments.  The arguments are provided as a variable number
of parameters followed by <em>NULL</em>.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This is the equivalent of the Python expression:
<code class="docutils literal notranslate"><span class="pre">callable(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethodObjArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallMethodObjArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*name</em>, ...<span class="sig-paren">)</span></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a method of the Python object <em>obj</em>, where the name of the method is given as a
Python string object in <em>name</em>.  It is called with a variable number of
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> arguments.  The arguments are provided as a variable number
of parameters followed by <em>NULL</em>.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethodNoArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallMethodNoArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*name</em><span class="sig-paren">)</span></dt>
<dd><p>Call a method of the Python object <em>obj</em> without arguments,
where the name of the method is given as a Python string object in <em>name</em>.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethodOneArg">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_CallMethodOneArg</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*arg</em><span class="sig-paren">)</span></dt>
<dd><p>Call a method of the Python object <em>obj</em> with a single positional argument
<em>arg</em>, where the name of the method is given as a Python string object in
<em>name</em>.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Vectorcall">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_Vectorcall</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em>&nbsp;*args</em>, size_t<em>&nbsp;nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kwnames</em><span class="sig-paren">)</span></dt>
<dd><p>Call a callable Python object <em>callable</em>.
The arguments are the same as for <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a>.
If <em>callable</em> supports <a class="reference internal" href="#vectorcall">vectorcall</a>, this directly calls
the vectorcall function stored in <em>callable</em>.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_VectorcallDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_VectorcallDict</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em>&nbsp;*args</em>, size_t<em>&nbsp;nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kwdict</em><span class="sig-paren">)</span></dt>
<dd><p>Call <em>callable</em> with positional arguments passed exactly as in the <a class="reference internal" href="#vectorcall">vectorcall</a> protocol,
but with keyword arguments passed as a dictionary <em>kwdict</em>.
The <em>args</em> array contains only the positional arguments.</p>
<p>Regardless of which protocol is used internally,
a conversion of arguments needs to be done.
Therefore, this function should only be used if the caller
already has a dictionary ready to use for the keyword arguments,
but not a tuple for the positional arguments.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_VectorcallMethod">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">PyObject_VectorcallMethod</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em>&nbsp;*args</em>, size_t<em>&nbsp;nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kwnames</em><span class="sig-paren">)</span></dt>
<dd><p>Call a method using the vectorcall calling convention. The name of the method
is given as a Python string <em>name</em>. The object whose method is called is
<em>args[0]</em>, and the <em>args</em> array starting at <em>args[1]</em> represents the arguments
of the call. There must be at least one positional argument.
<em>nargsf</em> is the number of positional arguments including <em>args[0]</em>,
plus <code class="xref py py-const docutils literal notranslate"><span class="pre">PY_VECTORCALL_ARGUMENTS_OFFSET</span></code> if the value of <code class="docutils literal notranslate"><span class="pre">args[0]</span></code> may
temporarily be changed. Keyword arguments can be passed just like in
<a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Vectorcall()</span></code></a>.</p>
<p>If the object has the <a class="reference internal" href="typeobj.html#Py_TPFLAGS_METHOD_DESCRIPTOR" title="Py_TPFLAGS_METHOD_DESCRIPTOR"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_METHOD_DESCRIPTOR</span></code></a> feature,
this will call the unbound method object with the full
<em>args</em> vector as arguments.</p>
<p>Return the result of the call on success, or raise an exception and return
<em>NULL</em> on failure.</p>
<p>This function is not part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">limited API</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="call-support-api">
<h2>Call Support API</h2>
<dl class="function">
<dt id="c.PyCallable_Check">
int <code class="descname">PyCallable_Check</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><span class="sig-paren">)</span></dt>
<dd><p>Determine if the object <em>o</em> is callable.  Return <code class="docutils literal notranslate"><span class="pre">1</span></code> if the object is callable
and <code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise.  This function always succeeds.</p>
</dd></dl>

</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="number.html" title="Number Protocol"
             >next</a> |</li>
        <li class="right" >
          <a href="object.html" title="Object Protocol"
             >previous</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.9.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" >Abstract Objects Layer</a> &#187;</li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Last updated on Oct 05, 2020.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>

  </body>
</html>