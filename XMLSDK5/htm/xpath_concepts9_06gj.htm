<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Useful Patterns for XPath Wildcards and Axes</TITLE>
<SCRIPT SRC="../stylesheets/vs70link.js"></SCRIPT>
<SCRIPT SRC="../stylesheets/vs70.js"></SCRIPT>
<SCRIPT LANGUAGE="JScript" SRC="../stylesheets/xmlsdk.js"></SCRIPT></HEAD>
<body topmargin=0 id="bodyID" class = "dtBODY">

<div id="scrbanner">
<div id="bannertitle">
<TABLE CLASS="bannerparthead" CELLSPACING=0>
<TR ID="hdr">
<TD CLASS="bannertitle" nowrap>Microsoft XML Core Services (MSXML) 5.0 for Microsoft Office - XPath Developer's Guide</TD><TD valign=middle><a href="#Feedback"><IMG name="feedb" onclick=startFeedback(SDKFeedB) style="CURSOR: hand;" hspace=15 alt="" src="../stylesheets/mailto.gif" align=right></a></TD>
</TR>
</TABLE>
</div>
</div>
<DIV id="scrtext" valign="bottom">
<H1 class="dtH1"><A NAME="xmconusefulpatternsforxpathwildcardsandaxes"></A>Useful Patterns for XPath Wildcards and Axes</H1>

<P>Try to select an efficient approach. The use of axes and wildcard characters can radically simplify your code, but that come at the expense of decreased efficiency. For example, the pattern "//*" will match every node in the tree, which is useful if you're trying to search for a given element or attribute but which can be disastrous if your XML structure has 100,000 nodes.</P>

<H2 class="dtH2">//* Linearizes Tree</H2>

<P>The //* pattern will put all of the nodes in a tree into a single node-set in regular traversal order.</P>

<H2 class="dtH2">//* Is Least Efficient</H2>

<P>Using universal match for searches is the least efficient way of finding nodes, as it traverses every point in the tree.</P>

<H2 class="dtH2">.//*[@attrName] Gets Elements With a Specific Attribute</H2>

<P>The <code class="ce">id()</code> function has been removed from the XSLT specification, but you can search for all elements with given attributes with the XPath expression <code class="ce">//*[@id='myID']</code>.</P>

<H2 class="dtH2">ancestor-or-self::* Gets Ancestor List</H2>

<P>This pattern can be used to retrieve a list of all direct ancestors of a given node, useful for identifying paths.</P>

<H2 class="dtH2">Use Axes and Wildcards for Recursion</H2>

<P>Both Axes and Wildcards are perfect for making recursive calls.</P>

<H2 class="dtH2">following-sibling::* is a node set</H2>

<P>This pattern returns ALL sibling nodes after the current node. To get the next node, use:</P>

<PRE class="code">following::sibling::*[1]</PRE>
<H4><A NAME="feedback"></A></H4>
<SPAN id="SDKFeedB"></SPAN>
</div>
</BODY>
</HTML>
