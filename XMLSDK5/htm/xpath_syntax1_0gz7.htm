<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Comparisons</TITLE>
<SCRIPT SRC="../stylesheets/vs70link.js"></SCRIPT>
<SCRIPT SRC="../stylesheets/vs70.js"></SCRIPT>
<SCRIPT LANGUAGE="JScript" SRC="../stylesheets/xmlsdk.js"></SCRIPT></HEAD>
<body topmargin=0 id="bodyID" class = "dtBODY">

<div id="scrbanner">
<div id="bannertitle">
<TABLE CLASS="bannerparthead" CELLSPACING=0>
<TR ID="hdr">
<TD CLASS="bannertitle" nowrap>Microsoft XML Core Services (MSXML) 5.0 for Microsoft Office - XPath Reference</TD><TD valign=middle><a href="#Feedback"><IMG name="feedb" onclick=startFeedback(SDKFeedB) style="CURSOR: hand;" hspace=15 alt="" src="../stylesheets/mailto.gif" align=right></a></TD>
</TR>
</TABLE>
</div>
</div>
<DIV id="scrtext" valign="bottom">
<H1 class="dtH1"><A NAME="xmrefcomparisons"></A>Comparisons</H1>

<P>To compare two objects in XPath, use the <code class="ce">=</code> sign to test for equality, or use <code class="ce">!= </code>to test for inequality.</P>

<P>For a comparison operation, exactly two operands must be supplied. Comparisons are then made by evaluating each operand, and converting them as needed, so they are of the same type. This is done according to the process described below, in <A HREF="#xmreforderofprecedence">Order of Precedence For Comparsions</A>.</P>

<P>All elements and attributes are strings, but are automatically cast as integer values for numeric comparisons. Literal numeric values are cast to long or double types during comparison operations, as shown in the following table.</P>

<P>For information about <code class="ce">&amp;lt;</code> and other binary comparison operators, see <A HREF="#xmrefbincompop">Binary Comparison Operators</A>, below.</P>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=26%>Literal type</TH>
<TH width=40%>Comparison</TH>
<TH width=34%>Example</TH>
</TR>

<TR VALIGN="top">
<TD width=26%>String</TD>
<TD width=40%><code class="ce">text(lvalue) op text(rvalue)</code></TD>
<TD width=34%><code class="ce">a &amp;lt; GGG</code></TD>
</TR>

<TR VALIGN="top">
<TD width=26%>Integer</TD>
<TD width=40%><code class="ce">(long) lvalue op (long) rvalue</code></TD>
<TD width=34%><code class="ce">a &amp;lt; 3</code></TD>
</TR>

<TR VALIGN="top">
<TD width=26%>Real</TD>
<TD width=40%><code class="ce">(double) lvalue op (double) rvalue</code></TD>
<TD width=34%><code class="ce">a &amp;lt; 3.1</code></TD>
</TR>
</table></div>

<P class="fineprint"></P>

<P>Single or double quotation marks can be used for string delimiters in expressions. This makes it easier to construct and pass patterns from within scripting languages.</P>

<P>For more information about how comparisons are performed using XPath, see section 3.4 ("Booleans") of the <A HREF="http://go.microsoft.com/fwlink/?LinkId=4873">W3C XML Path Language (XPath) Recommendation</A>.</P>

<H4 class="dtH4">Examples</H4>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=50%>Expression</TH>
<TH width=50%>Refers to</TH>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[last-name = "Bob"]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain at least one <code class="ce">&lt;last-name&gt;</code> element with the value <code class="ce">Bob</code>.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[last-name[1] = "Bob"]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements whose first <code class="ce">&lt;last-name&gt;</code> child element has the value <code class="ce">Bob</code>.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author/degree[@from != "Harvard"]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain <code class="ce">&lt;degree&gt;</code> elements with a <code class="ce">from</code> attribute that is not equal to <code class="ce">"Harvard"</code>.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[last-name = /editor/last-name]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain a <code class="ce">&lt;last-name&gt;</code> element that is the same as the <code class="ce">&lt;last-name&gt;</code> element inside the <code class="ce">&lt;editor&gt;</code> element under the root element.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[. = "Matthew Bob"]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements whose string value is <code class="ce">Matthew Bob</code>.</TD>
</TR>
</table></div>

<P class="fineprint"></P>



<H2 class="dtH2"><A NAME="xmreforderofprecedence"></A>Order of Precedence for Comparisons</H2>

<P>Comparisons with regard to data types obey the order of precedence.

<UL type="disc">
	<LI>If at least one operand is a Boolean, each operand is first converted to a Boolean.</li>

	<LI>Otherwise, if at least one operand is a number, each operand is first converted to a number.</li>

	<LI>Otherwise, if at least one operand is a date, each operand is first converted to a date.</li>

	<LI>Otherwise, both operands are first converted to strings.</li>
</UL>



<H2 class="dtH2"><A NAME="xmrefbincompop"></A>Binary Comparison Operators</H2>

<P>A set of binary comparison operators compares numbers and strings and returns Boolean results. The <code class="ce">&amp;lt;</code>, <code class="ce">&amp;lt;=</code>, <code class="ce">&amp;gt;</code>, and <code class="ce">&amp;gt;=</code> operators are used for less than, less than or equal, greater than, and greater than or equal, respectively. Single or double quotation marks can be used for string delimiters in expressions. This makes it easier to construct and pass patterns within scripting languages.</P>

<H4 class="dtH4">Examples</H4>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=50%>Expression</TH>
<TH width=50%>Refers to</TH>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[last-name = "Bob" and price &amp;gt; 50]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain a <code class="ce">&lt;last-name&gt;</code> element with the value <code class="ce">Bob</code>, and a <code class="ce">&lt;price&gt;</code> element with a value greater than 50.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">degree[@from != "Harvard"]</code></TD>
<TD width=50%>All <code class="ce">&lt;degree&gt; </code>elements with a <code class="ce">from</code> attribute that is not equal to <code class="ce">"Harvard"</code>.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[last-name &amp;gt;= "M"]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain a <code class="ce">&lt;last-name&gt;</code> element with a  value that begins with the letter M or greater.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">book[position() &amp;lt;= 3]</code></TD>
<TD width=50%>The first three <code class="ce">&lt;book&gt;</code> elements (1, 2, 3) in the XML file.</TD>
</TR>
</table></div>

<P class="fineprint"></P>

<H4 class="dtH4">Example</H4>

<P class="label"><B>XML File (test.xml)</B></P>

<PRE class="code">&lt;?xml version="1.0"?&gt;
&lt;test&gt;

    &lt;x a="1"&gt;
      &lt;x a="2" b="B"&gt;
        &lt;x&gt;
          &lt;y&gt;y31&lt;/y&gt;
          &lt;y&gt;y32&lt;/y&gt;
        &lt;/x&gt;
      &lt;/x&gt;
    &lt;/x&gt;

    &lt;x a="2"&gt;
      &lt;y&gt;y2&lt;/y&gt;
    &lt;/x&gt;

    &lt;x a="3"&gt;
      &lt;y&gt;y3&lt;/y&gt;
    &lt;/x&gt;

&lt;/test&gt;</PRE>

<P class="label"><B>XSLT File (test.xsl)</B></P>

<P>The following XSLT style sheet selects all the <code class="ce">&lt;x&gt;</code> elements that are the first of their siblings in the document order.</P>

<PRE class="code">&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="xml" omit-xml-declaration="yes" indent="yes"/&gt;

&lt;!-- Suppress text nodes not covered in subsequent template rule. --&gt;
&lt;xsl:template match="text()"/&gt;

&lt;xsl:template match="*"&gt;
   &lt;xsl:element name="{name()}"&gt;
      &lt;xsl:apply-templates select="*|@*"/&gt;
      &lt;xsl:if test="text()"&gt;
         &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="@*"&gt;
   &lt;xsl:attribute name="{name()}"&gt;
      &lt;xsl:value-of select="."/&gt;
   &lt;/xsl:attribute&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/test"&gt;
  <B>&lt;xsl:apply-templates select="//x[position() = 1 ] "/&gt;</B>
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</PRE>

<P class="label"><B>Formatted Output</B></P>

<P>The transformation applied to the XML file above yields the following result:</P>

<PRE class="code">&lt;x a="1"&gt;
  &lt;x a="2" b="B"&gt;
     &lt;x&gt;
        &lt;y&gt;y31&lt;/y&gt;
        &lt;y&gt;y32&lt;/y&gt;
     &lt;/x&gt;
   &lt;/x&gt;
&lt;/x&gt;
&lt;x a="2" b="B"&gt;
   &lt;x&gt;
      &lt;y&gt;y31&lt;/y&gt;
      &lt;y&gt;y32&lt;/y&gt;
   &lt;/x&gt;
&lt;/x&gt;
&lt;x&gt;
   &lt;y&gt;y31&lt;/y&gt;
   &lt;y&gt;y32&lt;/y&gt;
&lt;/x&gt;</PRE>

<H4 class="dtH4">See Also</H4>

<P><A HREF="xpath_syntax2_9wz0.htm">Sample XML File for XPath Syntax (inventory.xml)</A> | <A HREF="xpath_syntax2_3prn.htm">XPath Examples</A></P>
<H4><A NAME="feedback"></A></H4>
<SPAN id="SDKFeedB"></SPAN>
</div>
</BODY>
</HTML>
