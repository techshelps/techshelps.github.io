<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Sorting on Calculated Variables</TITLE>
<SCRIPT SRC="../stylesheets/vs70link.js"></SCRIPT>
<SCRIPT SRC="../stylesheets/vs70.js"></SCRIPT>
<SCRIPT LANGUAGE="JScript" SRC="../stylesheets/xmlsdk.js"></SCRIPT></HEAD>
<body topmargin=0 id="bodyID" class = "dtBODY">

<div id="scrbanner">
<div id="bannertitle">
<TABLE CLASS="bannerparthead" CELLSPACING=0>
<TR ID="hdr">
<TD CLASS="bannertitle" nowrap>Microsoft XML Core Services (MSXML) 5.0 for Microsoft Office - XSLT Developer's Guide</TD><TD valign=middle><a href="#Feedback"><IMG name="feedb" onclick=startFeedback(SDKFeedB) style="CURSOR: hand;" hspace=15 alt="" src="../stylesheets/mailto.gif" align=right></a></TD>
</TR>
</TABLE>
</div>
</div>
<DIV id="scrtext" valign="bottom">
<H1 class="dtH1"><A NAME="xmconsortingoncalculatedvariables"></A>Sorting on Calculated Variables</H1>

<P>The sorting performed by the <code class="ce">&lt;xsl:sort&gt;</code> elements above, in <B>prodsort.xsl</B>, would be suitable for an application like a catalog, in which a given product needs to be located easily.</P>

<P>Suppose, though, that the corporation's chief financial officer asks to see a list of all products, arranged in order by retail price. The first problem this presents is that our data contains a mixture prices in various currency denominations: US dollars (<code class="ce">curr="USD"</code>), Euros (<code class="ce">curr="EU"</code>), and British pounds Sterling (<code class="ce">curr="GBP"</code>). This might seem like an easy problem to fix. You could define a variable, such as <code class="ce">usd_equiv</code>, which would hold the retail price of the product, converted to its US dollar equivalent. Then, you might think, you could sort on the <code class="ce">usd_equiv</code> variable, instead of sorting directly on the value of the <code class="ce">&lt;price&gt;</code> element.</P>

<P>The problem is that you cannot sort directly on a variable. The sort key used as the value of the <code class="ce">&lt;xsl:sort&gt;</code> element's <code class="ce">select</code> attribute must be an XPath expression of some kind.</P>

<P>You can, however, sort on a calculated value, using the following general steps:

<OL type="1">
	<LI>Clone the source tree into a variable, which will then hold a result tree fragment. For more information, see <A HREF="xsl_advanced2_0neb.htm">Introduction to Result Tree Fragments</A>.</li>

	<LI>Create a new element to hold the calculated result, and append this new element to the cloned source tree created in step 1.</li>

	<LI>Select and sort the result tree fragment created by steps 1 and 2. Do not select and sort the original source tree. Note that this will require the result tree fragment to be converted to a node-set, using the <code class="ce">msxsl:node-set()</code> function. For more information, see <A HREF="xsl_advanced2_0703.htm">Using msxsl:node-set() to Process Result-Tree Fragments</A>.</li>
</OL>

<P>The remainder of  this topic works through each of these steps for the <B>prodsort</B> example. The complete solution to the problem stated above, the <B>prodsort_curr.xsl</B> style sheet, is available at <A HREF="xsl_advanced1_8jtz.htm">Sample XSLT File for Sorting</A>.</P>

<P>The solution to this problem requires the following steps.

<UL type="disc">
	<LI><A HREF="xsl_advanced1_210l.htm">Step 1: Cloning the Source Tree</A></li>

	<LI><A HREF="xsl_advanced1_8yd0.htm">Step 2: Creating the New Element</A></li>

	<LI><A HREF="xsl_advanced1_27ad.htm">Step 3: Sorting the Source Tree Clone</A></li>
</UL>
<H4><A NAME="feedback"></A></H4>
<SPAN id="SDKFeedB"></SPAN>
</div>
</BODY>
</HTML>
