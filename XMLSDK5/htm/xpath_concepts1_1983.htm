<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Overview of XPath Axes and Node Relationships</TITLE>
<SCRIPT SRC="../stylesheets/vs70link.js"></SCRIPT>
<SCRIPT SRC="../stylesheets/vs70.js"></SCRIPT>
<SCRIPT LANGUAGE="JScript" SRC="../stylesheets/xmlsdk.js"></SCRIPT></HEAD>
<body topmargin=0 id="bodyID" class = "dtBODY">

<div id="scrbanner">
<div id="bannertitle">
<TABLE CLASS="bannerparthead" CELLSPACING=0>
<TR ID="hdr">
<TD CLASS="bannertitle" nowrap>Microsoft XML Core Services (MSXML) 5.0 for Microsoft Office - XPath Developer's Guide</TD><TD valign=middle><a href="#Feedback"><IMG name="feedb" onclick=startFeedback(SDKFeedB) style="CURSOR: hand;" hspace=15 alt="" src="../stylesheets/mailto.gif" align=right></a></TD>
</TR>
</TABLE>
</div>
</div>
<DIV id="scrtext" valign="bottom">
<H1 class="dtH1"><A NAME="xmconoverviewofxpathaxesandnoderelationships"></A>Overview of XPath Axes and Node Relationships</H1>

<P>In addition to knowing the seven types of nodes, you also need to understand the possible kinds of relationships between and among nodes in a document. Each relationship corresponds to what XPath calls an axis. For more information, see <A HREF="xpath_hdi_2_4s4h.htm">Use XPath Axes to Navigate through XML Data</A>.</P>

<P>The terms used for the axes assume that the document tree represents a set of family relationships. The axes that can be expressed with XPath are:

<UL type="disc">
	<LI><A HREF="#xmconparent">Parent</A></li>

	<LI><A HREF="#xmconchild">Child</A></li>

	<LI><A HREF="#xmconancestor">Ancestor</A></li>

	<LI><A HREF="#xmcondescendant">Descendant</A></li>

	<LI><A HREF="#xmconancestororself">Ancestor-or-self</A></li>

	<LI><A HREF="#xmcondescendantorself">Descendant-or-self</A></li>

	<LI><A HREF="#xmconpreceding">Preceding</A></li>

	<LI><A HREF="#xmconfollowing">Following</A></li>

	<LI><A HREF="#xmconprecedingsibling">Preceding-sibling</A></li>

	<LI><A HREF="#xmconfollowingsibling">Following-sibling</A></li>

	<LI><A HREF="#xmconself">Self</A></li>
</UL>

<P>Two additional relationships apply only to element nodes:

<UL type="disc">
	<LI><A HREF="#xmconattribute">Attribute</A></li>

	<LI><A HREF="#xmconnamespace">Namespace</A></li>
</UL>



<H2 class="dtH2"><A NAME="xmconparent"></A>Parent</H2>

<P>The parent node of an element, attribute, processing instruction, comment, or text node is the element immediately above it in the tree&#0151;the element which contains it. For the root element, and any comments or processing instructions which precede or follow it, the parent is the root node. The root node itself has no parent. The parent of a namespace node is the element which declares it. In the document diagrammed above, for instance:

<UL type="disc">
	<LI>The parent of the <code class="ce">&lt;books&gt;</code> element is the root node.</li>

	<LI>The parent of each of the <code class="ce">catnum</code> attributes is the corresponding <code class="ce">&lt;book&gt;</code> element.</li>

	<LI>The parent of the comment, "Are we sure this guy's name is spelled right???" is the first <code class="ce">&lt;book&gt;</code> element.</li>

	<LI>The parent of both the <code class="ce">&lt;?xsl-stylesheet?&gt;</code> processing instruction and the comment at the end of the document is the root node.</li>
</UL>



<H2 class="dtH2"><A NAME="xmconchild"></A>Child</H2>

<P>A node's child is any node immediately below it in the hierarchy of a document's nodes, with some exceptions. The exceptions are that neither attribute nor namespace nodes are considered children of their respective elements. Therefore, if an XPath expression locates all children of a given element, it locates only elements, text nodes, processing instructions, and comments immediately subordinate to that element.</P>

<P>processing instructions and comments in the document prolog or following the root element are considered children of the root node, as is the root element.</P>

<P>In the document diagrammed above, for instance:

<UL type="disc">
	<LI>The children of the root node are the <code class="ce">&lt;?xsl-stylesheet?&gt;</code> processing instruction, the root <code class="ce">&lt;books&gt;</code> element, and the comment which follows the root element's end tag.</li>

	<LI>The children of the <code class="ce">&lt;books&gt;</code> element node are the two <code class="ce">&lt;book&gt;</code> elements. Note that the <code class="ce">catdate</code> attribute is not considered a child of the <code class="ce">&lt;books&gt;</code> element node, despite the fact that <code class="ce">&lt;books&gt;</code> is considered <code class="ce">catdate</code>'s parent.</li>

	<LI>The children of the first <code class="ce">&lt;book&gt;</code> element are the first <code class="ce">&lt;title&gt;</code> element, the comment "Are we sure this guy's name is spelled right???" and the first <code class="ce">&lt;author&gt;</code> element.</li>

	<LI>The second <code class="ce">&lt;title&gt;</code> element has only one child, the text node "For Love of a Toothpick."</li>
</UL>



<H2 class="dtH2"><A NAME="xmconancestor"></A>Ancestor</H2>

<P>An ancestor of any node in the tree is any node at a higher level in the tree than the node in question, including its parent. The root node has no ancestors; on the other hand, the root node is an ancestor of all other nodes in the tree.</P>

<P>For example, in the previous document diagrammed above:

<UL type="disc">
	<LI>The <code class="ce">catdate</code> attribute's ancestors are the <code class="ce">&lt;books&gt;</code> element and the root node.</li>

	<LI>The <code class="ce">&lt;?xml-stylesheet?&gt;</code> processing instruction, the root <code class="ce">&lt;books&gt;</code> element, and the comment following the <code class="ce">&lt;books&gt;</code> element each has a single ancestor, the root node.</li>

	<LI>Ancestors of the text node "Frey, Jörg" are the second <code class="ce">&lt;author&gt;</code> element, the second <code class="ce">&lt;book&gt;</code> element, the root <code class="ce">&lt;books&gt;</code> element, and the root node.</li>
</UL>



<H2 class="dtH2"><A NAME="xmcondescendant"></A>Descendant</H2>

<P>A descendant node is any node (including children) which is subordinate to a given node in the document tree. Everything in the document tree is a descendant of the root node, except the root node itself and any attribute or namespace nodes.</P>

<P>For example, in the document diagrammed earlier in this topic:

<UL type="disc">
	<LI>The <code class="ce">catdate</code> and <code class="ce">catnum</code> attributes have no descendants. (Attributes have no children.)</li>

	<LI>Descendants of the first <code class="ce">&lt;book&gt;</code> element are the first <code class="ce">&lt;title&gt;</code> element and its text node, "Jambing on the Trixles"; the comment, "Are we sure this guy's name is spelled right???"; and the first <code class="ce">&lt;author&gt;</code> element and its text node, "Randall, Tristan." Since an attribute is not considered a child of its defining element, the <code class="ce">catnum="id2345"</code> attribute is not a descendant of this <code class="ce">&lt;book&gt;</code> element (or indeed of anything else in the document).</li>
</UL>



<H2 class="dtH2"><A NAME="xmconancestororself"></A>Ancestor-or-self</H2>

<P>Ancestor-or-self nodes of a given node in the tree include all ancestors of that node and the node itself. Therefore, although the root node has no ancestors, an XPath expression which locates the ancestor-or-self nodes of the root node will locate the root node itself.</P>

<P>Some examples from the document diagrammed in this topic are:

<UL type="disc">
	<LI>The ancestor-or-self nodes of the concluding comment include the root node and the comment itself.</li>

	<LI>The <code class="ce">catdate</code> attribute's ancestor-or-self nodes are the <code class="ce">&lt;books&gt;</code> element which defines it, the root node, and the <code class="ce">catdate</code> attribute itself.</li>
</UL>



<H2 class="dtH2"><A NAME="xmcondescendantorself"></A>Descendant-or-self</H2>

<P>If a given node in the tree has any descendants, an XPath expression locating its descendant-or-self nodes will locate all those descendants, and the node itself. If it has no descendants, such an expression will locate only the node itself. Thus, given the document diagrammed in this topic:

<UL type="disc">
	<LI>The second <code class="ce">&lt;title&gt;</code> element's descendant-or-self nodes are its text node, "For Love of a Toothpick," and that <code class="ce">&lt;title&gt;</code> element itself.</li>

	<LI>The document's concluding comment has no descendants; therefore it has only a single descendant-or-self node, which is the comment itself.</li>
</UL>



<H2 class="dtH2"><A NAME="xmconpreceding"></A>Preceding</H2>

<P>A preceding node, relative to a given node in the document tree, is any node which appears in the document before that node, <I>except</I> ancestors, attribute nodes, or namespace nodes. One way to think of this is that preceding nodes are those whose content occurs in its entirety before the start of the node in question. Since the root node contains all other nodes in the document, it will never be located among a given node's preceding nodes; likewise, the root node itself has no preceding nodes. Given the document diagrammed earlier in this topic, for example:

<UL type="disc">
	<LI>The root <code class="ce">&lt;books&gt;</code> element has only one preceding node, which is the <code class="ce">&lt;?xml-stylesheet?&gt;</code> processing instruction.</li>

	<LI>Everything in the document (except the attributes and the document root node) is a preceding node relative to the concluding comment.</li>

	<LI>The first <code class="ce">&lt;author&gt;</code> element's preceding nodes are the comment, "Are we sure this guy's name is spelled right???", the first <code class="ce">&lt;title&gt;</code> element and its text node ("Jambing on the Trixles"), and the <code class="ce">&lt;?xml-stylesheet?&gt;</code> processing instruction. Since they are ancestors of the first <code class="ce">&lt;author&gt;</code> element, the first <code class="ce">&lt;book&gt;</code> element, the root <code class="ce">&lt;books&gt;</code> element, and the root node all terminate <I>after</I> the first <code class="ce">&lt;author&gt;</code> element closes, therefore they are not among its preceding nodes.</li>
</UL>



<H2 class="dtH2"><A NAME="xmconfollowing"></A>Following</H2>

<P>Following nodes are the reverse of preceding ones: They include any nodes (except descendant, attribute, and namespace nodes) which come <I>after</I> a given node. Since the root node contains all other nodes in the document, it is a following node of none of them, and itself has no following nodes.</P>

<P>Based on the document diagrammed in this topic, we can say:

<UL type="disc">
	<LI>The root <code class="ce">&lt;books&gt;</code> element has only one following node, which is the document's concluding comment.</li>

	<LI>The concluding comment has no following nodes.</li>

	<LI>The first <code class="ce">&lt;author&gt;</code> element's following nodes are the second <code class="ce">&lt;book&gt;</code> element (and all of the second <code class="ce">&lt;book&gt;</code> element's descendants) and the concluding comment. Because the text node "Randall, Tristan" is a descendant (specifically, a child) of the first <code class="ce">&lt;author&gt;</code> element, it is not considered a following node for that element.</li>
</UL>



<H2 class="dtH2"><A NAME="xmconprecedingsibling"></A>Preceding-sibling</H2>

<P>Sibling relationships in a family identify children of the same parent, relative to one another. Therefore preceding-sibling nodes are a subset of all siblings, including only those which appear in the document before the node in question. Since attribute and namespace nodes can never be child nodes, they can never be found among a given nodes' preceding-siblings.</P>

<BLOCKQUOTE class="dtBlock">
<b class="le">Note</b>&nbsp;&nbsp;&nbsp;XPath does not define a simple sibling relationship, only preceding-sibling and following-sibling.</BLOCKQUOTE>

<P>For instance, referring to the document described earlier in this topic:

<UL type="disc">
	<LI>Each of the <code class="ce">&lt;author&gt;</code> elements has one preceding-sibling node, which is the respective <code class="ce">&lt;title&gt;</code> element. However, the first <code class="ce">&lt;author&gt;</code> element also has another preceding-sibling, which is the comment, "Are we sure this guy's name is spelled right???"</li>

	<LI>The root <code class="ce">&lt;books&gt;</code> element has one preceding-sibling, the <code class="ce">&lt;?xml-stylesheet?&gt;</code> processing instruction.</li>

	<LI>The concluding comment has two preceding-siblings: the root <code class="ce">&lt;books&gt;</code> element and the <code class="ce">&lt;?xml-stylesheet?&gt;</code> processing instruction.</li>
</UL>



<H2 class="dtH2"><A NAME="xmconfollowingsibling"></A>Following-sibling</H2>

<P>Among a given node's following-siblings, you will find all those nodes (except attribute and namespace nodes, which can never be child nodes) which share that node's parent and appear after the node in question in the document.</P>

<BLOCKQUOTE class="dtBlock">
<b class="le">Note</b>&nbsp;&nbsp;&nbsp;XPath does not define a simple sibling relationship, only preceding-sibling and following-sibling.</BLOCKQUOTE>

<P>Examples from the document diagrammed earlier in this topic include:

<UL type="disc">
	<LI>Neither of the <code class="ce">&lt;author&gt;</code> elements has any following-sibling nodes.</li>

	<LI>The root <code class="ce">&lt;books&gt;</code> element has one following-sibling, which is the concluding comment.</li>

	<LI>The concluding comment has no following-siblings.</li>
</UL>



<H2 class="dtH2"><A NAME="xmconself"></A>Self</H2>

<P>In some cases, you need an XPath expression which locates only the node you're already dealing with. For such cases, XPath provides the "self relationship." Every node in any given document has, of course, one and only one self node.</P>



<H2 class="dtH2"><A NAME="xmconattribute"></A>Attribute</H2>

<P>Since attributes can never be found among the parent, child, ancestor, descendant, preceding, following, preceding-sibling, or following-sibling nodes of a given node, how do you locate them with XPath? The answer lies in the special attribute relationship. An element's attribute nodes are any attributes which it declares, and <I>only</I> elements can have attribute nodes. </P>

<BLOCKQUOTE class="dtBlock">
<b class="le">Note</b>&nbsp;&nbsp;&nbsp;A processing instruction's pseudo-attributes cannot be located this way.</BLOCKQUOTE>

<P>Using the sample document diagrammed earlier in this topic, for instance:

<UL type="disc">
	<LI>Each of the <code class="ce">&lt;book&gt;</code> elements has a single attribute node, the respective <code class="ce">catnum</code> attribute.</li>

	<LI>The root <code class="ce">&lt;books&gt;</code> element likewise has one attribute node, the <code class="ce">catdate</code> attribute.</li>

	<LI>None of the other elements in this sample document have any attribute nodes.</li>
</UL>



<H2 class="dtH2"><A NAME="xmconnamespace"></A>Namespace</H2>

<P>An element has a namespace node for every namespace which is in scope for it. Because namespaces are implicitly inherited by all elements descended from an element which declares a namespace, the following hold true:

<UL type="disc">
	<LI>An element may have a namespace node even if the element does not itself declare a namespace.</li>

	<LI>An element may have multiple namespace nodes, one corresponding to each namespace that it declares and one corresponding to each namespace declared by an ancestor element.</li>
</UL>

<H4 class="dtH4">See Also</H4>

<P><A HREF="xpath_concepts1_1nos.htm">Sample XML File for XPath Tree Model</A></P>
<H4><A NAME="feedback"></A></H4>
<SPAN id="SDKFeedB"></SPAN>
</div>
</BODY>
</HTML>
