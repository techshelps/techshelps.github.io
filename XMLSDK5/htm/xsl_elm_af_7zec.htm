<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><TITLE>&lt;xsl:fallback&gt; Element</TITLE>
<SCRIPT SRC="../stylesheets/vs70link.js"></SCRIPT>
<SCRIPT SRC="../stylesheets/vs70.js"></SCRIPT>
<SCRIPT LANGUAGE="JScript" SRC="../stylesheets/xmlsdk.js"></SCRIPT></HEAD>
<body topmargin=0 id="bodyID" class = "dtBODY">

<div id="scrbanner">
<div id="bannertitle">
<TABLE CLASS="bannerparthead" CELLSPACING=0>
<TR ID="hdr">
<TD CLASS="bannertitle" nowrap>Microsoft XML Core Services (MSXML) 5.0 for Microsoft Office - XSLT Reference</TD><TD valign=middle><a href="#Feedback"><IMG name="feedb" onclick=startFeedback(SDKFeedB) style="CURSOR: hand;" hspace=15 alt="" src="../stylesheets/mailto.gif" align=right></a></TD>
</TR>
</TABLE>
</div>
</div>
<DIV id="scrtext" valign="bottom">
<H1 class="dtH1"><A NAME="xmrefxslfallbackelement"></A>&lt;xsl:fallback&gt; Element</H1>

<P>The <code class="ce">&lt;xsl:fallback&gt;</code> element is designed to handle XSLT elements that cannot be handled by the parser: for example, elements that are part of a new version or unrecognized extension. The <code class="ce">&lt;xsl:fallback&gt;</code> element works by calling template content that provides a reasonable substitute for the behavior of the new element.</P>

<PRE class="syntax">&lt;xsl:fallback&gt;
&lt;/xsl:fallback&gt;</PRE>

<H4 class="dtH4">Attributes</H4>

<P>None</P>

<H4 class="dtH4">Element Information</H4>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TD width=33%><B>Number of occurrences</B></TD>
<TD width=67%>Unlimited</TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>Parent elements</B></TD>
<TD width=67%><A HREF="xsl_elm_af_05pw.htm">xsl:attribute</A>, <A HREF="xsl_elm_af_58tw.htm">xsl:comment</A>, <A HREF="xsl_elm_af_1c38.htm">xsl:copy</A>, <A HREF="xsl_elm_af_2vhw.htm">xsl:element</A>, xsl:fallback, <A HREF="xsl_elm_af_2bxw.htm">xsl:for-each</A>, <A HREF="xsl_elm_gp_1z3o.htm">xsl:if</A>, <A HREF="xsl_elm_gp_5xx0.htm">xsl:message</A>, <A HREF="xsl_elm_gp_4agk.htm">xsl:otherwise</A>, <A HREF="xsl_elm_gp_5ek4.htm">xsl:param</A>, <A HREF="xsl_elm_gp_1cdw.htm">xsl:processing-instruction</A>, <A HREF="xsl_elm_qz_120k.htm">xsl:template</A>, <A HREF="xsl_elm_qz_94hg.htm">xsl:variable</A>, <A HREF="xsl_elm_qz_4kj8.htm">xsl:when</A>, <A HREF="xsl_elm_qz_1f5g.htm">xsl:with-param</A>, output<I> </I>elements</TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>Child elements</B></TD>
<TD width=67%><A HREF="xsl_elm_af_7vqs.htm">xsl:apply-templates</A>, <A HREF="xsl_elm_af_05pw.htm">xsl:attribute</A>, <A HREF="xsl_elm_af_11x0.htm">xsl:call-template</A>, <A HREF="xsl_elm_af_9cz8.htm">xsl:choose</A>, <A HREF="xsl_elm_af_58tw.htm">xsl:comment</A>, <A HREF="xsl_elm_af_1c38.htm">xsl:copy</A>, <A HREF="xsl_elm_af_8zxw.htm">xsl:copy-of</A>, <A HREF="xsl_elm_af_2vhw.htm">xsl:element</A>, <A HREF="xsl_elm_af_2bxw.htm">xsl:for-each</A>, <A HREF="xsl_elm_gp_1z3o.htm">xsl:if</A>, <A HREF="xsl_elm_gp_1cdw.htm">xsl:processing-instruction</A>, <A HREF="xsl_elm_qz_5sl0.htm">xsl:text</A>, <A HREF="xsl_elm_qz_3gc4.htm">xsl:value-of</A>, <A HREF="xsl_elm_qz_94hg.htm">xsl:variable</A>, output elements</TD>
</TR>
</table></div>

<P class="fineprint"></P>

<H4 class="dtH4">Remarks</H4>

<P>When an XSLT document is first loaded, the XSLT preparser performs validation on all XSLT elements. If the version passed in the <code class="ce">&lt;xsl:stylesheet&gt;</code> element is greater than that supported by the parser, the parser will execute the <code class="ce">&lt;xsl:fallback&gt;</code> children of any unfamiliar element that is encountered. If an <code class="ce">&lt;xsl:fallback&gt;</code> element has no content, the parser does not perform any action. If an element is supported, the templates in its <code class="ce">&lt;xsl:fallback&gt;</code> children are never instantiated. If the version given in the style sheet is the same as that supported by the browser, an error will be called.</P>

<P>Fallbacks are part of the forward-processing mechanism that XSLT uses for handling upgrades. By creating alternative ways of handling a command if an element is not supported, forward-processing guarantees that the code used is relatively robust and insensitive to differences in parser conformity.</P>

<P>In addition to handling versioning differences, the fallback mechanism can also be used to handle elements defined by namespace extensions. Because adding functionality to the base specification is typically very difficult, namespace extensions let developers define functionality beyond that specified by the XSLT specification. If the namespace is not supported (no definition for the namespace is provided), or if a namespace function or element is not defined, the fallback mechanism can be used to provide alternate functionality.</P>

<P>To guarantee that the extension is interpreted within the XSLT operation, you need to set the <code class="ce">extension-element-prefixes</code> attribute in the <code class="ce">&lt;xsl:stylesheet&gt;</code> element so that it contains the name of the prefix to interpret. In addition, declare the namespace for that prefix.</P>

<P>The following topic provides an example of <code class="ce">&lt;xsl:fallback&gt;</code>.

<UL type="disc">
	<LI><A HREF="xsl_elm_af_25b9.htm">Example of &lt;xsl:fallback&gt;</A></li>
</UL>
<H4><A NAME="feedback"></A></H4>
<SPAN id="SDKFeedB"></SPAN>
</div>
</BODY>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script></html>
