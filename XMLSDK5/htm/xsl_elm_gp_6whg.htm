<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>&lt;xsl:number&gt; Element</TITLE>
<SCRIPT SRC="../stylesheets/vs70link.js"></SCRIPT>
<SCRIPT SRC="../stylesheets/vs70.js"></SCRIPT>
<SCRIPT LANGUAGE="JScript" SRC="../stylesheets/xmlsdk.js"></SCRIPT></HEAD>
<body topmargin=0 id="bodyID" class = "dtBODY">

<div id="scrbanner">
<div id="bannertitle">
<TABLE CLASS="bannerparthead" CELLSPACING=0>
<TR ID="hdr">
<TD CLASS="bannertitle" nowrap>Microsoft XML Core Services (MSXML) 5.0 for Microsoft Office - XSLT Reference</TD><TD valign=middle><a href="#Feedback"><IMG name="feedb" onclick=startFeedback(SDKFeedB) style="CURSOR: hand;" hspace=15 alt="" src="../stylesheets/mailto.gif" align=right></a></TD>
</TR>
</TABLE>
</div>
</div>
<DIV id="scrtext" valign="bottom">
<H1 class="dtH1"><A NAME="xmrefxslnumberelement"></A>&lt;xsl:number&gt; Element</H1>

<P>Inserts a formatted number into the result tree.</P>

<PRE class="syntax">&lt;xsl:number
&nbsp;&nbsp;level = "single" | "multiple" | "any"
&nbsp;&nbsp;count = <A HREF="xsl_xsltsyntax_6twz.htm">Pattern</A>
&nbsp;&nbsp;from = <A HREF="xsl_xsltsyntax_6twz.htm">Pattern</A>
&nbsp;&nbsp;value = <I>number-</I><A HREF="xsl_xsltsyntax_51pv.htm">Expression</A> 
&nbsp;&nbsp;format = { <I>string</I> }
&nbsp;&nbsp;lang = { <I>nmtoken</I> }
&nbsp;&nbsp;letter-value = { "<I>alphabetic</I>" | "<I>traditional</I>" }
&nbsp;&nbsp;grouping-separator = { <I>char</I> }
&nbsp;&nbsp;grouping-size = { <I>number</I> }&nbsp;/&gt;</PRE>

<H4 class="dtH4">Attributes</H4>

<DL>
<DT><B>level</B></DT>

<DD>Specifies what levels of the source tree should be considered; it has the values <code class="ce">"single"</code>, <code class="ce">"multiple"</code> and <code class="ce">"any"</code>. The default is <code class="ce">"single"</code>.</dd>

<DT><B>count</B></DT>

<DD>A pattern that specifies what nodes should be counted at those levels. If the <code class="ce">count</code> attribute is not specified, then it defaults to the pattern that matches any node with the same node type as the current node and, if the current node has an expanded-name, with the same expanded-name as the current node.</dd>

<DT><B>from</B></DT>

<DD>A pattern that specifies where counting starts.</dd>

<DT><B>value</B></DT>

<DD>Specifies the expression to be converted to a number and output to the result tree. If no <code class="ce">value</code> attribute is specified, the <code class="ce">&lt;xsl:number&gt;</code> element inserts a number based on the position of the current node in the source tree.</dd>

<DT><B>format</B></DT>

<DD>A sequence of tokens that specifies the format to be used for each number in the list. If there are no format tokens, then the default value of 1 is used which generates a sequence 1 2 … 10 11 12…. Each number after the first is separated from the preceding number by the separator token preceding the format token used to format that number. If there are no separator tokens, a period character is used (".").

<P class="fineprint">

<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=23%>Format token</TH>
<TH width=77%>Sequence generated</TH>
</TR>

<TR VALIGN="top">
<TD width=23%>1</TD>
<TD width=77%>1 2 3 4 5 … 10 11 12 …</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>01</TD>
<TD width=77%>01 02 03 … 19 10 11 … 99 100 101…</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>A</TD>
<TD width=77%>A B C … Z AA AB AC…</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>i</TD>
<TD width=77%>i ii iii iv v vi vii viii ix x…</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>I</TD>
<TD width=77%>I II III IV V VI VII VIII IX X…</TD>
</TR>
</table></div>


<P class="fineprint">
</dd>

<DT><B>lang</B></DT>

<DD>Specifies which language's alphabet is used. If no lang value is specified, the language is determined from the system environment.</dd>

<DT><B>letter-value</B></DT>

<DD>Disambiguates between numbering sequences that use letters. One numbering sequence assigns numeric values to letters in alphabetic sequence, and the other assigns numeric values to each letter in some other manner traditional in that language. In English, these correspond to the numbering sequences specified by the format tokens "a" and "i". In some languages, the first member of each sequence is the same, and so the format token alone would be ambiguous. A value of <code class="ce">"alphabetic"</code> specifies the alphabetic sequence; a value of <code class="ce">"traditional"</code> specifies the other sequence. Default is <code class="ce">"alphabetic"</code>.</dd>

<DT><B>grouping-separator</B></DT>

<DD>Gives the separator used as a grouping (e.g. thousands) separator in decimal numbering sequences. For example, <code class="ce">grouping-separator="," </code>and <code class="ce">grouping-size="3" </code>would produce numbers of the form 1,000,000. If only one of the <code class="ce">grouping-separator</code> and <code class="ce">grouping-size</code> attributes is specified, it is ignored.</dd>

<DT><B>grouping-size</B></DT>

<DD>Specifies the size (normally 3) of the grouping. For example, <code class="ce">grouping-separator=","</code> and <code class="ce">grouping-size="3"</code> would produce numbers of the form 1,000,000. If only one of the <code class="ce">grouping-separator</code> and <code class="ce">grouping-size</code> attributes is specified, it is ignored.</dd>
</DL>

<H4 class="dtH4">Element Information</H4>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TD width=34%><B>Number of occurrences</B></TD>
<TD width=66%>Unlimited</TD>
</TR>

<TR VALIGN="top">
<TD width=34%><B>Parent elements</B></TD>
<TD width=66%><A HREF="xsl_elm_af_1c38.htm">xsl:copy</A>, <A HREF="xsl_elm_af_2vhw.htm">xsl:element</A>, <A HREF="xsl_elm_af_7zec.htm">xsl:fallback</A>, <A HREF="xsl_elm_af_2bxw.htm">xsl:for-each</A>, <A HREF="xsl_elm_gp_1z3o.htm">xsl:if</A>, <A HREF="xsl_elm_gp_5xx0.htm">xsl:message</A>, <A HREF="xsl_elm_gp_4agk.htm">xsl:otherwise</A>, <A HREF="xsl_elm_gp_5ek4.htm">xsl:param</A>, <A HREF="xsl_elm_qz_120k.htm">xsl:template</A>, <A HREF="xsl_elm_qz_94hg.htm">xsl:variable</A>, <A HREF="xsl_elm_qz_4kj8.htm">xsl:when</A>, <A HREF="xsl_elm_qz_1f5g.htm">xsl:with-param</A>, output elements</TD>
</TR>

<TR VALIGN="top">
<TD width=34%><B>Child elements</B></TD>
<TD width=66%>(No child elements)</TD>
</TR>
</table></div>

<P class="fineprint"></P>

<H4 class="dtH4">Remarks</H4>

<P>The number to be inserted is specified by an expression contained in the <code class="ce">value</code> attribute. The expression is evaluated and the resulting object is converted to a number. The number is rounded to an integer and then converted to a string and inserted in the result tree.</P>

<P>The <code class="ce">&lt;xsl:number&gt;</code> element first constructs a list of positive integers using the level, count and from attributes:

<UL type="disc">
	<LI>When <code class="ce">level="single"</code>, it goes up to the first node in the ancestor-or-self axis that matches the count pattern, and constructs a list of length one containing one plus the number of preceding siblings of that ancestor that match the count pattern. If there is no such ancestor, it constructs an empty list. If the <code class="ce">from</code> attribute is specified, then the only ancestors that are searched are those that are descendants of the nearest ancestor that matches the <code class="ce">from</code> pattern. Preceding-siblings has the same meaning here as with the preceding-sibling axis.</li>

	<LI>When <code class="ce">level="multiple"</code>, it constructs a list of all ancestors of the current node in document order followed by the element itself; it then selects from the list those nodes that match the count pattern; it then maps each node in the list to one plus the number of preceding siblings of that node that match the count pattern. If the <code class="ce">from</code> attribute is specified, then the only ancestors that are searched are those that are descendants of the nearest ancestor that matches the <code class="ce">from</code> pattern. Preceding siblings has the same meaning here as with the preceding-sibling axis.</li>

	<LI>When <code class="ce">level="any"</code>, it constructs a list of length one containing the number of nodes that match the count pattern and belong to the set containing the current node and all nodes at any level of the document that are before the current node in document order, excluding any namespace and attribute nodes (in other words the union of the members of the preceding and ancestor-or-self axes). If the <code class="ce">from</code> attribute is specified, then only nodes after the first node before the current node that match the <code class="ce">from</code> pattern are considered.</li>
</UL>

<P>The following languages/numbering schemes are supported. "Format Token" corresponds to the <code class="ce">format</code> attribute, "Language" corresponds to the <code class="ce">lang</code> attribute, and "Letter-Value" corresponds to the <code class="ce">letter-value</code> attribute.</P>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=31%>Description</TH>
<TH width=22%>Format Token</TH>
<TH width=20%>Language</TH>
<TH width=27%>Letter-Value</TH>
</TR>

<TR VALIGN="top">
<TD width=31%>Western</TD>
<TD width=22%>0x0031 (1)</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Upper-case letter</TD>
<TD width=22%>0x0041 (A)</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Lower-case letter</TD>
<TD width=22%>0x0061 (a)</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Upper-case Roman</TD>
<TD width=22%>0x0049 (I)</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Lower-case Roman</TD>
<TD width=22%>0x0069 (i)</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Upper-case Russian (Cyrillic)</TD>
<TD width=22%>0x0410</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Lower-case Russian (Cyrillic)</TD>
<TD width=22%>0x0430</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Hebrew Alphabetic</TD>
<TD width=22%>0x05d0</TD>
<TD width=20%>n/a</TD>
<TD width=27%>Alphabetic</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Hebrew Traditional</TD>
<TD width=22%>0x05d0</TD>
<TD width=20%>n/a</TD>
<TD width=27%>Traditional</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Arabic</TD>
<TD width=22%>0x0623</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Hindi Consonants</TD>
<TD width=22%>0x0905</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Hindi Vowels</TD>
<TD width=22%>0x0915</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Hindi Numbers</TD>
<TD width=22%>0x0967</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Thai Letters</TD>
<TD width=22%>0x0e01</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Thai Numbers</TD>
<TD width=22%>0x0e51</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Japanese Aiueo (double-byte)</TD>
<TD width=22%>0x30a2</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Japanese Iroha (double-byte)</TD>
<TD width=22%>0x30a4</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Korean Chosung</TD>
<TD width=22%>0x3131</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Taiwanese Decimal</TD>
<TD width=22%>0x4e01</TD>
<TD width=20%>"zh-tw"</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Korean Decimal</TD>
<TD width=22%>0x4e01</TD>
<TD width=20%>"ko"</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Asian Decimal</TD>
<TD width=22%>0x4e01</TD>
<TD width=20%>any other lang</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Asian Kanji</TD>
<TD width=22%>0x58f1</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Traditional Taiwanese</TD>
<TD width=22%>0x58f9</TD>
<TD width=20%>"zh-tw"</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Traditional Chinese</TD>
<TD width=22%>0x58f9</TD>
<TD width=20%>any other lang</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Chinese "Zodiac" 12</TD>
<TD width=22%>0x5b50</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Chinese "Zodiac" 10</TD>
<TD width=22%>0x7532</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Chinese "Zodiac" 60</TD>
<TD width=22%>0x7532, 0x5b50</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Korean Ganada</TD>
<TD width=22%>0xac00</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Korean Decimal</TD>
<TD width=22%>0xc77c</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Korean 99</TD>
<TD width=22%>0xd558</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Western (double-byte)</TD>
<TD width=22%>0xff11</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Japanese Aiueo (single-byte)</TD>
<TD width=22%>0xff71</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>

<TR VALIGN="top">
<TD width=31%>Japanese Iroha (single-byte)</TD>
<TD width=22%>0xff72</TD>
<TD width=20%>n/a</TD>
<TD width=27%>n/a</TD>
</TR>
</table></div>

<P class="fineprint"></P>

<P>If the format token alone is enough to disambiguate a particular numbering scheme, there is no need to specify the language or letter-value.</P>

<P>Here are some examples of conversion specifications.</P>

<P><code class="ce">format="&amp;#x30A2;"</code> specifies Katakana numbering.</P>

<P><code class="ce">format="&amp;#x30A4;"</code> specifies Katakana numbering in the "iroha" order.</P>

<P><code class="ce">format="&amp;#x0E51;"</code> specifies numbering with Thai digits.</P>

<P><code class="ce">format="&amp;#x05D0;" letter-value="traditional"</code> specifies traditional Hebrew numbering.</P>

<P><code class="ce">format="&amp;#x10D0;" letter-value="traditional"</code> specifies Georgian numbering.</P>

<P><code class="ce">format="&amp;#x03B1;" letter-value="traditional"</code> specifies classical Greek numbering.</P>

<P><code class="ce">format="&amp;#x0430;" letter-value="traditional"</code> specifies Old Slavic numbering.</P>

<H4 class="dtH4">Example</H4>

<P>This example demonstrates the use of the <code class="ce">&lt;xsl:number&gt;</code> element by numbering items in a sorted list with Western and then lower-case Roman numbering.</P>

<BLOCKQUOTE class="dtBlock">
<b class="le">Note</b>   To test this example, you need to use a script. For more information, see <A HREF="xslt_howdoi_2put.htm">Initiate XSLT in a Script</A>.</BLOCKQUOTE>

<P class="label"><B>XML File (items.xml)</B></P>

<PRE class="code">&lt;?xml version='1.0'?&gt;
&lt;?xml-stylesheet type="text/xsl" href="numelem.xsl" ?&gt;
&lt;items&gt;
   &lt;item&gt;Car&lt;/item&gt;
   &lt;item&gt;Pen&lt;/item&gt;
   &lt;item&gt;LP Record&lt;/item&gt;
   &lt;item&gt;Wisdom&lt;/item&gt;
   &lt;item&gt;Cell phone&lt;/item&gt;
   &lt;item&gt;Film projector&lt;/item&gt;
   &lt;item&gt;Hole&lt;/item&gt;
   &lt;item&gt;Canopy&lt;/item&gt;
   &lt;item&gt;Widget&lt;/item&gt;
   &lt;item&gt;Concept&lt;/item&gt;
   &lt;item&gt;Null character&lt;/item&gt;
&lt;/items&gt;</PRE>

<P class="label"><B>XSLT File (numelem.xsl)</B></P>

<PRE class="code">&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform" &gt;

&lt;xsl:template match="items"&gt;
   &lt;xsl:for-each select="item"&gt;
      &lt;xsl:sort select="."/&gt;
<B>      &lt;xsl:number value="position()" format="1. "/&gt;</B>
      &lt;xsl:value-of select="."/&gt;, 
<B>      &lt;xsl:number value="position()" format="&amp;#x0069;) "/&gt;</B>
      &lt;xsl:value-of select="."/&gt;
      &lt;br/&gt;
   &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</PRE>

<P class="label"><B>Output</B></P>

<P>This is the formatted output:</P>

<P>1. Canopy, i) Canopy<BR>
2. Car, ii) Car<BR>
3. Cell phone, iii) Cell phone<BR>
4. Concept, iv) Concept<BR>
5. Film projector, v) Film projector<BR>
6. Hole, vi) Hole<BR>
7. LP Record, vii) LP Record<BR>
8. Null character, viii) Null character<BR>
9. Pen, ix) Pen<BR>
10. Widget, x) Widget<BR>
11. Wisdom, xi) Wisdom</P>

<P>This is the processor output:</P>

<PRE class="code">&lt;?xml version="1.0" encoding="UTF-16"?&gt;1. Canopy, 
      i) Canopy&lt;br /&gt;2. Car, 
      ii) Car&lt;br /&gt;3. Cell phone, 
...
      xi) Wisdom&lt;br /&gt;</PRE>

<H4 class="dtH4">See Also</H4>

<P><A HREF="xsl_advanced2_20hg.htm">Inserting Automatic Numbering Using XSLT</A></P>
<H4><A NAME="feedback"></A></H4>
<SPAN id="SDKFeedB"></SPAN>
</div>
</BODY>
</HTML>
