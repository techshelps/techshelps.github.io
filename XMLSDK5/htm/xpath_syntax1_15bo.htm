<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Boolean, Comparison, and Set Expressions</TITLE>
<SCRIPT SRC="../stylesheets/vs70link.js"></SCRIPT>
<SCRIPT SRC="../stylesheets/vs70.js"></SCRIPT>
<SCRIPT LANGUAGE="JScript" SRC="../stylesheets/xmlsdk.js"></SCRIPT></HEAD>
<body topmargin=0 id="bodyID" class = "dtBODY">

<div id="scrbanner">
<div id="bannertitle">
<TABLE CLASS="bannerparthead" CELLSPACING=0>
<TR ID="hdr">
<TD CLASS="bannertitle" nowrap>Microsoft XML Core Services (MSXML) 5.0 for Microsoft Office - XPath Reference</TD><TD valign=middle><a href="#Feedback"><IMG name="feedb" onclick=startFeedback(SDKFeedB) style="CURSOR: hand;" hspace=15 alt="" src="../stylesheets/mailto.gif" align=right></a></TD>
</TR>
</TABLE>
</div>
</div>
<DIV id="scrtext" valign="bottom">
<H1 class="dtH1"><A NAME="xmrefbooleancomparisonset"></A>Boolean, Comparison, and Set Expressions</H1>

<P>Filter patterns can contain Boolean expressions, comparison expressions, and set expressions. Shortcuts listed in the following table represent alternative symbols that are provided in this XSL Transformations (XSLT) implementation. This documentation discusses these expression operators.</P>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=14%>Operator</TH>
<TH width=86%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">and</code></TD>
<TD width=86%>Logical-and</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">or</code></TD>
<TD width=86%>Logical-or</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">not()</code></TD>
<TD width=86%>Negation</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">=</code></TD>
<TD width=86%>Equality</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">!= </code></TD>
<TD width=86%>Not equal</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">&amp;lt; *</code></TD>
<TD width=86%>Less than</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">&amp;lt;= *</code></TD>
<TD width=86%>Less than or equal</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">&amp;gt; *</code></TD>
<TD width=86%>Greater than</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">&amp;lt;= *</code></TD>
<TD width=86%>Greater than or equal</TD>
</TR>

<TR VALIGN="top">
<TD width=14%><code class="ce">|</code></TD>
<TD width=86%>Set operation; returns the union of two sets of nodes</TD>
</TR>
</table></div>

<P class="fineprint">* Extended XPath method</p>
<P>The World Wide Web Consortium (W3C) syntax for operator keywords uses white space and other separators rather than the dollar sign character (<code class="ce">$</code>) used in version 2.5. In the W3C syntax, a binary keyword of the form $xxx$ can be expressed as <I>ws</I>xxx<I>ws,</I> where <I>ws</I> refers to a token terminator that can be white space, single quote characters (<code class="ce">'</code>), or double quote characters (<code class="ce">"</code>). Unary operators such as <code class="ce">not()</code> use functional notation. Although the Microsoft implementation supports both syntaxes, it is recommended that the W3C syntax be used for future compatibility.</P>

<P>Precedence order (from highest to lowest) for comparison operators and Boolean operators is shown in the following table.</P>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TD width=11%>1</TD>
<TD width=40%><code class="ce">( )</code></TD>
<TD width=49%>Grouping</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>2</TD>
<TD width=40%><code class="ce">[ ]</code></TD>
<TD width=49%>Filters</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>3</TD>
<TD width=40%><code class="ce">/ </code>
<P><code class="ce">//</code></P>
</TD>
<TD width=49%>Path operations</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>4</TD>
<TD width=40%><code class="ce">&lt; </code>or<code class="ce"> &amp;lt;</code>
<P><code class="ce">&lt;= </code>or<code class="ce"> &amp;lt;= </code></P>

<P><code class="ce">&gt; </code>or<code class="ce"> &amp;gt; </code></P>

<P><code class="ce">&gt;= </code>or<code class="ce"> &amp;gt;=</code></P>
</TD>
<TD width=49%>Comparisons</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>5</TD>
<TD width=40%><code class="ce">= </code>
<P><code class="ce">!= </code></P>
</TD>
<TD width=49%>Comparisons</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>6</TD>
<TD width=40%><code class="ce">|</code></TD>
<TD width=49%>Union</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>7</TD>
<TD width=40%><code class="ce">not() </code></TD>
<TD width=49%>Boolean not</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>8</TD>
<TD width=40%><code class="ce">And</code></TD>
<TD width=49%>Boolean and</TD>
</TR>

<TR VALIGN="top">
<TD width=11%>9</TD>
<TD width=40%><code class="ce">Or</code></TD>
<TD width=49%>Boolean or</TD>
</TR>
</table></div>

<P class="fineprint"></P>

<P>When the operators are used in an XML document, such as an XSLT style sheet, the <code class="ce">&lt;</code> and <code class="ce">&gt;</code> tokens must be escaped as <code class="ce">&amp;lt;</code> and <code class="ce">&amp;gt;</code>, respectively. For example, the following XSLT instruction invokes an XSLT template rule on all <code class="ce">&lt;book&gt;</code> elements whose <CODE>&lt;price&gt;</CODE> element has a numeric value less than or equal to 10.</P>

<PRE class="code">&lt;xsl:apply-templates select="book[price &amp;lt;= 10]"/&gt;</PRE>

<P>When an XPath expression is used with DOM, the &lt; and &gt; operators need not to be escaped. For example, the following JScript statement selects all <code class="ce">&lt;book&gt;</code> elements whose <CODE>&lt;price&gt;</CODE> element has a numeric value less than or equal to 10.</P>

<PRE class="code">var cheap_books =<I> dom</I>.selectNodes("book[price &lt;= 10]");</PRE>

<P>Boolean expressions can match all nodes of a particular value or all nodes with nodes in particular ranges. The following is an example of a Boolean expression that returns false.</P>

<PRE class="code">1 &amp;gt;= 2</PRE>

<P>Operators are case-sensitive.</P>

<H2 class="dtH2">Logical-and and Logical-or</H2>

<P>The Boolean operators <code class="ce">and</code> and <code class="ce">or</code> perform logical-and and logical-or operations, respectively. These operators, in conjunction with grouping parentheses, can be used to build sophisticated logical expressions.</P>

<H4 class="dtH4">Examples</H4>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=50%>Expression</TH>
<TH width=50%>Refers to</TH>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[degree and award]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain at least one <code class="ce">&lt;degree&gt;</code> element and at least one <code class="ce">&lt;award&gt;</code> element.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[(degree or award) and publication]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain at least one <code class="ce">&lt;degree&gt;</code> or <code class="ce">&lt;award&gt;</code> element, and at least one <code class="ce">&lt;publication&gt;</code> element.</TD>
</TR>
</table></div>

<P class="fineprint"></P>

<H2 class="dtH2">Boolean not</H2>

<P>The Boolean <code class="ce">not</code> operator negates the value of an expression within a filter pattern.</P>

<H4 class="dtH4">Examples</H4>

<P class="fineprint"></P>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TH width=50%>Expression</TH>
<TH width=50%>Refers to</TH>
</TR>

<TR VALIGN="top">
<TD width=50%><code class="ce">author[degree and not(publication)]</code></TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain at least one <code class="ce">&lt;degree&gt;</code> element, but contain no <code class="ce">&lt;publication&gt;</code> elements</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>author[not(degree or award) and publication]</TD>
<TD width=50%>All <code class="ce">&lt;author&gt;</code> elements that contain at least one <code class="ce">&lt;publication&gt;</code> element, but do not contain any <code class="ce">&lt;degree&gt;</code> elements or <code class="ce">&lt;award&gt;</code> elements.</TD>
</TR>
</table></div>

<P class="fineprint"></P>

<H4 class="dtH4">Example</H4>

<P class="label"><B>XML File (test.xml)</B></P>

<PRE class="code">&lt;?xml version="1.0"?&gt;
&lt;test&gt;

    &lt;x a="1"&gt;
      &lt;x a="2" b="B"&gt;
        &lt;x&gt;
          &lt;y&gt;y31&lt;/y&gt;
          &lt;y&gt;y32&lt;/y&gt;
        &lt;/x&gt;
      &lt;/x&gt;
    &lt;/x&gt;

    &lt;x a="2"&gt;
      &lt;y&gt;y2&lt;/y&gt;
    &lt;/x&gt;

    &lt;x a="3"&gt;
      &lt;y&gt;y3&lt;/y&gt;
    &lt;/x&gt;

&lt;/test&gt;</PRE>

<P class="label"><B>XSLT File (test.xsl)</B></P>

<P>The following XSLT stylesheet selects all the &lt;x&gt; elements without any attributes.</P>

<PRE class="code">&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="xml" omit-xml-declaration="yes" indent="yes"/&gt;

&lt;!-- suppress text nodes not covered in subsequent template rule --&gt;
&lt;xsl:template match="text()"/&gt;

&lt;xsl:template match="*"&gt;
   &lt;xsl:element name="{name()}"&gt;
      &lt;xsl:apply-templates select="*|@*"/&gt;
      &lt;xsl:if test="text()"&gt;
         &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="@*"&gt;
   &lt;xsl:attribute name="{name()}"&gt;
      &lt;xsl:value-of select="."/&gt;
   &lt;/xsl:attribute&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/test"&gt;
  <B>&lt;xsl:apply-templates select="//x[not(@*)] "/&gt;</B>
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</PRE>

<P class="label"><B>Output</B></P>

<P>The transformation, when applied to the XML file given above yields the following result:</P>

<PRE class="code">&lt;x&gt;
   &lt;y&gt;y31&lt;/y&gt;
   &lt;y&gt;y32&lt;/y&gt;
&lt;/x&gt;</PRE>
<H4><A NAME="feedback"></A></H4>
<SPAN id="SDKFeedB"></SPAN>
</div>
</BODY>
</HTML>
