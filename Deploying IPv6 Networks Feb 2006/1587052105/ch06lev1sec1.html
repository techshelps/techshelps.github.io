<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>IPv6 Multicast</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><TD valign="top"><a name="ch06lev1sec1"></a>
<H3 class="docSection1Title">IPv6 Multicast</h3>
<p class="docText">An important aspect of the multicast service is addressing. Whereas a unicast address identifies a node, a multicast address identifies a group of nodes interested in the same data. There are no constraints on the location of a group's members. A packet with a multicast destination address (DA) is delivered to all members of the group identified by that address.</p>
<p class="docText"><a name="iddle1386"></a><a name="iddle1412"></a><a name="iddle1435"></a><a name="iddle1514"></a><a name="iddle1598"></a>IPv6 multicast, like unicast, benefits from the new addressing architecture defined in IPv6 for the following reasons:</p>
<ul><li><p class="docList"><span class="docEmphStrong">Larger addressing space</span> implies the availability of plenty of addresses for multicast groups (unicast-based multicast address described in <a class="docLink" href="ch02.html#ch02">Chapter 2</a>, &quot;An IPv6 Refresher,&quot; is a good example). IPv6 addressing lifts major deployment constraints that plagued IPv4; it facilitates and simplifies multicast service deployments.</p><a name="ch06note01"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">IANA assigned the IPv4 Class D addresses, from 224.0.0.0 to 239.255.255.255, to designate IPv4 multicast groups. For more information, visit the IANA website at <a class="docLink" target="_blank" href="http://www.iana.org">http://www.iana.org</a>.</p>
</div><br></li><li><p class="docList"><span class="docEmphStrong">Address scoping</span> offers a cleaner way to contain the multicast traffic within the intended domain.</p><a name="ch06note02"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">In IPv4 only, the fixed multicast scoping (see <a class="docLink" href="ch02.html#ch02">Chapter 2</a>) is defined.</p>
</div><br></LI></UL>
<p class="docText"><a class="docLink" href="ch02.html#ch02">Chapter 2</a> presents the IPv6 multicast addressing architecture for both layer 2 and layer 3 of the OSI model. This chapter builds on that knowledge to provide a review of key concepts such as multicast group, multicast domain, multicast trees, and service-supporting protocols.</p>
<a name="ch06lev2sec1"></a>
<h4 class="docSection2Title">Group Membership Management</h4>
<p class="docText">Multicast addresses define &quot;forums&quot; for applications to deliver their content to. These forums (called <span class="docEmphasis">groups</span>) have a dynamic audience that users can join or leave. On a link, the group is managed through several protocols at both layer 2 and at layer 3 of the OSI model.</p>
<a name="ch06lev3sec1"></a>
<H5 class="docSection3Title">Multicast Listener Discovery</h5>
<p class="docText">The Internet Group Management Protocol (IGMP) is used in IPv4 to enable hosts on a link to join a multicast group, leave it, or simply communicate to a router their group membership. In short, it manages the multicast-related interaction between listeners and routers. IGMP went through several developmental iterations: IGMPv1, IGMPv2, and IGMPv3. The later versions are backward compatible, but each adds features that enhance the operation of its predecessor.</p>
<a name="ch06lev4sec1"></a>
<h5 class="docSection4Title">Protocol Description</h5>
<p class="docText">The Multicast Listener Discovery (MLD) protocol is performing IGMP's function in IPv6. There are two versions of the protocol, MLDv1 and MLDv2. They map identically the last two versions of IGMP, as shown in <a class="docLink" href="#ch06table02">Table 6-2</a>. Similar to IGMP, MLD is built on top of ICMP.</P>
<a name="ch06table02"></a><P><table cellspacing="0" class="allBorders" border="1" RULES="all" cellpadding="4"><caption><H5 class="docTableTitle">Table 6-2. MLD Message Types</h5></caption><colgroup><col width="140"><col width="140"><col width="165"><col width="105"></colgroup><thead><tr><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">MLD</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">IGMP</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">MLD Message Types</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">ICMPv6 Type</p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">IGMPv1 (RFC 1112)</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"></P></td></tr><tr><td class="docTableCell" align="left" valign="top" rowspan="3"><p class="docText">MLDv1 (RFC 2710)</p></td><td class="docTableCell" align="left" valign="top" rowspan="3"><p class="docText">IGMPv2 (RFC 2236)</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Multicast listener query</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">130</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText">Multicast listener report</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">131</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Multicast listener done</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">132</p></td></tr><tr><td class="docTableCell" align="left" valign="top" rowspan="2"><p class="docText">MLDv2 (MLDv2)</p></td><td class="docTableCell" align="left" valign="top" rowspan="2"><p class="docText">IGMPv3 (RFC 3376)</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Multicast listener query</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">130</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">Multicast listener report</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">143</p></td></tr></table></p><br>
<p class="docText">For each of its links, a router has to keep track of all multicast groups that have listeners. It needs to maintain this state to decide whether it should accept traffic for a multicast group and whether it should forward that traffic out its interfaces.</p>
<p class="docText">On the other hand, by default, routers do not have to track every listener on an interface. They just have to know whether there is at least one active listener. To perform this function, on each link a single router is elected to query for listeners. In this sense, on a link a router can be in a querier (sending periodic general queries) or a nonquerier state. All routers start as queriers, but only the one using the lowest source address (SA) (link-local address is used as the SA) on its queries for a given link remains active. The querier sends general queries (&quot;Any listener out there?&quot;) or specific queries (&quot;Any listeners for group G?&quot;). When a router is informed of a listener's departure, the latter query type represents an optimal way to verify whether any other listeners remain in the group that was just left.</p>
<a name="ch06note03"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">If a router queries a specific group, the packet is sent to the multicast address of that group. The response to the query is sent with the same DA, and the router ignores it if the router has not subscribed to that group, too. For this, reason a hop-by-hop extension header with a Router Alert option (see the &quot;<a class="docLink" href="ch02lev1sec2.html#ch02lev3sec8">Hop-by-Hop Options Header</a>&quot; section in <a class="docLink" href="ch02.html#ch02">Chapter 2</a>) is used with the MLD ICMPv6 packets. It forces routers to examine messages destined to multicast groups that the router is not subscribed to.</p>
</div><BR>
<p class="docText">Nodes respond to queries with report messages that indicate the groups and sources their interfaces are listening to. Report (MLDv2) or Done (MLDv1) messages are also sent by nodes to indicate a change in the listening state of one of their interfaces.</p>
<p class="docText">The MLDv1 messages are used to perform the following functions:</p>
<UL><LI><p class="docText"><span class="docEmphStrong">Multicast listener query</span> Used to identify whether a given group has listeners on a link. There are two types of query. The general query sent to the link-local, all-nodes multicast address (FF02::1), and with the MLD Multicast Address field set to :: is used to learn which multicast group has listeners. The multicast address-specific query is used to identify the listeners for a given group that is listed in the MLD Multicast Address field of the message and is sent to the queried multicast address.</p></li><li><p class="docText"><span class="docEmphStrong">Multicast listener report</span> The message used in response to a query. The IPv6 DA for a report is the multicast address being reported.</p></LI><li><p class="docText"><span class="docEmphStrong">Multicast listener done</span> Sent by a node to indicate that it stopped listening to a multicast address. The IPv6 DA for the done message is the link-local, all-routers multicast address (FF02::2).</p></li></ul>
<a name="ch06note04"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">All MLD packets are sent with a link-local address as the IPv6 SA. The hop limit is set to 1. This is done to make sure the packet is not routed outside of the link.</P>
</div><BR>
<p class="docText">MLDv2 enhances MLDv1 by enabling a node to express or report interest in a particular source for a multicast group. This capability optimizes the multicast operation through a more discrete control of group membership. It also provides the support for the Source Specific Multicast (SSM) deployment model that is discussed later in this chapter.</p>
<p class="docText">The MLDv2 query message performs the same functions as its MLDv1 counterpart. In addition, it supports multicast-source specific queries. The capabilities of the report message were also enhanced for MLDv2. It concatenates a set of records, each record containing information that relates to a given multicast address. This structure offers enough flexibility to the MLDv2 report message to perform the function of the MLDv1 done message, too. MLDv2 does not use done messages.</p>
<a name="ch06note05"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">MLDv2 is backward compatible with MLDv1, and for this reason it must support the MLDv1 messages, including the 131 and 132 types (see <a class="docLink" href="#ch06table02">Table 6-2</a>).</p>
</div><br>
<p class="docText"><a class="docLink" href="#ch06fig01">Figure 6-1</a> summarizes some aspects of the MLDv2-governed listener-router interaction on a link.</p>
<a name="ch06fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 6-1. Conceptual Representation of Listener-Router Interaction on a Link</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/06fig01_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="387" SRC="images/06fig01.jpg"></p>
</center></p><br>
<p class="docText">On Cisco routers, MLDv2 is enabled by default on all interfaces as soon as multicast routing is globally enabled on the router (using the global configuration command <span class="docEmphStrong">ipv6 multicast-routing</span>). <a class="docLink" href="#ch06ex01">Example 6-1</a> shows an example of the MLD operational status on an interface.</p>
<a name="ch06ex01"></a><h5 class="docExampleTitle">Example 6-1. MLD Operational Status on a Router Interface</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>


<pre>Router#<span class="docEmphStrong">show ipv6 mld interface GE-WAN1/1.1</span>
GE-WAN1/1.1 is up, line protocol is up
  Internet address is ::/10
  MLD is enabled on interface
  <span class="docEmphMark">Current MLD version is 2</span>
  <span class="docEmphMark">MLD query interval is 125 seconds</span>
  <span class="docEmphMark">MLD querier timeout is 255 seconds</span>
  <span class="docEmphMark">MLD max query response time is 10 seconds</span>
  Last member query response interval is 1 seconds
  <span class="docEmphMark">MLD activity: 4 joins, 0 leaves</span>
  <span class="docEmphMark">MLD querying router is FE80::20D:29FF:FEE1:4DC0 (this system)</span></pre><BR>

</td></tr></table></p>
<p class="docText">The MLD-specific parameters such as query interval, timeout, or max response time that are highlighted in the example above can be configured under each interface. The output <a name="iddle1610"></a><a name="iddle1940"></a>also lists the querier for the link; in this case, it is FE80::20D:29FF:FEE1:4DC0, the router in the example.</p>

<a name="ch06lev4sec2"></a>
<h5 class="docSection4Title">Source Specific Multicast Mapping for MLDv1</h5>
<p class="docText">The SSM service model discussed later in this chapter requires a host to specify both the multicast group it intends to join and the specific source it intends to listen to. Only MLDv2 supports this functionality on the hosts. Although SSM is a popular deployment model, MLDv2 is not commonly implemented on IPv6 stacks at the time of this writing, so a solution is necessary to make SSM work with MLDv1. This solution is called <span class="docEmphasis">SSM mapping for MLDv1</span>, and it operates in two modes:</p>
<ul><li><p class="docText"><span class="docEmphStrong">Statically configured mapping</span> A source (S) is statically mapped to a given group (G) on the router. The router maps any (*,G) MLDv1 report to an (S,G) based on the configured mapping. This mapping feature is off by default on a router. It is enabled with the global command <span class="docEmphStrong">ipv6 mld ssm-map enable</span>. The static mapping is configured with the global command <span class="docEmphStrong">ipv6 mld ssm-map static &lt;<span class="docEmphasis">ACL</span>&gt; source &lt;<span class="docEmphasis">source</span>&gt;,</span> where the access control list (ACL) identifies the groups mapped to a given source.</p></li><li><p class="docText"><span class="docEmphStrong">Dynamically configured mapping</span> An AAAA record (see <a class="docLink" href="ch03.html#ch03">Chapter 3</a>, &quot;Delivering IPv6 Unicast Services&quot;) is configured for G in a DNS server. When the router receives an MLDv1 report for (*,G), it does a reverse DNS lookup querying for G's record. The DNS server returns the corresponding S for G. After the SSM mapping has been enabled globally, as previously shown, you can configure the dynamic mapping option with the global command <span class="docEmphStrong">ipv6 mld ssm-map query dns</span>. In this case, the IP address of the DNS server must be configured on the router, too (<span class="docEmphStrong">ip name-server &lt;<span class="docEmphasis">IP address</span>&gt;</span>). The DNS server can be reached over IPv6 or over IPv4 in a dual-stack network.</P></li></ul>
<p class="docText">This feature, available on Cisco routers, enables IPv6 hosts supporting only MLDv1 to receive SSM-based multicast services.</P>
<a name="ch06note06"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">IPv4 faces the same problem of little support for the newer IGMPv3 protocol. While the host stacks are getting updated to include IGMPv3, the same mapping solution is available to enable IGMPv1/v2-capable hosts to participate in SSM-based multicast service deployments. The feature is called <span class="docEmphasis">SSM mapping for IGMPv1/v2</span>.</p>
</div><br>

<a name="ch06lev4sec3"></a>
<h5 class="docSection4Title">MLD Access Control and Explicit Tracking</h5>
<p class="docText">Two useful MLD features enable network administrators to block unauthorized user access to multicast resources and to monitor individual MLD client activity on an interface:</P>
<ul><li><p class="docText"><span class="docEmphStrong">MLD access control</span> Configured on a router interface, MLD access control filters inbound MLD reports for groups and sources based on a defined access list. The ACL SA matches the address of the multicast source and the ACL DA matches the group address. <a class="docLink" href="#ch06ex02">Example 6-2</a> shows the configuration of this feature.</p><a name="ch06ex02"></a><h5 class="docExampleTitle">Example 6-2. Denying User Access to (2001::1,FF3A::1) and Permitting All the Other Sources for (*,FF3A ::1)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<pre>Router(config)# <span class="docEmphStrong">ipv6 access-list mld-acc-control</span>
Router(config-ipv6-acl)# <span class="docEmphStrong">deny ipv6 host 2001::1 host ff3a::1</span>
Router(config-ipv6-acl)# <span class="docEmphStrong">permit ipv6 any host ff3a::1</span>
Router(config-ipv6-acl)# <span class="docEmphStrong">interface GE-WAN1/1.1</span>
Router(config-if)# <span class="docEmphStrong">ipv6 mld access-group mld-acc-control</span></pre><br>

</td></tr></table></p><p class="docList"><a name="iddle1380"></a><a name="iddle1481"></a><a name="iddle1616"></a><a name="iddle1791"></a><a name="iddle1811"></a>In <a class="docLink" href="#ch06ex02">Example 6-2</a>, the ACL identifies reports for group FF3A::1 and source 2001::1 to be rejected; reports for all other sources of the group are to be accepted.</p></li><li><p class="docText"><span class="docEmphStrong">Explicit tracking (ET)</span> Configured on a router interface (<span class="docEmphStrong">ipv6 mld explicit-tracking</span> &lt;<span class="docEmphBoldItalic">access-list</span>&gt;), ET enables the router to explicitly track each multicast client on that interface. By default, the router is interested in knowing only whether it has any listeners for a group on the interface, so it does not monitor individual listeners. The tracking can be done for all multicast groups or for a subset identified via an access list. The matching rules described for MLD access control apply in this case, too. When ET is enabled on an interface, the router can use the fast-leave mechanism available for MLDv2. In other words, it does not have to query the link for other listeners after each report of a listener leaving a group. The router knows at all times how many listeners are subscribed to each group, and this information can be viewed with the command <span class="docEmphStrong">show ipv6 mld traffic</span>.</p></li></ul>
<p class="docText">MLD access control and ET are currently available with Cisco IOS routers.</p>
<p class="docText">Another useful MLD feature is MLD authentication, authorization, and accounting (AAA). It complements the other two features by offering network operators the means to dynamically control user access and to perform billing for the services accessed. This feature will soon be available on Cisco routers.</p>


<a name="ch06lev3sec2"></a>
<h5 class="docSection3Title">Multicast Layer 2 Protocols</H5>
<p class="docText">Protocols managing the multicast traffic at layer 2 can help improve layer 2 device operation. Several protocols that would make switches aware of multicast group membership were developed for IPv4, including the Cisco Group Management Protocol (CGMP). CGMP enables routers to provide connected switches with listener information, and IGMP snooping enables the switches to learn a port's group membership by monitoring its IGMP traffic. These mechanisms allow layer 2 switches to forward the multicast traffic only to those ports within a VLAN that have listeners and thus avoid flooding it on every port.</P>
<a name="ch06note07"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">Other protocols have been developed for IPv4 to optimize the layer 2 forwarding of multicast traffic but have not yet been considered for IPv6. Two of these are Router Group Management Protocol (RGMP; RFC 3488) and GARP (Generic Attribute Registration Protocol) Multicast Registration Protocol.</P>
</div><BR>
<p class="docText"><a name="iddle1366"></a><a name="iddle1499"></a><a name="iddle1596"></a><a name="iddle1617"></a><a name="iddle1778"></a><a name="iddle1830"></a><a name="iddle1843"></a><a name="iddle1926"></a><a name="iddle1937"></a>Although you can implement CGMP and snooping for IPv6 (as you can with IPv4), you must consider some IPv6 specificities. Multicast is extensively used in IPv6 to perform basic functionality such as neighbor discovery. Each node has to subscribe to multiple groups that are dedicated to proper link operation. A node's basic operation can be severely impacted if it is not generating enough MLD traffic that would allow a snooping switch to be aware of all the groups the node listens to.</p>
<p class="docText">On layer 2 Cisco devices, MLD snooping is available today and is enabled by default. You can enable the feature with the command <span class="docEmphStrong">ipv6 mld snooping</span> (if disabled); the feature has tuning parameters such as rate limiting and number of layer 2 entries that can be installed by MLD snooping. There are no plans to implement CGMP for IPv6 at the time of this writing.</p>


<a name="ch06lev2sec2"></a>
<h4 class="docSection2Title">Multicast Routing and Forwarding</h4>
<p class="docText">MLD enables routers to learn and manage listeners directly connected to them. The next step in building a multicast-aware network is to enable the routers to inform each other of their listeners' interest in a multicast group. These routers can then collectively build the optimal path for the multicast traffic from the sources to the listeners.</p>
<a name="ch06lev3sec3"></a>
<h5 class="docSection3Title">Multicast Distribution Trees</h5>
<p class="docText">A fundamental concept of multicast routing and forwarding is that of a multicast distribution tree (MDT). Its branches lead to routers that service networks hosting listeners. As listeners join or leave, branches are added to or pruned from the tree. Why a tree? Because with all the replication of traffic, the last thing one wants to have in the network is looped multicast traffic.</p>
<p class="docText">The question that follows the decision to use distribution trees is this: Where should the root of the MDT be located? Generally speaking, the optimal path for the multicast traffic is that of a tree that has the root at the source of the traffic. This is called a <span class="docEmphasis">shortest path tree</span> (SPT), and it is identified by the (S,G) tuple, where S is the address of the source and G is the address of the multicast group. All the routers that are part of an (S,G) tree have to maintain state for it. In fact, routers have to maintain state for each source-group pair used in the network. This can become a burden when a large number of (S,G)s are present.</p>
<p class="docText">When multiple sources serve the same G, it might be worthwhile to share a common distribution tree. A shared tree is identified as (*,G). The shared tree (ST) is rooted in an administratively selected router called <span class="docEmphasis">rendezvous point</span> (RP). One RP is active for each group, but the same RP can handle multiple groups. Sources register with the RP and their traffic is forwarded over an (S,G) to the RP and from there down the shared tree. This traffic enables edge routers to learn about the existence of these sources.</p>
<p class="docText">The shared tree is a common information resource for the multicast domain, but it cannot be the optimal path for all multicast sources. If an edge router has listeners for a given group, <a name="iddle1790"></a><a name="iddle1849"></a>once it learns about a source, it can choose to switch to an SPT that offers optimal forwarding of the multicast traffic. <a class="docLink" href="#ch06fig02">Figure 6-2</a> shows a shared tree and an SPT over the same topology.</p>
<a name="ch06fig02"></a><p><center>
<H5 class="docFigureTitle">Figure 6-2. Multicast Distribution Tree Types</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/06fig02_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="315" SRC="images/06fig02.jpg"></p>
</center></P><BR>
<a name="ch06note08"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">The two tree types have advantages and disadvantages. With SPT, routers require more memory to maintain the state of multiple trees. On the other hand, the SPT will always offer the optimal path between the source and destination, whereas that might not always be the case when using an ST. Nonoptimal paths can lead to packet delays and delay variations. The SPT also offers more protection against denial-of-service (DoS) attacks. An RP could be an easy target.</p>
</div><br>

<a name="ch06lev3sec4"></a>
<h5 class="docSection3Title">Reverse-Path Forwarding Determination</H5>
<p class="docText">Regardless of tree type, the control messages used to build and manage it are always sent toward the root. Whether it is the multicast source or the RP, routers need to find the next hop on the reverse path (with respect to the flow of multicast traffic) toward them. The process of identifying this upstream neighbor is called reverse-path forwarding (RPF) calculation.</p>
<p class="docText">To decide the outbound interface for these messages, a router has to be aware of the network topology. Because multicast routing builds and maintains state only for MDT, a router relies <a name="iddle1498"></a><a name="iddle1625"></a>on the underlying unicast routing protocols for network topology information. Based on this information, it executes an RPF calculation and it identifies the best upstream interface toward the RP or the source.</p>
<p class="docText">The following information is examined in the RPF calculation process:</p>
<ul><LI><p class="docList">Static multicast routes</P></LI><li><p class="docList">MBGP (Multiprotocol BGP) multicast routes</p></li><li><p class="docList">IPv6 unicast routing information stored in the Routing Information Base (RIB) and provided by static routes, RIPng, EIGRP, OSPFv3, and IS-IS but excluding BGP unicast routes</p></li></ul>
<a name="ch06note09"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">By default, a static route is installed in the unicast RIB, and it is used for multicast RPF calculation, too. Enhancements made to the configuration syntax allow for static routes to be configured for unicast only or for the multicast RPF calculation only.</p>
</div><br>
<p class="docText">First, the longest-match is searched across the three databases. If two or more equivalent routes are found across the tables, the tiebreaker used is the administrative distance. If the tie remains, the route found in the first of the tables listed above will be selected.</p>
<a name="ch06note10"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">A less-optimal distance-only criteria is currently used in IPv4 multicast RPF calculation. A route with a shorter prefix length can be preferred because its administrative distance happens to be lower than a route with a longer prefix length.</p>
</div><br>
<a name="ch06note11"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">The RPF calculation takes into account the existence of multiple equal paths to multicast sources. A hash is done between the last 32 bits of the source and the last 32 bits of the available next hops to select from among the interfaces that can be used to receive the multicast traffic. The interface returned by the RPF calculation will be used for all multicast traffic from a given source. This leads to the load balancing of the multicast traffic on a per-source basis.</P>
</div><BR>
<p class="docText">Changes to IPv6 BGP/MBGP led to a different approach to using BGP routes for RPF calculation. Based on RFC 2545 and RFC 2858, the following types of routes are advertised by MBGP:</P>
<UL><li><p class="docList"><span class="docEmphStrong">Unicast-only routes</span> are marked with SAFI=1. For this reason, the BGP entries in the unicast RIB are ignored. However, you can enable routers to use the BGP unicast routes for RPF with the command <span class="docEmphStrong">ipv6 rpf use-bgp</span>.</p></li><li><p class="docList"><span class="docEmphStrong">Multicast-only routes</span> are marked with SAFI=2. These routes cannot be used for unicast. The same SAFI=2 is available with IPv4.</p></li></ul>
<a name="ch06note12"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">IETF decided to remove SAFI=3, which was marking routes to be used for both unicast and multicast routing.</p>
</div><br>
<p class="docText">With MBGP, an IPv6 multicast address family can be defined for exchanging routes to be used in multicast routing. The routing information available via static routes and RIB is used for multicast routing purposes and is maintained in the MRIB (Multicast RIB). There is, however, no mapping of the MRIB for MBGP.</p>
<p class="docText">Because it can carry multicast routes, MBGP provides the means to exchange IPv6 multicast-relevant routing information between PIM domains. You can enable the BGP process on a Cisco router to exchange IPv6 multicast routing information by simply configuring a new address family with the command <span class="docEmphStrong">address-family ipv6 multicast</span>, as shown in <a class="docLink" href="#ch06ex03">Example 6-3</a>.</p>
<a name="ch06ex03"></a><H5 class="docExampleTitle">Example 6-3. Enabling BGP to Exchange IPv6 Multicast Routes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>


<pre><span class="docEmphMark">router bgp 200</span>
 bgp router-id 200.200.200.200
 <span class="docEmphMark">no bgp default ipv4-unicast</span>
 bgp log-neighbor-changes
 <span class="docEmphMark">neighbor 2001:D:1::2 remote-as 201</span>
 <span class="docEmphMark">neighbor 2001:D:1::2 update-source GigabitEthernet0/1</span>
 !
 <span class="docEmphMark">address-family ipv6 multicast</span>
 <span class="docEmphMark">neighbor 2001:D:1::2 activate</span>
 <span class="docEmphMark">network 2001:D:AAAA:1::/64</span>
 exit-address-family</pre><br>

</td></tr></table></p>
<p class="docText">The highlights in the preceding example indicate that the IPv6 multicast address family enables BGP process 200 to exchange IPv6 multicast information with neighbor 2001:D:1::2. In this example, prefix 2001:D:AAAA:1::/64 is advertised for multicast routing only. You can view information regarding the multicast routes exchanged via MBGP through the various options available with the <span class="docEmphStrong">show bgp ipv6 multicast</span> command. The command's output on the peer (201.201.201.201 with address 2001:D:1::2) of the router configured in <a class="docLink" href="#ch06ex03">Example 6-3</a> shows the advertised prefix.</P>
<a name="ch06ex04"></a><h5 class="docExampleTitle">Example 6-4. IPv6 Multicast Route Advertised via BGP</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<pre>MBGP-Peer-Router#<span class="docEmphStrong">show bgp ipv6 multicast</span>
BGP table version is 182, local router ID is 201.201.201.201
Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,
              r RIB-failure, S Stale
Origin codes: i - IGP, e - EGP, ? - incomplete
   Network          Next Hop            Metric LocPrf Weight Path
*&gt; <span class="docEmphMark">2001:D:AAAA:1::/64</span>
                    <span class="docEmphMark">2001:D:1::1              0             0 200 i</span></pre><BR>

</TD></tr></table></p>
<p class="docText"><a name="iddle1963"></a><a name="iddle1975"></a>In the cases where the BGP neighbor does not support the multicast SAFI, additional configuration on the SAFI-aware router facilitates the exchange of multicast routes through the unicast address family, as shown in <a class="docLink" href="#ch06ex05">Example 6-5</a>.</p>
<a name="ch06ex05"></a><h5 class="docExampleTitle">Example 6-5. Enabling BGP Process to Exchange IPv6 Routes with a Neighbor That Does Not Support the Multicast SAFI</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>


<pre><span class="docEmphMark">address-family ipv6</span>
<span class="docEmphMark">neighbor 2001:D:1::2 translate-update ipv6 multicast unicast</span>
neighbor 2001:D:1::2 activate
no synchronization
exit-address-family
<span class="docEmphMark">address-family ipv6 multicast</span>
<span class="docEmphMark">neighbor 2001:D:1::2 activate</span></pre><br>

</td></tr></table></p>
<p class="docText">It is also worth observing that whereas the RPF calculation returns a next hop for the reverse path based on the IPv6 unicast topology, with IPv6 this result does not always match the address of the upstream PIM neighbor because the router might have multiple addresses on the interconnecting link. In this case, the unicast topology is not congruent with the PIM topology in terms of next-hop addresses. The PIM Hello message used in building PIM neighbors was enhanced to avoid this type of situation. The Routable Address option of the PIM Hello message enables the router to list all its addresses on the interface over which the Hello is sent. The address of a next-hop router generated by an RPF calculation is always compared with the addresses it listed in the Routable Address option of its PIM Hello messages.</p>
<p class="docText">Routers also use RPF checks to ensure a loop-free distribution of multicast traffic throughout the network. After PIM builds the distribution tree, routers do an RPF check on the SA of all received multicast packets. If the RPF check matches the upstream interface in the distribution tree, the packet is forwarded downstream; otherwise, it is discarded.</p>

<a name="ch06lev3sec5"></a>
<H5 class="docSection3Title">Protocol Independent Multicast</H5>
<p class="docText">Multicast routing represents the process of building the MDT. The tree topology information is collected and maintained in the Tree Information Base (TIB). Many protocols were developed to support this process. They all leverage one or both of the tree types mentioned. Distance Vector Multicast Protocol (DVMRP), Multicast Open Shortest Path First (MOSPF), Core Based Trees (CBT), Protocol Independent Multicast (PIM), and Pragmatic General Multicast (PGM) all dealt with certain models of service delivery, and catered to certain application needs. In time, implementation issues and deployment experiences trimmed down the number of preferred IPv4 multicast routing protocols to PIM variants.</P>
<p class="docText"><a name="iddle1711"></a><a name="iddle1713"></a><a name="iddle1714"></a>Learning from its predecessor, IPv6 adopted only three multicast routing protocols:</P>
<UL><li><p class="docList">PIM-SM for many-to-many applications, where multiple sources transmit to the same group. The typical applications are videoconferencing or peer-to-peer gaming.</p></li><li><p class="docList">PIM-SSM is a subset of PIM-SM, and it is used for one-to-many applications, where a single source transmits to multiple listeners. The typical applications are content delivery such as video or audio programs.</p></li><li><p class="docList">PIM-Bidir is used for many-to-many applications, where all members of the group can be both receivers and sources. PIM-Bidir is the recommended routing protocol for &quot;hoot 'n' holler&quot; applications, which enable any host to send a message to a group it belongs to.</p></li></ul>
<a name="ch06note13"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">PIM-SM, PIM-SSM, and PIM-Bidir operate based on a &quot;pull&quot; model, where each router requests, or pulls, the multicast information from the source or RP whenever it has listeners or downstream clients. The MDT is built based on demand. By contrast, the &quot;push&quot; model is sending, or pushing, the multicast information to all routers, so at first all routers are part of the MDT. The nodes that are not interested in that multicast are later trimmed from the tree. PIM-Dense Mode supports the &quot;push&quot; multicast model. IPv6 multicast does not support PIM-DM.</p>
</div><BR>
<p class="docText">IPv6 PIM implementation is similar to IPv4. As a matter of fact, the PIM protocol standards are transparent with respect to the version of IP. For these reasons, you can reference multicast technology-specific references such as <span class="docEmphasis">Developing IP Multicast Networks, Volume 1</span>, by Beau Williamson, to gain an in-depth understanding of the PIM protocol.</p>
<p class="docText">In this brief review of the protocol, let's start with an important element in its operation, the designated router (DR) election. PIM routers build adjacencies between themselves. If two or more PIM routers are on the same multi-access link, they elect a DR to handle the PIM control traffic coming from and going to that link. The DR is the router that registers any source on the link. The DR is also the router that joins a tree when a listener becomes active on the link. The PIM router with the highest IPv6 address or the highest priority (configurable via the <span class="docEmphStrong">ipv6 pim dr-priority</span> interface command) is elected the DR for a multi-access network.</p>
<a name="ch06note14"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">The DR election process uses different rules than the querier election process described earlier in the &quot;<a class="docLink" href="#ch06lev3sec1">Multicast Listener Discovery</a>&quot; section. This means that different routers on the same link might perform these two functions.</P>
</div><br>
<p class="docText">This concept, along with that of RPF, identifies the source and the destination of PIM join messages sent by routers in the process of building the MDT.</p>
<a name="ch06lev4sec4"></a>
<h5 class="docSection4Title">PIM-SM</h5>
<p class="docText">It is important to understand PIM-SM because the other two variants, PIM-SSM and PIM-Bidir, can be viewed as two of its special cases. There are two interesting events in the operation of PIM-SM:</P>
<ul><li><p class="docList">Multicast source registration with an RP</p></li><LI><p class="docList">Multicast listener joining the group</P></LI></ul>
<p class="docText">Let's assume that in a multicast domain, the shared tree with the root in the RP is already in place. Multicast sources for a given group need to register with the RP defined for that group. Based on the PIM draft's recommendation, a virtual tunnel interface is used by routers to register sources connected to them. The tunnel is unidirectional, and it is used to send register messages to the RP. A tunnel interface is created for each RP defined or advertised in the PIM domain.</p>
<p class="docText"><a class="docLink" href="#ch06ex06">Example 6-6</a> shows interface Tunnel 1 created for the RP 2001:D:AAAA:1::1.</p>
<a name="ch06ex06"></a><h5 class="docExampleTitle">Example 6-6. Tunnel Interface Created to Communicate with a Known RP</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>


<pre>Router#<span class="docEmphStrong">show ipv6 pim tunnel</span>
<span class="docEmphMark">Tunnel1*</span>
  <span class="docEmphMark">Type  : PIM Encap</span>
  <span class="docEmphMark">RP    : 2001:D:AAAA:1::1</span>
  <span class="docEmphMark">Source: 2001:1:FFFF:FFFF:2::</span></pre><br>

</td></tr></table></p>
<p class="docText">The tunnel interface can be created only for the registration process, and then it can be removed. Cisco IOS software, however, keeps the tunnel interface active for as long as the RP is known. The tunnel interface comes up when the RPF calculation for the RP returns an output interface and there is a unicast route installed for the RP (see <a class="docLink" href="#ch06ex07">Example 6-7</a>).</p>
<a name="ch06ex07"></a><h5 class="docExampleTitle">Example 6-7. Relevant Information for the Tunnel Interface Used for Registering with a Known RP</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>


<pre>Router#<span class="docEmphStrong">show interfaces Tunnel1</span>
<span class="docEmphMark">Tunnel1 is up, line protocol is up</span>
  Hardware is Tunnel
  MTU 1514 bytes, BW 9 Kbit, DLY 500000 usec,
     reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation TUNNEL, loopback not set
  Keepalive not set
  <span class="docEmphMark">Tunnel source 2001:1:FFFF:FFFF:2:: (Loopback0), destination 2001:D:AAAA:1::1</span>
  <span class="docEmphMark">Tunnel protocol/transport PIM/IPv6, key disabled, sequencing disabled</span>
  Tunnel TTL 255
  Checksumming of packets disabled
  <span class="docEmphMark">Tunnel is transmit only</span></pre><BR>

</td></tr></table></p>
<a name="ch06note15"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText"><a class="docLink" href="#ch06ex07">Example 6-7</a> refers to the tunnel interfaces created on non-RP routers. On the RP side, a single tunnel is used for all registering tunnels set up to it.</p>
</div><br>
<p class="docText">When a DR receives multicast traffic from a connected source, it analyzes the group address to find its RP. It then encapsulates the multicast traffic and sends it through the appropriate tunnel interface to the appropriate RP. After the source has been registered, the RP sends register-stop messages outside of the tunnel over an SPT built between the source and the RP. From there on, the multicast traffic originated by that source will flow unencapsulated over the shortest path to the RP and then down the shared tree. The leaf routers of the ST use this traffic to learn about the registered sources. <a class="docLink" href="#ch06fig03">Figure 6-3</a> summarizes the source registration process.</p>
<a name="ch06fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 6-3. Conceptual Representation of Source Registration with PIM-SM</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/06fig03_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="373" SRC="images/06fig03.jpg"></p>
</center></p><BR>
<p class="docText">Consider now how the shared tree is built. When a listener expresses interest in a G by sending MLD reports, the routers on that link install their interface in a list of output interfaces for that multicast traffic. However, only the DR looks up the RP-to-group mapping, identifies the group's RP, and sends a PIM (*,G) join to the upstream neighbor out the interface that is the result of the RPF calculation for that RP. Through this process, all routers that are interested in traffic for group G form an MDT, the ST identified as (*,G).</p>
<p class="docText">It was mentioned earlier that routers learn about sources for a group G through traffic that comes down the ST. When a DR learns about a certain source, the DR sends an (S,G) PIM join message directly toward the source. The routers along the reverse path analyze the metric to the source versus the one to the RP and forward the joins up the shortest path, thus building an (S,G) SPT. The DR can choose to switch over to receiving traffic over the SPT rather than the ST for better delay characteristics.</p>
<a name="ch06note16"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">Cisco routers, by default, immediately switch over from the ST to the SPT for traffic forwarding. To stop the switchover and have routers use only the ST for forwarding multicast traffic, you must configure them globally with the <span class="docEmphStrong">ipv6 pim spt-threshold infinity</span> command.</P>
</div><br>
<p class="docText"><a class="docLink" href="#ch06fig04">Figure 6-4</a> summarizes this process.</p>
<a name="ch06fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 6-4. Conceptual Representation of Listener Join with PIM-SM</H5>
<p class="docText"><div class="v1"><a target="_self" href="images/06fig04_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="382" SRC="images/06fig04.jpg"></p>
</center></p><br>
<a name="ch06note17"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText"><a name="iddle1715"></a><a name="iddle1847"></a><a name="iddle1848"></a>In a router, an MDT's representation consists of an upstream neighbor identified through the RPF calculation and an outgoing interface list (OIL). The OIL in IPv6 has two types of entries (unlike IPv4, in which a single list is used):</P>
<UL><LI><p class="docText"><span class="docEmphStrong">Immediate OIL</span> Generated by PIM joins/leaves and by MLD report messages. They reflect the tree topology and can be seen in the output of <span class="docEmphStrong">show ipv6 pim topology</span>.</p></li><li><p class="docText"><span class="docEmphStrong">Inherited OIL</span> Interfaces inherited by an (S,G) from a (*,G). You can see the inherited OIL and the immediate OIL in the MRIB with the <span class="docEmphStrong">show ipv6 mrib route</span> command.</p></li></ul>
</div><br>
<p class="docText">PIM-SM builds shared trees and requires the use of at least one rendezvous point (RP) for every multicast group. Different RPs can handle different multicast groups, and for this reason PIM has to be complemented by a mechanism that allows routers to learn which RP to use for a given group. Such mapping mechanisms are needed both within a PIM domain and between various domains. A discussion of the mapping methods available with IPv6 multicast follows in the &quot;<a class="docLink" href="#ch06lev3sec7">RP Mapping and Redundancy</a>&quot; section of this chapter. PIM also builds SPTs that are used by default for traffic forwarding.</p>
<p class="docText">By default, PIM runs on all interfaces of a Cisco router enabled for multicast routing (using the global configuration command <span class="docEmphStrong">ipv6 multicast-routing</span>). You can disable PIM per interface by using the command <span class="docEmphStrong">no ipv6 pim</span>. For PIM-SM, you can configure an RP globally with the <span class="docEmphStrong">ipv6 pim rp-address &lt;<span class="docEmphasis">IPv6-address</span>&gt; command</span>.</p>
<p class="docText">The PIM-relevant information can be viewed with the help of the various options available with the command <span class="docEmphStrong">show ipv6 pim</span> (see <a class="docLink" href="#ch06ex08">Example 6-8</a>).</p>
<a name="ch06ex08"></a><h5 class="docExampleTitle">Example 6-8. Options Available for the show ipv6 pim Command</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>


<pre>Router#<span class="docEmphStrong">show ipv6 pim ?</span>
  bsr         PIM Bootstrap router
  df          Bidir Designated Forwarder
  group-map   PIM group-to-protocol mapping information
  interface   PIM interface information
  join-prune  PIM Join/Prune information
  neighbor    PIM neighbor information
  range-list  PIM range-list information
  topology    PIM topology table information
  traffic     PIM traffic counters
  tunnel      List PIM tunnel interfaces</pre><BR>

</TD></TR></table></P>

<a name="ch06lev4sec5"></a>
<h5 class="docSection4Title">PIM-SSM</h5>
<p class="docText">PIM-SSM represents a subset of PIM-SM. In this case, the listener knows <span class="docEmphasis">a priori</span> both the group and the source (S,G) it wants to join. PIM-SSM operates similarly to PIM-SM, but it does not build a shared tree and so it does not need an RP. The listener must be able to <a name="iddle1500"></a><a name="iddle1597"></a><a name="iddle1602"></a><a name="iddle1605"></a><a name="iddle1712"></a><a name="iddle1846"></a>indicate to its DR what (S,G) it is interested in. For this reason, MLDv2 listener or the SSM MLDv1 mapping router support is required for a PIM-SSM deployment.</p>
<p class="docText">Because it builds only (S,G)s, the deployment and management of the service is much easier than for PIM-SM. Moreover, there is no need for additional protocols that help manage the RP. On the other hand, managing the distribution of source information to listeners might represent a challenge. Application layer protocols, independent of PIM, are needed to help hosts automatically discover the source of a given group. Work is being done in this area, but for the time being the most common way to distribute source information is via a known repository such as a web page.</p>

<a name="ch06lev4sec6"></a>
<h5 class="docSection4Title">PIM-Bidir</h5>
<p class="docText">Bidirectional PIM is an extension of PIM optimized for many-to-many communications. It represents the other end of the spectrum in terms of MDT types used. PIM-Bidir, like PIM-SM, uses shared trees, but it never builds SPTs. There is no source registration process, so the traffic is unconditionally forwarded on the ST. This allows it to scale to an arbitrary number of sources with minimal additional overhead. The ST is bidirectional in the case of PIM-Bidir. Under these circumstances, RPF is not operating as in the case of PIM-SM, and the RP becomes the reference point in maintaining a loop-free network. In the case of PIM-Bidir, the RP is configured with <span class="docEmphStrong">ipv6 pim rp-address &lt;<span class="docEmphasis">IPv6-address</span>&gt; bidir</span>.</p>
<p class="docText">Ultimately, the multicast routing protocol selection is done based on the application types and service models that are being deployed. Cisco routers can support all three IPv6 PIM protocols simultaneously for different multicast groups.</p>
<p class="docText">Based on the routing, tree topology, and group membership information available, forwarding decisions are made for the multicast traffic, and they are mapped into the Multicast Forwarding Information Base (MFIB). The MFIB relates to the MRIB in the same way the RIB relates to FIB for unicast.</p>



<a name="ch06lev2sec3"></a>
<h4 class="docSection2Title">Deployment Considerations</h4>
<p class="docText">Along with MLD and PIM, a few additional operational aspects are important when deploying an IPv6 multicast service. Some mechanisms help manage the multicast domain, and some mechanisms help routers correlate multicast groups to RPs that serve them. These mechanisms, together with the multicast protocols already discussed, fit into complete service architectures that provide the network-wide perspective on deploying IPv6 multicast. These topics are analyzed in this section.</p>
<a name="ch06lev3sec6"></a>
<H5 class="docSection3Title">Multicast Domain Control</h5>
<p class="docText">For scalability considerations, it is advisable at times to segment the network in PIM domains. The PIM messages are contained within the PIM domain, leading to smaller-size MDTs. This smaller size translates into fewer states to maintain and a lighter RP utilization.</p>
<a name="ch06note18"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText"><a name="iddle1154"></a><a name="iddle1159"></a><a name="iddle1608"></a>It is worthwhile to note that although PIM uses unicast routing information for RPF calculation, a PIM domain is not necessarily the same as a routing domain.</P>
</div><br>
<p class="docText">The techniques used with IPv4 for multicast domain control, such as Time-To-Live (TTL) constraints and ACLs, can be used in the case of IPv6, too. On the other hand, IPv6's address scoping provides a powerful tool to implement domain control in a cleaner way. You can define boundaries on router interfaces for various address scopes.</p>

<a name="ch06lev3sec7"></a>
<h5 class="docSection3Title">RP Mapping and Redundancy</h5>
<p class="docText">For PIM-SM to build and use a shared tree, it is critical for the PIM routers to know what RP to use for each multicast group. IPv6 did not inherit all mechanisms developed for distributing RP-to-group mapping information in IPv4 multicast. For example, there is no standardization work done for Auto-RP in IPv6 at the time of this writing. On the other hand, the larger IPv6 addresses support a new, IPv6-specific mechanism that is described in this section.</P>
<a name="ch06lev4sec7"></a>
<h5 class="docSection4Title">Static RP</h5>
<p class="docText">A basic way to advise routers of the RP that should be used for a multicast group is to statically configure this information on each one of them. <a class="docLink" href="#ch06ex09">Example 6-9</a> shows the configuration of this static mapping on a Cisco router.</p>
<a name="ch06ex09"></a><h5 class="docExampleTitle">Example 6-9. Configuring 2001:1::1 as a Static RP for (*,FF0A ::1)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<pre>Router(config)# <span class="docEmphStrong">ipv6 access-list RP-group</span>
Router(config-ipv6-acl)# <span class="docEmphStrong">permit ipv6 any host ff0a::1</span>
Router(config)# <span class="docEmphStrong">ipv6 pim rp-address 2001:1::1 RP-group</span></pre><br>

</td></tr></table></p>
<p class="docText">Despite its simplicity, this method has the potential of being a provisioning and network management nightmare. It also limits significantly the ways in which you can implement RP redundancy in the network.</p>

<a name="ch06lev4sec8"></a>
<h5 class="docSection4Title">Bootstrap Router</h5>
<p class="docText">Bootstrap router (BSR) provides dynamic distribution of RP-to-group mapping information across a PIM domain. A set of routers is configured as candidate BSRs. Each of them sends bootstrap messages (BSMs) that are flooded throughout the domain. The messages contain a Priority field. If a candidate BSR receives a BSM from another candidate with a higher priority, it stops sending BSMs for a given period of time. Through this election process, a single BSR is left flooding the domain with BSMs and thus providing the RP-to-group mapping information.</p>
<a name="ch06note19"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText"><a name="iddle1316"></a><a name="iddle1844"></a>The BSR election tiebreaker between two candidates with equal priorities is their advertised address. The highest address wins.</p>
</div><br>
<p class="docText">A Cisco router is globally configured to be a candidate BSR with the following command:</p>
<div class="docText"><pre><span class="docEmphStrong">ipv6 pim bsr candidate bsr <span class="docEmphasis">&lt;address of the candidate&gt; &lt;hash-mask length&gt;</span> priority</span>
  <span class="docEmphBoldItalic">&lt;priority value&gt;</span></pre></div><br>
<p class="docText">You can view the result of the BSR election process with the <span class="docEmphStrong">show ipv6 pim bsr election</span> command.</P>
<p class="docText">A set of routers (same as or different from the BSR candidates) is configured as candidate RPs, and they periodically send messages to the BSR to indicate their willingness to be the RP for a list of groups included in the messages. The RP candidates are globally configured: <span class="docEmphStrong">ipv6 pim bsr candidate rp</span> &lt;<span class="docEmphasis">address of the candidate</span>&gt; [<span class="docEmphasis">access-list identifying the groups</span>] &lt;<span class="docEmphasis">priority</span>&gt;.</P>
<p class="docText">You can view a list of candidate RPs by using the <span class="docEmphStrong">show ipv6 pim bsr rp-cache</span> command.</P>
<a name="ch06note20"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">Cisco routers identify the BSR address from the bootstrap messages. They forward only those BSMs that are received over the interface that matches the RPF calculation for the BSR.</P>
</div><br>
<p class="docText">The BSR builds a subset of RPs willing to serve the PIM domain. It advertises these candidate RPs and the groups they are willing to serve with the help of BSMs. The messages are flooded throughout the domain, and PIM routers store the advertised mapping information. You can use the <span class="docEmphStrong">show ipv6 pim group-map</span> command to view the RP-to-group mapping. If a candidate RP is no longer available, the BSR adjusts the RP-to-group mapping information in the BSMs. This adjustment provides the PIM domain with a certain level of RP redundancy.</p>
<p class="docText">Domain control has to be implemented for the BSMs, too. These flooded packets should not be allowed to leave the designated BSR domain. The interfaces at the edge of the domain are enabled (interface command <span class="docEmphStrong">ipv6 pim bsr border</span>) to drop any BSMs of any scope.</p>

<a name="ch06lev4sec9"></a>
<h5 class="docSection4Title">Embedded RP</h5>
<p class="docText">After all the bits that were reserved by the IPv6 addressing architecture for scopes and flags, there still are plenty left in an IPv6 multicast address to include the address of the RP to be used for a multicast group. This simple mechanism of providing the RP-to-group mapping information is called <span class="docEmphasis">embedded RP</span>. It relies on the unicast-prefix multicast group addresses described in RFC 3306, with an additional flag that indicates the presence of the RP address. <a class="docLink" href="#ch06fig05">Figure 6-5</a> details the procedure of building this type of multicast addresses.</p>
<a name="ch06fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 6-5. Creating an Embedded RP Multicast Address</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/06fig05_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="279" SRC="images/06fig05.jpg"></p>
</center></p><br>
<p class="docText"><a class="docLink" href="#ch06ex10">Example 6-10</a> applies the procedure described in <a class="docLink" href="#ch06fig05">Figure 6-5</a> to build a multicast group address that embeds the RP address 2001:D:AAAA:1::2.</P>
<a name="ch06ex10"></a><h5 class="docExampleTitle">Example 6-10. Generating an Embedded RP Multicast Address</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>


<pre>RP Address: 2001:D:AAAA:1::2
<span class="docEmphMark">RP Address Network Length: 64 (decimal) -&gt; 40 (hex)</span>
<span class="docEmphMark">RP Interface ID: <span class="docEmphStrong">2</span></span>
Scope for the Embedded RP multicast address: 8
Group ID: 100
<span class="docEmphMark">Embedded RP multicast address: FF78:240:2001:D:AAAA:1:0:100</span></pre><br>

</td></tr></table></P>
<p class="docText">The elements used in building an embedded RP multicast address are highlighted in <a class="docLink" href="#ch06ex10">Example 6-10</a>. Highlights are used to identify the contribution of each element in the resulting embedded RP address. With this mechanism, each registered unicast address automatically comes with 256 RP addresses for the 16 address scopes and 2<sup>32</sup> multicast groups for each RP.</p>
<p class="docText">Routers that support the embedded RP concept search for the RP address in MLD reports, PIM traffic, or data traffic by looking at the destination multicast addresses that have the R flag set to 1. The router whose address is advertised in the multicast address has to be statically enabled to be an RP.</p>
<p class="docText">Embedded RP does not require changes to the PIM protocol, and it can in fact replace BSR for RP-to-group mapping within a PIM domain. It can also be used for mapping RPs to <a name="iddle1609"></a>group addresses across different PIM domains. However, you must consider a few drawbacks:</p>
<ul><LI><p class="docList">Embedded RP does not support PIM-Bidir.</P></LI><li><p class="docList">Only one RP address can be used for each group. This means that any RP redundancy mechanism used with embedded RP must have an anycast flavor.</p></li><li><p class="docList">Not all vendors support embedded RP. If the network includes routers without support for the feature, you should configure those routers for static RP or BSR.</p></li></ul>
<p class="docText">The embedded RP functionality runs by default on multicast-enabled Cisco routers. You can disable it explicitly on routers operating in domains that do not support the feature across various types of platforms.</p>

<a name="ch06lev4sec10"></a>
<h5 class="docSection4Title">RP Redundancy</h5>
<p class="docText">A single RP per PIM domain represents a single point of failure. Therefore, it is important to consider ways to provide RP redundancy. A certain level of redundancy was already mentioned in the context of BSR. If a candidate router stops advertising its willingness to be an RP (either because of reconfiguration or device/network failure), the BSR removes it from the RP set, and the routers in the domain update their RP-to-group mapping information accordingly.</p>
<p class="docText">There remains, however, the need to identify RP redundancy strategies for deployments that use, for example, static RP or embedded RP. A possible solution is to simulate an anycast-like behavior by configuring two routers with the same RP address but different prefix lengths, such as RP1=2001:D:AAAA:1::2/128 and RP2=2001:D:AAAA:1::2/127. Because of the longest prefix match, RP1 will always be reached first by both sources and PIM routers joining the ST. If RP1 fails, its role is picked up by RP2.</p>
<a name="ch06note21"></a><div class="docNote"><p class="docNoteTitle">Note</p>

<p class="docText">The redundancy options discussed do not provide the RPs with a mechanism to exchange source registration information. In IPv4, the Multicast Source Discovery Protocol (MSDP) performed this function. MSDP in IPv4 was considered a temporary solution. Despite not evolving or even becoming a standard, MSDP is still used in IPv4 multicast deployments. IPv6 did not pursue MSDP-IPv6, and because of that the MSDP/anycast-RP redundancy solution, currently widely used in IPv4 multicast deployments, is not available in IPv6. MSDP inadvertently provided another fringe benefit: RP load balancing. Mechanisms will have to be developed to provide this functionality in IPv6.</p>
</div><BR>


<a name="ch06lev3sec8"></a>
<H5 class="docSection3Title">Service Models</H5>
<p class="docText">The design of the multicast service deployment in a network should be tailored to best fit the applications that must be supported by the network. The two popular multicast service <a name="iddle1105"></a><a name="iddle1603"></a><a name="iddle1611"></a><a name="iddle1933"></a><a name="iddle1938"></a>models are Any Source Multicast (ASM) and Source Specific Multicast (SSM). Each model leverages a subset of the protocols and mechanisms discussed in this chapter, and each has its strengths and weaknesses. This section briefly reviews ASM and SSM and highlights the IPv6 specificities.</P>
<a name="ch06lev4sec11"></a>
<H5 class="docSection4Title">ASM Versus SSM</h5>
<p class="docText">The simplest service model is the SSM. It is very well suited for content delivery where a set of fixed sources provides video or audio multicast streams to interested users, as shown in <a class="docLink" href="#ch06fig06">Figure 6-6</a>. The important thing to notice is the localized nature of the sources. A customer's set-top box or PC can map video/audio channel IDs to (S,G)s, and it can handle the process of joining a requested (S,G) when the corresponding channel is selected.</p>
<a name="ch06fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 6-6. Deployment Models, SSM and ASM</h5>
<p class="docText"><div class="v1"><a target="_self" href="images/06fig06_alt.jpg">[View full size image]</a></div><img border="0" alt="" width="500" height="399" SRC="images/06fig06.jpg"></p>
</center></p><br>
<p class="docText"><a name="iddle1093"></a><a name="iddle1103"></a>The following is needed to deploy SSM:</p>
<ul><li><p class="docList">MLDv2 or MLDv1 combined with SSM mapping-capable routers (see the earlier section &quot;<a class="docLink" href="#ch06lev4sec2">Source Specific Multicast Mapping for MLDv1</a>&quot;).</p></LI><li><p class="docList">Use of multicast group address of the SSM format FF3X::.</p></LI><LI><p class="docList">PIM-SSM, which is very easy to deploy. It does not require RPs and the overhead necessary to manage them.</p></li></ul>
<p class="docText">SSM has no domain constraints. However, if the number of (S,G)s is very large, the memory and processing resources of the routers supporting the multicast service might be excessively taxed.</p>
<p class="docText">In an environment where a large number of sources are used and the applications are more dynamic in nature or multiparty oriented, the use of a shared tree for protocol control might become justifiable (see <a class="docLink" href="#ch06fig06">Figure 6-6</a>). Note that in this example, sources are located in different parts of the network. A shared tree in this case would reduce the amount of MDT state that has to be maintained by the routers in the network. The service model applied in this case is ASM. The use of an ST and the mandatory RPs adds complexity to the ASM model.</P>
<p class="docText">The following is needed to deploy ASM:</p>
<ul><li><p class="docList">MLDv1 or MLDv2</p></LI><LI><p class="docList">PIM-SM or PIM-Bidir</P></li><li><p class="docList">Static RP, BSR, or embedded RP for RP management</p></li><li><p class="docList">Anycast RP solution to provide redundancy for static or embedded RP</p></li><li><p class="docList">Domain control measures</p></li></ul>
<p class="docText">SSM can, in principle, support most commonly deployed multicast applications. Its simplicity trades off for scalability limitations. If an application can be supported by both SSM and ASM, the first option in designing the multicast service deployment should be SSM. Both SSM and ASM models are fully supported on the Cisco routers. They can easily coexist in the same network.</p>

<a name="ch06lev4sec12"></a>
<h5 class="docSection4Title">Intradomain Versus Interdomain ASM</h5>
<p class="docText">The ASM model requires the use of RPs. For scalability and manageability considerations, you can partition a network into PIM domains. Each PIM domain has its own set of RPs servicing the (*,G)s.</P>
<p class="docText">The intradomain multicast refers to the service deployment within a single PIM domain. All the concepts discussed so far for ASM and SSM apply within a PIM domain. The questions are these: What happens when multiple PIM domains are defined in a network? How will they interact, and how should interdomain multicast be deployed?</P>
<p class="docText"><a name="iddle1612"></a><a name="iddle1995"></a>If you deploy ASM across multiple domains, the following information has to be exchanged between domains:</P>
<UL><LI><p class="docText"><span class="docEmphStrong">Multicast routes</span> MP-BGP takes care of this function in both IPv4 and IPv6.</p></li><li><p class="docText"><span class="docEmphStrong">RP-to-group mapping</span> In IPv4 and IPv6, it can be done with the help of BSR. With IPv6, you have an additional option: using embedded RP.</p></li><li><p class="docText"><span class="docEmphStrong">Source registration information</span> In IPv4, MSDP takes care of this function. Because in IPv6 there is no MSDP-like mechanism in place, only one of the domains can have RPs.</p></li></ul>
<p class="docText">Because of the lack of MSDP-IPv6 or similar functionality, in IPv6 the only option available is to use a single PIM domain for ASM deployments. SSM will always be the easy alternate solution for interdomain multicast.</p>


<a name="ch06lev3sec9"></a>
<h5 class="docSection3Title">Multicast over Tunnels</h5>
<p class="docText"><a class="docLink" href="ch03.html#ch03">Chapter 3</a> describes the various tunneling mechanisms that were developed to facilitate the migration from IPv4 to IPv6. When choosing tunneling mechanisms for IPv6 deployments, you should consider the long-term service offerings. <a class="docLink" href="#ch06table03">Table 6-3</a> notes multicast services provided by the various tunneling mechanisms.</P>
<a name="ch06table03"></a><p><table cellspacing="0" class="allBorders" border="1" RULES="all" cellpadding="4"><caption><h5 class="docTableTitle">Table 6-3. IPv6 Multicast Support over Tunnels</H5></caption><colgroup><col width="120"><col width="80"><col width="100"><col width="200"></colgroup><thead><TR><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">Tunnel Type</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">Cisco Support</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">IPv6 Multicast Support</p></th><th class="thead" scope="col" align="left" valign="bottom"><p class="docText">Comments</p></th></TR></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">6over4</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">No</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Historic.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">6to4</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">No</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">At the time of this writing, there is no active work within IETF on multicast support over this tunneling mechanism.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Manual</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText">IPv6 over IPv4 GRE</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">IPv4-compatible</p>
<p class="docText">IPv6 tunnel</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">No</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Being deprecated; choose ISATAP instead.</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">ISATAP</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Yes</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">No</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">At the time of this writing, there is no active work within IETF on multicast support over this tunneling mechanism.</p></td></tr></table></p><BR>
<p class="docText">It is also important to consider the implications of deploying multicast over certain tunnels. For example, the 6over4 tunnels require an IPv4 multicast infrastructure to support IPv6 multicast.</p>
<p class="docText">IPv6 islands can also be interconnected with other types of tunnels, such as pseudowire layer 2 tunnels. The tunnels are layer 3 transparent, and they support multicast. The static nature of such tunnels makes for a deployment that scales poorly.</p>

<a name="ch06lev3sec10"></a>
<H5 class="docSection3Title">Multicast over MPLS Infrastructures</H5>
<p class="docText"><a name="iddle1572"></a><a name="iddle1607"></a><a name="iddle1620"></a><a name="iddle1630"></a>During the past decade, MPLS has become a mainstay in the core of most major service provider networks. Proposals are now being made for its deployment in enterprise networks, too. Along with MPLS came virtual private networks (VPNs), a popular service deployed over MPLS infrastructures. This service enables enterprises to securely interconnect remote locations in a more cost-effective way than leasing lines. (For more information on VPNs, see <a class="docLink" href="ch07.html#ch07">Chapter 7</a>, &quot;VPN IPv6 Architecture and Services.&quot;)</p>
<p class="docText">Currently, there is no intrinsic support for IPv4 multicast over MPLS networks. RFC 3353 provides a review of the challenges faced by multicast in an MPLS environment. A possible deployment approach is for the multicast to be forwarded untagged, completely ignoring the underlying MPLS infrastructure. This solution is complicated by the fact that a VPN's multicast traffic has to be isolated from that of other VPNs. The Cisco solution to this control-plane problem is called <span class="docEmphasis">multicast VPN</span> (MVPN).</p>
<p class="docText">At the control-plane level, MVPN is virtual routing and forwarding (VRF) aware. On the PE router, a PIM instance runs for each VRF and it performs the multicast routing function between the CEs and PEs that belong to that VPN. The multicast routing and forwarding table created is called a multicast VRF (MVRF). Each MVRF is assigned a multicast group address that is used for forwarding only its traffic (GRE encapsulated) between PE routers. These multicast groups are manually mapped to MVRFs, and they are managed by a common, global PIM instance. The important thing to remember is that the actual forwarding across the service provider network, within the global MD, is done at layer 3 and that the presence or absence of MPLS is irrelevant.</p>
<p class="docText">Unlike IPv4, currently there is no MVPN-like solution available for IPv6, which proves particularly relevant when considering 6PE, the migration approach discussed in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>. 6PE is a practical way to provide IPv6 unicast service over an MPLS network with minimal impact at the edge and no impact on the core. 6PE itself can be viewed as a global VPN. In the absence of an MVPN-like solution for 6PE, others need to be found to provide multicast support. Such solutions will have to consider all the requirements that were placed on 6PE as a transition mechanism (no impact on the core and so forth). One option being worked on is to look at the MPLS cloud as an NBMA from the 6PE router perspective.</p>
<a name="ch06note22"></a><div class="docNote"><p class="docNoteTitle">Note</P>

<p class="docText">Of course, you can complement a 6PE deployment with an overlay dedicated to the multicast service. You can use fully meshed layer 2 MPLS-based tunnels to build such an overlay. The drawback is that an overlay entails additional operational and management costs.</p>
</div><br>
<p class="docText"><a name="iddle1941"></a>Work is currently being done in IETF to solve the multicast over MPLS problem. A solution to this problem can be leveraged to provide multicast support over 6PE and 6VPE, too.</p>



<a href="22971536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch06lev1sec2.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>